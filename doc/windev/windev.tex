\documentclass[dvipdfm,11pt]{article}
\usepackage[dvipdfm]{hyperref} % Upgraded url package
\parskip=.1in

% Formatting conventions for contributors
% 
% A quoting mechanism is needed to set off things like file names, command
% names, code fragments, and other strings that would confuse the flow of
% text if left undistinguished from preceding and following text.  In this
% document we use the LaTeX macro '\texttt' to indicate such text in the
% source, which normally produces, when used as in '\texttt{special text}',
% the typewriter font.

% It is particularly easy to use this convention if one is using emacs as
% the editor and LaTeX mode within emacs for editing LaTeX documents.  In
% such a case the key sequence ^C^F^T (hold down the control key and type
% 'cft') produces '\texttt{}' with the cursor positioned between the
% braces, ready for the special text to be typed.  The closing brace can
% be skipped over by typing ^e (go to the end of the line) if entering
% text or ^C-} to just move the cursor past the brace.

% LaTeX mode is usually loaded automatically.  At Argonne, one way to 
% get several useful emacs tools working for you automatically is to put
% the following in your .emacs file.

% (require 'tex-site)
% (setq LaTeX-mode-hook '(lambda ()
%          		 (auto-fill-mode 1)
%          		 (flyspell-mode 1)
%          		 (reftex-mode 1)
% 			 (setq TeX-command "latex")))


\begin{document}
\markright{MPICH2 Windows Development Guide}
\title{{\bf MPICH2 Windows Development Guide}\thanks{This work was supported by the
    Mathematical, Information, and Computational Sciences Division
    subprogram of the Office of Advanced Scientific Computing Research,
    SciDAC Program, Office of Science, U.S. Department of Energy, under
    Contract
    W-31-109-ENG-38.}\\
  Version 1.0.2\\
  Mathematics and Computer Science Division\\
  Argonne National Laboratory}

\author{David Ashton}

\maketitle
\cleardoublepage

\pagenumbering{roman}
\tableofcontents
\clearpage

\pagenumbering{arabic}
\pagestyle{headings}

\section{Introduction}
\label{sec:intro}
This manual describes how to set up a Windows machine to build and test MPICH2 on.

\section{Build machine}
\label{sec:machine}

Build a Windows XP or Windows Server 2003 machine.  Place this machine in the MPICH domain
and create a user in the domain with the same name as your MCS user name.  Use your MCS 
password for this new account.  This isn't a requirement; you can create any username you
want with any password you want and it doesn't have to be part of the MPICH domain.
But it makes life a lot easier if you do.

\section{Test machine}
\label{sec:test_machine}

Build a Windows XP or Windows Server 2003 machine on a 32bit CPU.
Also build a Windows Server 2003 X64 machine to test the Win64 distribution.

%Note: peta07 and peta08.mcs.anl.gov have Mellanox Infiniband cards in them for testing
%the Infiniband channel under Windows.

\section{Software}

This section describes the software necessary to build MPICH2.

\subsection{Packages}
\label{sec:packages}

To build MPICH2 you will need:
\begin{enumerate}
\item Microsoft Developer Studio .NET 2003
\item Microsoft Platform SDK
\item cygwin - full installation
\item Intel Fortran compiler IA32
\item Intel Fortran compiler EMT64
%\item Mellanox 32bit and 64bit Infiniband libraries for VAPI and IBAL
\item Java SDK
\end{enumerate}

Microsoft Developer Studio can be found on the CDs from an MSDN subscription.  The
2003 version is needed to get a compiler that is up to date on standards compliance.  This
is needed to compile the C++ interface and handle types like ``long long''.

The Platform SDK can also be found on the MSDN CDs or downloaded from Microsoft.com.  The
latest version as of the writing of this document was Platform SDK - Windows Server 2003 SP1.
This package needs to be installed to get the Win64 compilers.

The Intel Fortran compilers need to be installed after Developer Studio and the PSDK because
they integrate themselves into those two products.  The regular IA32 compiler needs to be 
installed and the EMT64 compiler needs to be installed.  They are two separate packages and 
they require a license file to use.  The license file is for a single user on a single 
machine.

%The Mellanox Infiniband libraries are simply a package that needs to be unzipped.  They don't
%need to be installed because the build machine won't have Infiniband hardware on it.  I put
%the 32bit vapi package in \texttt{C:$\backslash$Mellanox} and the 64bit package in
%\texttt{C:$\backslash$Mellanox64}.  The ibal package should go in 
%\texttt{c:$\backslash$ibal} with both the 32bit and 64bit libraries in 
%\texttt{c:$\backslash$ibal$\backslash$Install$\backslash$x86} and 
%\texttt{c:$\backslash$ibal$\backslash$Install$\backslash$AMD64}.  If different pathes are 
%chosen then the scripts and Visual Studio project files will need to be updated to reflect 
%this change.

cygwin needs to be installed to get cvs, perl and ssh.  MPICH2 can also be built completely
under cygwin just like a Unix build so I install all of cygwin.  The latest cygwin packages
are needed to build MPICH2 under cygwin and the MCS mirror site for cygwin does not contain
the latest versions.  So I would select a download site other than the mcs mirror site during
the cygwin install.  I also select to use the DOS file format during the install process for 
cygwin.

After installing cygwin, bring up a cygwin bash shell and generate some ssh keys.  I believe
the command is: \texttt{ssh-keygen -t dsa}.  Then copy the public key generated to your
mcs \texttt{/home/you/.ssh/authorized\_keys} file.  This will allow you to ssh from this machine
to harley.mcs.anl.gov without typing a password.  This is important in order for the 
automated scripts to run without user intervention.

Assuming you installed cygwin to the default \texttt{c:$\backslash$cygwin} directory, add 
\texttt{c:$\backslash$cygwin$\backslash$bin} to your path environment variable.  This is 
required so the automated scripts can run tools like ssh and perl without specifying the 
full path.

The Java SDK needs to be installed so the logging library can be compiled.  This can be a problem
because MPICH2 needs to know the include path for \texttt{jni.h}.  Since the JSDK can be installed anywhere
and the path includes the version there isn't a standard path that can be added to the MPICH2 
projects.  Currently \texttt{c:$\backslash$j2sdk1.4.2\_06$\backslash$include} is used in
\texttt{mpich2$\backslash$src$\backslash$util$\backslash$logging$\backslash$rlog$\backslash$TraceInput$\backslash$TraceInput.vcproj}.
This will have to be modified if you install a different version of the JSDK.

Run the following command from a command prompt to change the Windows script engine from
GUI mode to console mode:
\begin{verbatim}
cscript //H:cscript
\end{verbatim}

\section{Building MPICH2}
\label{sec:building}

This section describes how to make various packages once you have a working build machine.

\subsection{Developer Studio automated 32bit build}
\label{sec:devstudiobuild}

The easist way to build an MPICH2 distribution is to use the Developer Studio environment
and the makewindist.bat script from the top level of the mpich2 source tree.  You can check
out mpich2 from CVS or you can simply copy this batch file from the distribution.  The batch
file knows how to check out mpich2 so it the only file required to make a distribution.

The product GUIDs need to be changed when a new release is created.  To do this run 
``\texttt{perl update\_windows\_version $<$new\_version$>$}''.  Run this script with mpich2/maint 
as the current directory so the project files can be found.  Example:
\begin{verbatim}
perl update_windows_version 1.0.3
\end{verbatim}

Or you can modify the project files by hand.  Edit mpich2/maint/mpich2i.vdproj.  The ProductCode
and PackageCode entries need to be changed to use new GUIDs.  Under Unix or Windows, uuidgen can 
be used to generate a new GUID.  The ProductVersion entry needs to be changed to match the 
version of MPICH2.

Once the version and GUIDs have been updated, commit the changes to mpich2i.vdproj to cvs.

Then you can build a distribution.

Bring up a build command prompt by selecting Start$\to$Progams$\to$Microsoft Visual Studio 
.NET 2003$\to$Visual Studio .NET Tools$\to$Visual Studio .NET 2003 Command Prompt.

Change directories to wherever you want to create the distribution.  mpich2 will be checked 
out under the current directory.  Run the makewindist batch file:

\begin{verbatim}
makewindist.bat --with-checkout
\end{verbatim}

Since there are no bugs in MPICH2 everything will work automatically.  The batch file does the
following steps:
\begin{enumerate}
\item check out mpich2allWithMPE and change into the mpich2 directory
\item ssh to harley.mcs.anl.gov and checkout mpich2.  Then run \texttt{maint/updatefiles} on
harley, collect all the generated \texttt{.h.in} files and copy them back to the Windows
machine.
\item run ``\texttt{winconfigure.wsf --cleancode}'' to configure mpich2 for Windows and output
all the generated files like mpi.h and the fortran interface files, etc.
\item run the Developer Studio command line tool to build all the pieces of MPICH2.  This
includes each of the channels - sock, ssm, shm, sshm, and the multi-threaded sock
channel.  Two versions of each channel are built, the regular release build and the rlog
profiled version.  The mpi wrapper channel selector dll is built and three Fortran interfaces
are built, one for each set of common symbol types and calling conventions.  mpiexec and
smpd are built along with the Windows GUI tools and the cygwin libraries.  (These are the cygwin
link libraries to use the Windows native build of MPICH2, not a Unix-style build of MPICH2
under cygwin.)
\item package up everthing into \texttt{maint$\backslash$ReleaseMSI$\backslash$mpich2.msi}.
\end{enumerate}

When the batch file is finished you will be left with a mpich2.msi file that can be used to
install MPICH2 on any Win32 machine.  This file can be re-named to match our release naming 
conventions.

\subsection{Platform SDK builds}
\label{sec:psdk_build}

The makefile in the \texttt{mpich2$\backslash$winbuild} directory builds a distribution based 
on what compilers are specified in the environment so it can be used to compile any version of
MPICH2.  The following targets can all be built with this mechanism:
\begin{itemize}
\item Win64 X64
\item Win64 IA64
\item Win32 x86
\end{itemize}

But first you need to have mpich2 checked out and configured before building.
\begin{enumerate}
\item bring up a command prompt and check out mpich2: 

\texttt{cvs -d :ext:ashton@harley.mcs.anl.gov:/home/MPI/cvsMaster co mpich2allWithMPE}.  Replace ashton with your own username.
\item cd into mpich2
\item run \texttt{getdotin.bat}
\item run \texttt{winconfigure.wsf --cleancode}
\end{enumerate}

To build the Win64 X64 distribution do the following:
\begin{enumerate}
\item Bring up a build command prompt from the PSDK.  It can be found here: Start$\to$Programs
$\to$Microsoft Platform SDK for Windows Server 2003 SP1$\to$Open Build Environment Window$\to$
Windows Server 2003 64-bit Build Environment$\to$Set Win Svr 2003 x64 Build Env (Retail)
\item Run \texttt{$\backslash$Program Files$\backslash$Intel$\backslash$Fortran$\backslash$compiler80$\backslash$Ia32e$\backslash$Bin$\backslash$ifortvars.bat}
\item cd into \texttt{mpich2$\backslash$winbuild}
\item run \texttt{build.bat 2>\&1 | tee build.x64.out}
\end{enumerate}

To build the Win64 IA64 distribution do the following:
\begin{enumerate}
\item Bring up a build command prompt from the PSDK.  It can be found here: Start$\to$Programs
$\to$Microsoft Platform SDK for Windows Server 2003 SP1$\to$Open Build Environment Window$\to$
Windows Server 2003 64-bit Build Environment$\to$Set Win Svr 2003 IA64 Build Env (Retail)
\item Run \texttt{$\backslash$Program Files$\backslash$Intel$\backslash$Fortran$\backslash$compiler80$\backslash$Itanium$\backslash$Bin$\backslash$ifortvars.bat}
\item cd into \texttt{mpich2$\backslash$winbuild}
\item run \texttt{build.bat 2>\&1 | tee build.ia64.out}
\end{enumerate}

To build the Win32 x86 distribution do the following:
\begin{enumerate}
\item Bring up a build command prompt from the PSDK.  It can be found here: Start$\to$Programs
$\to$Microsoft Platform SDK for Windows Server 2003 SP1$\to$Open Build Environment Window$\to$
Windows 2000 Build Environment$\to$Set Windows 2000 Build Environment (Retail)
\item Run \texttt{$\backslash$Program Files$\backslash$Intel$\backslash$Fortran$\backslash$compiler80$\backslash$Ia32$\backslash$Bin$\backslash$ifortvars.bat}
\item cd into \texttt{mpich2$\backslash$winbuild}
\item run \texttt{build.bat 2>\&1 | tee build.x86.out}
\end{enumerate}

\section{Distributing MPICH2 builds}
\label{sec:distribute}

If you built an .msi file using the Developer Studio build process \ref{sec:devstudiobuild} then
all you have to do is rename the \texttt{mpich2.msi} file to something appropriate like
\texttt{mpich2-1.0.3-1-win32-ia32.msi}

If you built using the Platform SDK build process \ref{sec:psdk_build} then the output files
are left in their build locations and need to be collected and put in a zip file for
distributing.  This process should be automated with a script.

\section{Testing MPICH2}
\label{sec:testing}

Run the \texttt{testmpich2.wsf} script to checkout mpich2, build it, install it, checkout 
the test suites, build them, run the test suites, and collect the results in a web page.

\subsection{Testing from scratch}
Explain the use of testmpich2.wsf.

Run ``\texttt{testmpich2.wsf}'' without any parameters and it will create a \texttt{testmpich2}
subdirectory and check out into that directory mpich2 and the test suites - c++, mpich, intel
and mpich2.  It will then build mpich2 and all the tests from the test suites.  Then it will run
the tests and place a summary in \texttt{testmpich2$\backslash$summary$\backslash$index.html}.

\subsection{Testing a built mpich2 directory}
Explain how to run \texttt{testmpich2.wsf} if you have the mpich2 source tree on a machine and you 
have already built all of mpich2.

Here is a sample batch file to test mpich2 that has already been built in c:$\backslash$mpich2:
\begin{verbatim}
testmpich2.wsf /mpich2:c:\mpich2 /make- /configure- /buildbatch
pushd testmpich2\buildMPICH
call mpich_cmds.bat
popd
pushd testmpich2\buildCPP
call cpp_cmds.bat
popd
pushd testmpich2\buildINTEL
call intel_cmds.bat
popd
pushd testmpich2\buildMPICH2
call mpich2_cmds.bat
popd
testmpich2.wsf /mpich2:c:\mpich2 /make- /configure- /summarize
\end{verbatim}

\subsection{Testing an existing installation}
Explain the use of testmpich2.wsf to test an existing installation, one that was installed
with the .msi distribution.

\section{Development issues}
This section describes development issues that are particular to the Windows build.

Whenever a .h.in file is created on the Unix side, winconfigure.wsf needs to be updated to
create the .h file from the .h.in file.  Use cut and paste to copy an existing section in 
winconfigure.wsf that already does this and rename the file names.

When new definitions are added to the .h.in files these definitions, usually in the form HAVE\_FOO 
or USE\_FOO, need to be added to the AddDefinitions function in winconfigure.wsf.  Simply add 
new cases to the big case statement as needed.  winconfigure.wsf warns you of definitions that 
are not in the case statement.

Whenever a @FOO@ substitution is added on the Unix side, winconfigure.wsf needs to be updated
to handle the substitution.  Find the ReplaceAts function in winconfigure.wsf and add the 
substitution to the big case statement.  winconfigure.wsf warns you of new substitutions that
have not been added to the case statement.

\section{Runtime environment}

This section describes the mpiexec environment that is particular to Windows.

\subsection{User credentials}
mpiexec must have the user name and password to launch MPI applications in the context of
that user.  This information can be stored in a secure encrypted manner for each user on a
machine.  Run \texttt{mpiexec -register} to save your username and password.  Then mpiexec
will not prompt you for this information.

This is also true for a nightly build script.  The user context under which the script is 
run must have saved credentials so mpiexec doesn't prompt for them.  So scripts won't hang,
mpiexec provides a flag, \texttt{-noprompt}, that will cause mpiexec to print out errors in 
cases when it normally would prompt for user input.  This can also be specified in the 
environment with the variable MPIEXEC\_NOPROMPT.

\subsection{MPICH2 channel selection}
MPICH2 for Windows comes with multiple complete implementations of MPI.  These are called
channels and each build represents a different transport mechanism used to move MPI messages.
The default channel uses sockets for communication.  There are two channels that use only
shared memory.  There is a channel that uses both sockets and shared memory.  There is a
channel that uses Infiniband.  And there is a thread-safe version of the sockets channel.

The short names for the channels are: sock, shm, sshm, ssm, mt.

These channels can be selected at runtime with an environment variable: MPICH2\_CHANNEL.
The following is an example that uses the Infiniband channel instead of the default sockets
channel:

\begin{verbatim}
mpiexec -env MPICH2_CHANNEL ib -n 4 myapp.exe
or
mpiexec -channel ib -n 4 myapp.exe
\end{verbatim}

If you specify \texttt{auto} for the channel then mpiexec will automatically choose a
channel for you.
\begin{verbatim}
mpiexec -channel auto -n 4 myapp.exe
\end{verbatim}
The rules are:
\begin{enumerate}
\item If numprocs is less than 8 on one machine, use the shm channel
\item If numprocs is greater than 7 on one machine, use the sshm channel
\item If running on multiple machines, use the ssm channel.  This channel can be changed 
using winconfigure.
\end{enumerate}

\subsection{MPI apps with GUI}
Many users on Windows machines want to build GUI apps that are also MPI applications.  This is
completely acceptable as long as the application follows the rules of MPI.  MPI\_Init must be
called before any other MPI function and it needs to be called soon after each process starts.
The processes must be started with mpiexec but they are not required to be console applications.

The one catch is that MPI applications are hidden from view so any Windows that a user 
application brings up will not be able to be seen.  mpiexec has an option to allow the MPI 
processes on the local machine to be able to bring up GUIs.  Add -localroot to the mpiexec
command to enable this capability.  But even with this option, all GUIs from processes on 
remote machines will be hidden.

So the only GUI application that MPICH2 cannot handle by default would be a video-wall type
application.  But this can be done by running smpd.exe by hand on each machine instead of
installing it as a service.  Log on to each machine and run ``\texttt{smpd.exe -stop}'' 
to stop the service and then run ``\texttt{smpd.exe -d 0}'' to start up the smpd again.  
As long as this process is running you will be able to run applications where every process 
is allowed to bring up GUIs.

\subsection{Security}
MPICH2 can use Microsoft's SSPI interface to launch processes without using any user 
passwords.  This is the most secure way to launch MPI jobs but it requires the machines to be 
configured in a certain way.
\begin{itemize}
\item All machines must be part of a Windows domain.
\item Each machine must have delegation enabled.
\item Each user that will run jobs must be allowed to use delegation.
\end{itemize}

If the machines are set up this way then an administrator can set up MPICH2 for passwordless
authentication.  On each node, a domain administrator needs to execute the following:
``\texttt{smpd -register\_spn}''.

Then a user can add the \texttt{-delegate} flag to their mpiexec commands and the job startup 
will be done without any passwords.  Example:
\begin{verbatim}
mpiexec -delegate -n 3 cpi.exe
\end{verbatim}

\end{document}
