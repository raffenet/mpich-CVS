\subsection{Changing the Routines Used to Implement MPI Collectives}

The MPICH2 code (like the original MPICH) allows the developer and
sophisticated user to selectively replace the code that is used to
implement any and all of the MPI collective routines.  For wholesale,
build-time replacement, the easiest approach is to select an alternate
collective operation subdirectory, following the model of that in
\file{src/mpi/coll}.  It is more likely, however, that you will wish
to replace just a few routines.  This can be done at runtime by
calling the routine \code{MPIX_Comm_replace_collop}:

\begin{verbatim}
int MPIX_Comm_replace_collop( MPI_Comm comm, 
                              const char name[],
                              void (*meth)(void) )
\end{verbatim}
where the three arguments have the following meanings:
\begin{description}
\item[\code{comm}]The communicator for which the operation should be
  replaced.  To replace the operation on all communicators created
  after the call, use \code{MPI_COMM_NULL} (this is similar to the use
  of \code{MPI_FILE_NULL} when setting the default error handler).
\item[\code{name}]The name of the MPI routine whose operation is to be
  replaced.  For example, use \code{"MPI_Allreduce"} to select the
  \code{MPI_Allreduce} operation.
\item[\code{meth}]A pointer to the function to use to implement the
  operation.  The function must take the same parameters as the
  function being replaced; the \code{void (*)(void)} type here is used
  simply to allow any function pointer.
\end{description}

Question:  Should we also have a ``replace multiple'' that takes
arrays of names and functions?  I don't think that there is enough of
a reason for that.  

Another possibility is to expose the structure that is used for the
function pointers; I don't think that we should do that because it
will cause problems if the structure is ever changed.

Still to do: explain how to change the default entries at build-time,
and how to allow the device code to modify the collective operation
table.  We should also describe the table, including the use of
``null'' implies use the default routine.  
Note that if the device defines the following macro
\begin{verbatim}
MPID_Dev_comm_create_hook( MPI_Comm newcomm )
\end{verbatim}
the code that this macro expands into will be executed after the
communicator is created, just before it is returned to the user.
Similarly,
\begin{verbatim}
MPID_Dev_comm_destroy_hook( MPI_Comm comm )
\end{verbatim}
is invoked at the very beginning of the process that frees a
communicator (this gives the device hook a ``stack''-like
semantic---last in first out.

