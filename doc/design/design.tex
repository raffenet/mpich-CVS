\documentclass{report}
\usepackage{graphics}
\usepackage[dvipdfm]{hyperref}
%
% This is the new (September 2005) MPICH2 design document.  The plan is
% to make this available both as a PDF document and split on the web in
% an easy to read fashion.  We can use latex2html to tohtml to provide a 
% simple version of this, and that may be enough.  However, to retain the
% option of generating web pages directly from this source, only simple 
% Latex should be used, and only the new forms (e.g., \texttt{...} instead of 
% {\tt ...}
%


\makeindex

\begin{document}

\markright{MPICH Design Document}

\title{MPICH2 Design Document}
\author{William D. Gropp and Rajeev Thakur}
\maketitle

\pagenumbering{roman}
\tableofcontents
\clearpage


%\raggedright
%% raggedright resets parindent
%\parindent 1em
%% no parskip when parindent used
%\parskip 0pt

\pagenumbering{arabic}
\pagestyle{headings}

\part{MPICH2 organization for users}

\chapter{Overview}
     <<up here, explain that MPICH2 is a framework for MPI implementation with many possible choices, including specialized communication devices and interfaces to process managers, not ch3+mpd.  Duplicate this discussion in the top-level entry for developers>>

\chapter{Communication Devices}

\chapter{Process Managers}

    other options 
    <<this chapter partially overlaps the installation manual, but that manual doesn't cover much of the motivation for the design>>

\chapter{Help Resources}

\section{Frequently Asked Questions (FAQ)}

\section{Diagnostic Programs}

\section{Buglist archives}


\part{MPICH2 organization for developers and hackers}


    <<each section (as appropriate) contains a rationale for the choices and a brief discussion of alternatives and why they were not chosen>>

\chapter{Goals of MPICH2}


\section{Principles}
         No duplicated code (no cut and paste programming) 
         Uniform appearance of code
         Uniform user interface for controls (e.g., standardized parameter handling, output, naming)
         Coverage and Testing

\section{Major components}
         devices
              the ch3 device and channels
         process managers and PM interface
         logging
         collectives
         topology

\section{Build System}
         rationale
              why not automake
              why not libtool
         using the build system
         using your own configure/make/build scripts

\section{Coding Style}
         Code template for uniform error checking and reporting (e.g., common \texttt{fn\_fail} target)
         Macros for common operations
              error reporting
              memory allocation
              debugging
         Safer or more efficient replacements for common routines
              safe string routines
              memcpy hooks
         Error reporting
              Rationale
               Adding new error classes and codes
         Tags for coverage analysis

\section{Major Structures}
      request, comm, group, etc.

\section{Selecting Features at Compile Time}
     use of macros to control which code is used
     list of all macros

\section{Language Bindings}
           rationale for buildiface
           Outstanding issues

\section{Scripts and Standards for user interfaces}
           command line and environment variables

\chapter{Adding your own implementation of a component}
         General mechanism (--with-<<component-name>>=directory, e.g., --with-pm=/home/me/mypm)
              configure and setup scripts
              standardized variables (\texttt{MPI\_CFLAGS}, CFLAGS, etc.)
         Specific components (describe, explain the API/ABI, and how to work with it):

Two types 

configure/compile-time

link/runtime

\section{Specifying Components during Configure}

\section{Specifying Components at Runtime}

It is possible to override the default routines for any component at
runtime by calling one of the following routines.

\begin{verbatim}
    MPIX_SetMethod( component, object, name, function, communicator,
    version )
\end{verbatim}

where
    component - identifier for the component (e.g., topology,
    collectives)
    object    - object to change; null if changing the defaults for
    all objects
    name      - name of the method (probably character string for function)
    function  - function to use
    communicator - communicator scope of this change (MPI\_COMM\_SELF
    and MPI\_COMM\_WORLD are popular choices)
    version   - version of the interface (see below)

    This call is collective over the communicator.  The intent of the 
    communicator option is to allow consistency checking for changes
    that must be consistent across processes (e.g., changing the
    collective algorithms).

    The version number is used to ensure that the version of the
    interface matches the one used in the library

A related call is

\begin{verbatim}
    MPIX_SetAllMethods( component, object, struct-of-functions*,
    communicator, version )
\end{verbatim}

This is similar to SetMethod, except all functions are set from those
defined in the struct-of-functions.  The version is very important
here as it ensures that the struct is known.

One additional call is

\begin{verbatim}
    MPIX_DLLLoadMethods( component, object, dll-name, communicator,
    version )
\end{verbatim}

This loads the methods from a dynamic loaded shared object.  It is
collective over the communicator

Implementation note: the ``component'' in these calls can be the name
of a routine that 

\section{Collectives}
\section{Topology}
\section{Logging}
    --with-logging=/pathname
    looks for setup\_logging script.  Makefile will be invoked with (null),
    clean, dist-clean, maintainer-clean, library target?

    Must provide an mpilogging.h file (contents defined as...)

    Example (give example directory on web)

    Builtin versions...

\section{PM and PMI}

mpiexec 
    -pmiargs host port executable
special args used to allow singleton init.

\section{Name Server}

    --with-nameserver=...

\section{mpid}
\section{ch3-channel}

          Components still evolving (a placeholder for things that we want to do)

\chapter{Working with MPICH2 itself}
          <<for people that edit MPICH2 rather than use the component interface>>
          Coding standards
          Keeping configure clean
          Keeping MPICH modular
          

\end{document}
