The basic remote queue device assumes the following:

There is a simple mechanism for transfering short (control) messages.  These
are typically packet headers, but may also include short messages.  There is
no assumption that you must be able to send a short message; a device must be
prepared to enqueue an out-going message.

Long messages are *always* transfered with remote memory operations.  That is,
either a put or a get operation.  The tcp device shows how this is simulated
for environments that do not have remote memory operations.  Note that the
"address" for the put or get operation is an opaque bit-field; where true
remote memory operations are available, it could be an address; in other
cases, it could be an offset or a index into a table entry or something else.

Collective operations can be accellerated through the use of a few operations
that can be specified at the destination of each message.  Think of these as
extensions to the usual active message data copy routine.  These operations
are optional; a device need not support them (the operations are join, cat,
and copy).

Different devices cannot be mixed together in an single MPICH implementation.
However, different methods may be.  A method may specify how to move data
using a single transport (e.g., TCP, shared memory, Myrinet).  A multi-method
implementation shares basic data structures (e.g., MPID_Request).  Note that
MPID_Requests are shared by all methods in a device, and are "vertically
integrated" (used from the very lowest levels of the device to the very top).
By mandating a common form for requests (and for the common part of a packet),
it is possible to write the dispatch loop for incoming data even if there is a
single queue (see below).

The interface between the MPI routines (e.g., MPI_Send) and the ADI is defined
in terms of requests:  the MPI routine allocates a request, fills in the
required fields, and calls the appropriate ADI routine.

The receive queues (unexpected and pending) are (roughly) visible at the MPID
level.  Any other queues or lists are part of particular device
implementations.  The reason that the receive queues are visible is that, for
thread safety, the atomic operation when looking starting a receive is ``is a
matching receive in the unexpected queue; if so, return that match and if not,
add to the posted receive queue''.

Example ADI implementations
============================

1. A multi-method device (TCP and Shared Memory)

Overview:  Messages are sent by sending packets; these packets either carry
data (short messages) or setup a rendezvous (long messages).  Additional
packet types support message cancel and flow control.  Long data is sent using
a separate mechanism; this *looks* like remote memory operations, but may
simply be another packet operation.

There are three basic queues: Posted receives, Unexpected sends, and pending
sends.  The last queue is used to handle messages that have not yet been sent
because of a flow control or other temporary restriction on delivery of
messages.  The pending send queue is visible only the the RMQ device.

Rules for names:
MPID prefix is used for routines seen by the MPI implementation and that are
part of the ADI-3 specification.
RMQ prefix is used for the RMQ implementation of ADI-3.

typedef enum { RMQ_TCP, RMQ_SHMEM } RMQ_Method;
typedef <whatever is 32 bits> int32;

typedef struct _MPID_Request *MPID_Request_p;

/* This is the packed version using bit fields; limited to 1024 processes.
   For maxiumum efficiency, it should be L1 cache-aligned and, if possible,
   the minimum packet should be 1 cache-line long */
typedef struct _RMQ_Packet {
    unsigned int packet_type:8;
    unsigned int packet_len:14;
    unsigned int lrank:10;
    unsigned int from:10;
    unsigned int to:10;  ??? do we need this, or is it in the request?
    unsigned int ctxid:12;
    int32        tag;
    ? flow control ?
    ???
    ? data area ?
    } RMQ_Packet;

/* Requests are also carefully aligned.
typedef struct _MPID_Request {
   MPID_Request_p next;     /* Easy enqueue of requests */
   RMQ_Method    method;
   int            to;       ? if not in packet
   ??? other data not in packet???
   char           pad[PAD_SIZE]; /* padding to position packet */
   RMQ_Packet    packet;   
   ???
   /* Method-specific data begins here */
   } MPID_Request

Device Implementation
=====================

MPID_Isend( MPID_Request *request )
{
    /* Determine method from destination; setup any method-specific
       info (use request->to or request->packet.to) */
    RMQ_Set_method( request );
    // This could return the method as its value or RMQ_NO_METHOD for error 
    
    /* Invoke appropriate method */
    switch (request->method) {
        case RMQ_TCP:   RMQ_TCP_Isend( request ); break;
	case RMQ_SHMEM: RMQ_SHMEM_Isend( request ); break;
	/* Add other methods here */
	/* Always catch the something-is-wrong case */
	default: Panic();
    }
}

MPID_Irecv( MPID_Request *request )
{
    // Match against unexpected receive queue or insert into
    // pending receives
    if (MPID_Match_recv( request )) {
	// found a matching receive.  Process it
	MPID_Push_request( request );
	// request may be complete (short message) or may not (long message,
        // push-request sent ack).
    }
}

MPID_Wait( MPID_Request *request, MPI_Status *status )
{
    while (!request->complete) {
	// In the multi-threaded case, the request may be completed by
        // another thread (?).  Should there be a MPID_Req_active(request)
	// to indicate that some thread is actively waiting on request?
	MPID_Poll( 1 );
    }
}

/* This routine handles the queue operations.  Note that not all operations
   will reach this routine (e.g., the TCP device may choose to handle
   RMQ_PKT_OK_TO_SEND messages directly) 

   MPID_Poll is called by
       Random MPI routines (which ones?)
       A timer (thread lock?)
       A thread (thread lock?)
*/
MPID_Poll( int blocking )
{
    make sure we are atomic: if running return else lock;

    /* Get next packet from anywhere */
    packet = RMQ_Next_packet( blocking );

    if (!packet) { unlock; return; }
    /* Also need to attempt to write any pending messages in the write 
       queue */
    /* This can use a single queue or a blended access to different 
       method queues based on access time */
    switch (packet->packet_type) {
        case RMQ_PKT_SHORT:
	     Try to match message against posted receives, else 
	     add to unexpected message queue
	     break;
	case RMQ_PKT_REQUEST_SEND:
	     Try to match message against posted receives.  If
	     found, generate ok-to-send response.  Else add to 
             unexpected message queue
	     break;
	case RMQ_PKT_OK_TO_SEND:
	     Execute RMQ_Put_data
	     break;
	case RMQ_PKT_ANTI_SEND:
	     Try to remove message from unexpected message queue; 
	     generate ack.
	     break;
	case RMQ_PKT_ANTI_SEND_OK:
	     Update request with success/failure of cancel
	     break;
	case RMQ_PKT_FLOW:
	     Update flow-control information for link
	     break;
        default: Panic();
    }
    unlock;
}

// This only handles communication initialization.  
// For mmap/forked shmem, we need to pass pre-existing communication context
// to the initialization (or have pre and post-process creation
// initialization?) 
MPID_Init()  // no cmdline args required 
{
    RMQ_TCP_Init();
    RMQ_SHMEM_Init();
}

or

MPID_Init()  // no cmdline args required 
{
 
    RMQ_TCP_CommPreInit();
    RMQ_SHMEM_CommPreInit();
    RMQ_TCP_ProcessCreate();
    RMQ_SHMEM_ProcessCreate();
    RMQ_TCP_CommPostInit();
    RMQ_SHMEM_CommPostInit();
}

RMQ device (general routines)
==============================

/* This routine could be simply "add to queue" */
RMQ_Dispatch_packet( packet )
{
   if (multi-threaded)
      Add packet to queue of pending packets
   else
      call routine to process packet (switch in MPID_Poll?)
}


TCP method
==========

typedef struct _RMQ_TCP_Request {
    MPID_Request common;   /* Could also macro include this if the 
                              compiler generates poor code */
    ???
    } RMQ_TCP_Request

// This doesn't address process startup
// Only the communication is initialized by this
RMQ_TCP_Init()
{
    Create connection listener
    Get connection server ip/port name from environment
    Send connection server my listener ip:host
    Contact connection server to get others ip:host
}

RMQ_TCP_Isend( MPID_Request_p request )
{
    if (message is short) {
	pack message into packet (memcpy or MPID_pack_datatype)
    }
    else {
	set packet kind to request-to-send
    }
    //send packet (enqueue request at remote location)
    RMQ_TCP_Enqueue_envelope( request );
}

RMQ_TCP_Poll( int blocking )
{
    select( open-fds, timeout = (blocking ? NULL : 0) );
    for each set fd {
        if read {
            read packet.  Process or add the packet queue:
            RMQ_Dispatch_packet( packet );
        }
        else {
            advance pending writes
        }
    }
}

RMQ_TCP_Enqueue_envelope( MPID_Request_p request_p )
{
    Do flow-control for packet
    if writes allowed then {
        write( request_p->tcp.fd, request_p->common.packet, 
	       request_p->common.packet_len );
    }
    if (not all written) {
        add to pending write queue
    }
}

/* ?? How to double buffer this ?? */
/* Vaddress is the "virtual" address that was returned by the receiver in the 
   packet.  When the data is returned, with this address, to the receiver, it
   will know where to put the data (Vaddress could be index of matching
   request, which solves heterogeneity issues)
 */
RMQ_TCP_Put_data( MPID_Packet *packet_p )
{
   Find request from packet
   if (message is contiguous) {
       compute address of source data from request
   }
   else {
       use MPID_pack_datatype into a buffer attached to the request
       (space allocated at Isend?  At Put_data time?)
       save state of pack in request if we aren't done
   }
   writev( with return Vaddress, next lump of data ) 
   if (not all written)
       add to pending write queue
}

Shared memory method
====================

(not done)

RMQ_SHMEM_Init()
{
    ?? (if sysv segments, this would look much like TCP_Init)
}

Notes on the implementation
===========================
Rather than use an enum type and a switch statement, the MPID_Request could
replace method with a (virtual) function table.  The advantage is that any
number of methods can be supported; the disadvantage is that the requests them
selves become more complex and vulnerable (any damage to the request can
mangle the function pointers), even if method is a pointer to a static
function table.  

We need a way (similar to the ch2 device in ADI-2) to build the "common" parts
of the method implementations.  Perhaps the name-mangling approach in the next
section could be used?

If "short" doesn't depend on the method, or is easily extracted, we may be
able to eliminate one layer of calls.

Short cuts in the method implementations could process some packets
(particularly "continue sending data") without ever reaching the device-level
poll routine.

Single Method Implementation
============================
In the single method case, we can dispense with the switch on method type and
the code to determine the correct method.  To enable method code to become
device code, we might consider declarations that use
#define RMQ_NAME(b) RMQ_BASE_NAME##b
...
RMQ_NAME(_Isend)( MPID_Request_p request )
...

Then -DRMQ_BASE_NAME=RMQ_TCP creates the TCP method for use in a
multi-method device, and -DRMQ_BASE_NAME=RMQ creates the TCP method for a
single (TCP) method device.  ## is the ISO C string concatentation operator;
pre ISO C can use /**/ instead (and configure can test with
PAC_C_CPP_CONCAT). 

Adding VIA
==========

(not done)

Unlimited Methods
=================
All of the functions can be virtuallized, allowing the method to be
dynamically loaded, at some additional cost in function dispatch.

Questions
=========
Error returns.  Do all functions return an error value?  Do they use the MPI
error classes?  Error codes (encoded according to MPICH error handling)?

How should requests be allocated?  The allocation must be fast (don't use
malloc).

Who defines MPI_Status structure?  Is this something defined by the particular
device implementation (and hence must be included within the mpi.h file)?
