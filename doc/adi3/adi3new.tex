% 
%   This is a latex file that generates a reference manual for 
%   ADI-3 
%
\documentclass{article}
\usepackage{refman}
\usepackage{tpage}
\usepackage{url} 
\usepackage{graphics}
%\usepackage{epsf}
%hyperref - do not remove this comment

\textheight=9in
\textwidth=6.1in
\oddsidemargin=.2in
\topmargin=-.50in
\newread\testfile

\newcommand{\mpich}{\texttt{mpich}}
\newcommand{\Mpich}{\texttt{Mpich}}

%
% For now, let findex be the same as index.  This will allow us to
% more easily separate function and nonfunction index entries later.
\let\findex=\index
%
% Modify the way titles are handled for no breaks between pages
\def\mantitle#1#2#3{\pagerule\nobreak
\ifmancontents\addcontentsline{toc}{subsection}{#1}\fi
\index{#1}}

\makeindex

\begin{document}

\markright{ADI-3 Reference Manual}

\def\nopound{\catcode`\#=13}
{\nopound\gdef#{{\tt \char`\#}}}
\catcode`\_=13
\def_{{\tt \char`\_}}
\catcode`\_=11
\def\code#1{{\tt #1}}
%\let\url=\code
\def\makeussubscript{\catcode`\_=8}
\def\makeustext{\catcode`\_=11}
%\tpageoneskip
\ANLTMTitle{MPICH Abstract Device Interface\\
Version 3.4\\
Reference Manual\\\ \\Draft of \today}{\em 
William Gropp\\
Ewing Lusk\\
David Ashton\\
Rob Ross\\
Rajeev Thakur\\
Brian Toonen\\
Mathematics and Computer Science Division\\
Argonne National Laboratory}{00}{\today}

\clearpage

\pagenumbering{roman}
\tableofcontents
\clearpage

\pagenumbering{arabic}
\pagestyle{headings}

%
% The first section is the design
\input design.tex

\section{Integrating a New Device into the MPICH Build Tree}
This section describes how to add a device or method into the MPICH
build tree.  This section is intended both to describe the process of
adding a device and the rationale for the design of the
device-dependent modules.

\input adiimplrules.tex

\appendix

\section{Data Structures}
\label{sec:datastructures}

This section contains descriptions of the data structures using in the
ADI3 definition.  These include both the major enumerated types and
the structure definitions.

\subsection{Basic enumerations and types}
\input adi3man/MPID_Object_kind.tex
\input adi3man/MPID_Lang_t.tex
\input adi3man/MPID_Request_kind.tex
\input adi3man/MPID_Comm_kind_t.tex
\input adi3man/MPID_Errhandler_fn.tex
\input adi3man/MPID_Op_kind.tex
\input adi3man/MPID_User_function.tex
\input adi3man/MPID_Copy_function.tex
\input adi3man/MPID_Delete_function.tex

\subsection{Major MPI Objects}
\input adi3man/MPID_Request.tex
\input adi3man/MPID_Comm.tex
\input adi3man/MPID_Group.tex
\input adi3man/MPID_Win.tex
\input adi3man/MPID_Op.tex
%\input adi3man/MPID_Segment.tex
%\input adi3man/MPID_Dataloop.tex
%\input adi3man/MPID_Dataloop_contig.tex
%\input adi3man/MPID_Dataloop_vector.tex
%\input adi3man/MPID_Dataloop_blockindexed.tex
%\input adi3man/MPID_Dataloop_indexed.tex
%\input adi3man/MPID_Dataloop_struct.tex
\input adi3man/MPID_Datatype.tex
\input adi3man/MPID_Info.tex
\input adi3man/MPID_Errhandler.tex
\input adi3man/MPID_Keyval.tex
\input adi3man/MPID_Attribute.tex

\subsection{Threads}
Thread support in MPI requires both a thread-safe device and
thread-safe handling of MPI objects that may be shared among threads.
These routines provide for atomic updates to reference counts on MPI
objects.  Other routines provide thread locks on a communicator basis,
as well as a process-wide thread lock that may be used when such a
coarse-grain lock is sufficient.

\input adi3man/MPID_MAX_THREAD_LEVEL.tex
\input adi3man/MPIU_Object_add_ref.tex
\input adi3man/MPIU_Object_release_ref.tex
\input adi3man/MPID_Comm_thread_lock.tex
\input adi3man/MPID_Comm_thread_unlock.tex

\section{Basic Point-to-Point}
\label{sec:pt-2-pt}
This section provides definitions for the point-to-point communication
functions.  These roughly parallel their MPI counterparts, with the 
exception that all (even \code{MPID_Send} and \code{MPID_Recv} are
non-blocking, and the optional \code{MPID_tBsend} routine that may be
used to improve the performance of buffered sends.

\input adi3man/MPID_Send.tex
\input adi3man/MPID_Ssend.tex
\input adi3man/MPID_Rsend.tex
\input adi3man/MPID_Isend.tex
\input adi3man/MPID_Issend.tex
\input adi3man/MPID_Irsend.tex
\input adi3man/MPID_tBsend.tex
\input adi3man/MPID_Recv.tex
\input adi3man/MPID_Irecv.tex
\input adi3man/MPID_Request_release.tex
\input adi3man/MPID_Cancel_send.tex
\input adi3man/MPID_Cancel_recv.tex
\input adi3man/MPID_Iprobe.tex
\input adi3man/MPID_Probe.tex

\section{Persistent Point-to-Point}
\label{sec:persistent}
This section provides the definitions for the persistent communication
routines.  Note that there is no \code{MPID_Start} routine; we
currently believe that \code{MPID_Startall} is all that is required,
as it is easy to implement \code{MPI_Start} with \code{MPID_Startall},
and \code{MPID_Startall} is required to allow the device the option of
scheduling communication for all of the requests passed to it.

\input adi3man/MPID_Send_init.tex
\input adi3man/MPID_Ssend_init.tex
\input adi3man/MPID_Rsend_init.tex
\input adi3man/MPID_Recv_init.tex
\input adi3man/MPID_Startall.tex

\section{Generalized Requests}
\label{sec:grequests}
This section provides the interface to the generalized (user-defined)
requests.  
\input adi3man/MPID_Request_create.tex
%\input adi3man/MPID_Request_set_completed.tex

\section{Data Segment}
\label{sec:segment-fcns}
\input adi3man/SGOverview.tex
%% \input adi3man/MPID_Segment_init_pack
%% \input adi3man/MPID_Segment_pack
%% \input adi3man/MPID_Segment_init_unpack
%% \input adi3man/MPID_Segment_unpack
%% \input adi3man/MPID_Segment_free

\section{Process Topology}
This section describes a routine that allows the device to communicate
information on the process topology to the MPI process topology
routines.  This routine is designed for hierarchically-organized
machines.  Additional routines for other topologies (e.g., a scalable
mesh topology) will be considered as needed.

\input adi3man/MPID_Topo_cluster_info.tex

\section{Progress Engine}
\label{sec:progress}
The progress engine provides a way for the MPI implementation and the
ADI implementation to coordinate progress on communication.  The
design makes no assumptions about whether the ADI uses polling or a
separate communication thread or interrupts or any other mechanism to
make progress.  

Here are several implementation sketches.
First, a polling implementation for a single-threaded implementation:
\begin{verbatim}
MPID_Progress_start - no-op
MPID_Progress_end - no-op
MPID_Progress_test - select with no wait
MPID_Progress_wait - select with infinite wait
MPID_Progress_poke - select with no wait
\end{verbatim}

A non-polling, single-threaded implementation that used a separate
thread for communication could use (this isn't correct yet)
\begin{verbatim}
MPID_Progress_start - Set flag indicating checks in progress
MPID_Progress_end - Clear flag
MPID_Progress_test - yield to communication thread
MPID_Progress_wait - if no completions since flag set, 
                     wait on condition variable.  Otherwise, return.
MPID_Progress_poke - either no-op or yield to communication thread
\end{verbatim}

See the generalized request functions in Section~\ref{sec:grequests}
for some additional requirements on the progress engine.

\input adi3man/MPID_Progress_start.tex
\input adi3man/MPID_Progress_end.tex
\input adi3man/MPID_Progress_test.tex
\input adi3man/MPID_Progress_wait.tex
\input adi3man/MPID_Progress_poke.tex

\section{Starting and stopping}
\input adi3man/MPID_Init.tex
\input adi3man/MPID_Finalize.tex
\input adi3man/MPID_Abort.tex

\section{Information about the device}
\input adi3man/MPID_Get_processor_name.tex

\section{RMA}
(not yet defined)
%\input adi3man/MPID_Win_put.tex
%\input adi3man/MPID_Win_get.tex
%\input adi3man/MPID_Win_accumulate.tex
%\input adi3man/MPID_Win_do.tex
%\input adi3man/MPID_Win_fence.tex
%\input adi3man/MPID_Win_begin.tex
%\input adi3man/MPID_Win_end.tex
%\input adi3man/MPID_Win_local_lock.tex
%\input adi3man/MPID_Win_local_unlock.tex

\subsection{Memory Allocation for RMA}
\input adi3man/MPID_Mem_alloc.tex
\input adi3man/MPID_Mem_free.tex
\input adi3man/MPID_Mem_was_alloced.tex

\section{Dynamic Processes}
(not yet designed)

\section{Collective Communication}
(not yet designed)

\section{Connections and Local Process Ids}
\label{sec:connections}
These routines are used to manage connections.  MPI Communicators contain
references to these tables; group operations use the local process id
(see \code{MPID_VCR_Get_lpid}) to identify processes.

\input adi3man/MPID_VCRT_Create.tex
\input adi3man/MPID_VCRT_Add_ref.tex
\input adi3man/MPID_VCRT_Release.tex
\input adi3man/MPID_VCRT_Get_ptr.tex
\input adi3man/MPID_VCR_Dup.tex
\input adi3man/MPID_VCR_Get_lpid.tex

%\section{Device Hooks}
%\input adi3man/MPID_Dev_xxx_create_hook.tex
%\input adi3man/MPID_Dev_xxx_destroy_hook.tex

% More on data structures and constants, including MPIU_Handle_obj_create
% etc.?  Or does this go into the MPICH2 document?
%
%\section{Available Utility Functions}
%\input adi3man/MPIU_Object_add_ref.tex
%\input adi3man/MPIU_Object_release_ref.tex

\section{Timers}
Timer support is defined so that the device may either provide or use
the timers.  We expect most devices to use one of the timers defined
in \file{src/mpi/timer}
\input adi3man/MPID_Wtime.tex
\input adi3man/MPID_Wtick.tex
\input adi3man/MPID_Wtime_diff.tex
\input adi3man/MPID_Wtime_init.tex
\input adi3man/MPID_Wtime_todouble.tex
\input adi3man/MPID_Wtime_acc.tex

\let\SaveBibliography=\thebibliography
\def\thebibliography#1{\SaveBibliography{#1}\addcontentsline{toc}{section}{References}}
\let\gb\relax
\bibliography{/home/MPI/allbib,/home/gropp/public_html/bib/gropp,/home/gropp/papers/MPI/mpich2-coding/mpich2,adi3.bib}
\bibliographystyle{plain}

% Index
%\openin\testfile{adi3new.ind}
%\ifeof\testfile\else
\let\SaveIndex=\theindex
\long\def\theindex#1{\SaveIndex{#1}\addcontentsline{toc}{section}{Index}}
\input adi3new.ind
%\fi
%\closein\testfile

\end{document}
