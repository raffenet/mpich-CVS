The purpose of this section is to describe how communcators are constructed
during the initialization of an new process group or the establishment of a
inter-communicator through the dynamic process interface.  This discussion
includes the initialization of objects referred to by the communicator, such
as the virtual connection objects used by the multi-method device.

%------------------------------------------------------------------------------

\subsection{Overview}

MPI_Init
- gather process information (size, rank, keyval space) from BNR
- create process group object, storing info obtained from BNR
- call MPID_Init, obtaining MPIR_CRT for MPI_COMM_WORLD on return
- determine extra space required by device for MPIR_Comm objects
- initialize MPIR_Comm allocator
- construct MPIR_Comm for MPI_COMM_WORLD
- construct MPIR_Comm for MPI_COMM_SELF

\Q How do we handle vMPI needing extra storage in each communicator?

\Q How do we handle vMPI needing to be informed about communicator creation?

\begin{discussion}
  We considered placing all interactions with BNR at the device layer.  This
  would have allowed devices tightly coupled to a particular piece of
  hardware or parallel operating environment to avoid the use of BNR and thus
  the development of an additional module.  We later discovered that the
  spawn functionaly at the MPICH layer was dependent on BNR in order for the
  spawnees to gather information about the spawner.  Therefore, we moved the
  gathering of common information from BNR back into the MPICH layer and made
  BNR a requirement for all configurations of MPICH.
\end{discussion}

MPID_Init (MM impl)
- obtain list of methods (dynamically loading new ones if runtime
  configuration calls for such a thing)
- initialize methods
- get capability and contact descriptions from each of the methods
- publish descriptions in BNR
  - Note: in general, we publish information at the MPID layer since not all
    devices may need to publish information
- return a pointer to the MPIR_CRT defining the connections for
  MPI_COMM_WORLD

MPID_Comm_get_object_size()
- returns the additional number of bytes needed by the MPID_Comm object over
  the MPIR_Comm object

%------------------------------------------------------------------------------

\subsection{Data Structures/Objects?/Interfaces}

\paragraph{Connection Reference Table}

The connection reference table, \code{MPIR_CRT}, representing a ordered
collection of point-to-point connections.  This table will be used to track
the connections to other processes participating in an MPI communicator.
Although this may be a complex distributed data structure for machines like
the Blue Gene, we define it in terms of a process local array for the general
implementation.  The \code{MPIR_CRT} object contains:
\begin{itemize}
\item reference count
\item size (number of connection references)
\item array of connection references (\code{MPID_ConnRef}
\end{itemize}
The elements of \code{MPIR_CRT} are all considered public, and therefore may be
accessed directly by an code holding a reference to one of these objects.

\paragraph{virtual connection table}

we know that we're going to allocate VCs in groups (that might correspond to
process groups), so it makes a certain amount of sense to organize these into
tables of VCs which are allocated at one time, for example at startup for comm
world.

by allocating in terms of process groups, we make it easier to identify reuse
of VCs in new communicators/connection reference tables created through
additional connect/attaches.

these tables don't have to be arrays because we're not going to be digging
around in them all the time -- they don't have to be super-efficient to access.

in fact these ``tables'' aren't even needed until we implement connect-attach.
the ``tables'' are probably not arrays, and in any case they just refer to VCs
rather than containing them.

\begin{verbatim}
MPI_Comm -> MPIR_Comm

MPIR_Comm
    ref_cnt
    ptr to local CRT (MPIR_CRT)
    ptr to remote CRT (MPIR_CRT)
    contexts (*** separate communicators vs. contexts? ***)
      intra-communicator
        pt2pt
        collective
        rma
        file
      inter-communicator
        pt2pt
        collective
        local group A in collective
        local group B in collective

MPIDI_Comm : MPIR_Comm
    (device specific info)

MPIDMI_Comm : MPIDI_Comm
    (does this make any sense?  a communicator can utilize multiple devices
     since a device is associated with each connection. on the other hand, the
     vendor MPI device needs to be able to track communicators, and therefore
     it is desirable for it to be able to store method-specific information in
     the communicator)
\end{verbatim}


Contexts allocated in blocks of power of 2 (probably 4) so that we can perform
one context allocation operation (which is collective) and have all the
contexts we need for a single communicator.

\begin{verbatim}
MPIR_CRT (connection reference table)
    ref_cnt
    size (number of connections)
    array of MPID_Conn_ref (actual objects not pointers to objects)
\end{verbatim}

Initially we defined \code{MPIR_CRT} as an opaque object since we wanted to be
able to implement the table usig some scalable data structure (i.e., something
other than an array) on systems like Blue Gene.  Having this object be opaque
implies that accessor functions would be required to access elements in the
table.  It also implies that set functions would be needed to manipulate the
table itself.  Before we define all of these functions, we want to be sure that
it is possible to create a scalable, distributed data structure whose
scalability doesn't fall apart once set manipulations are performed.
Additionally, all data structures referred to by the CRT, such as VCs, must
also remain scalable in the face of set manipulation.

We have since decide that \code{MPIR_CRT} is not opaque.  The connection table
will be implemented as an array, although that implementation may change for
systems like Blue Gene.  This will be accomplished through the use of the C
preprocessor.

\begin{verbatim}
MPID_Conn_ref
    (device specific - MMCA = ptr to MPIDI_VC)
\end{verbatim}

Accessors functions are required to obtain information out of the VC.  

\Q Should \code{MPID_Conn_ref} be an ADI3 function?  If not, VC accessor
functions need to operate on a \code{MPIR_CRT} instead of a
\code{MPID_Conn_ref}.

\begin{verbatim}
MPIDI_VC
    ref_cnt
    local process id
    ptr to process group
    rank in PG

MPIDMI_VC : MPIDI_VC
    (method specific data)
\end{verbatim}

\begin{verbatim}
MPIR_Process_group
    ref_cnt
    BNR keyval space name
    size of PG
    my rank in PG
\end{verbatim}


%------------------------------------------------------------------------------

\subsection{Walkthrough}

\paragraph{comm world}

goal is for our mm device to create the crt for comm world and pass it back for
inclusion in the comm world communicator.

we're in the mm implementation of mpid_init.

we've got a keyval space name.  bnr tells us a size and rank too.

each process publishes her (ha!) information through bnr about our methods,
contact info, etc. and commit it.

then we do a bnr barrier so we know everyone has committed.

at that point we can grab connectivity information out of the bnr keyval space.

for this comm world process group it's probably worth recording somewhere that
that process group is associated with keyval space X, is of size Y, and we are
rank Z in it.

-- the above stuff probably all happens in mpid_init() --

the rest of this either goes in mpid_init or goes into some
mpid_create_comm_world function.  we don't really care :).

we might want to track vcs associated with this process group too...but we
don't need that yet.

we allocate vcs for all the potential destinations.  we fill them in with a
reference to this process group information and a destination rank in that
process group (which will be the rank in the comm world communicator).
obviously the VCs are unbound at this point :).

we then allocate a CRT and fill in the connection references pointing to the
right VCs.

CRT gets passed back up so that it can be associated with the communicator.

as an aside, we could have left the ConnRefs ``unbound'' and used a lookup of
some sort, but that seems silly for this implementation.  it would make more
sense in a highly scalable (Blue Gene) implementation.

We should talk to bill about CRTs and whether we can really do anything other
than make them arrays.  If not, there is no point in making them opaque,
although having functions to do this stuff (or macros) gives a system that uses
vendor mpi more information on what is going on...but is it sufficient?


\paragraph{spawn from the spawner's pov}

spawning requires the creation of the following communicators at the spawned
processes:
\begin{itemize}
\item an intra-communicator for COMM_WORLD, and
\item an inter-communicator between the spawner and spawnee processes.
\end{itemize}
Only the inter-communicator is created at the spawner processes.

The COMM_WORLD intra-communicator is created as described above.  The
inter-communicator is created using MPI_Comm_connect() and MPI_Comm_accept(),
which is described below.  (See BNR section for a discussion of this process.)

\paragraph{connect and accept}

goal is for our mm device to create the crt for comm world and pass it back for
inclusion in the comm world communicator.

need a function that discovers the process groups relevant to a CRT

need to expose process groups through ADI3 - must be able to create new groups
and change information (at least the keyval space name associated with the
process group)

each side does the following:
\begin{itemize}
\item first thing we do is extract a list of process groups from the crt; we do
  this by looking at the process group associated with each connection (VC)
\item for each process group in crt, send across the process group and a dump
  of the corresponding keyval space (if we aren't in the same bnr domain)
\item next we need to serialize the crt and pass it across.  this includes
  information from the vcs regarding their rank in one of the process groups
\item the function that ``deserializes'' the table needs to perform process
  group translation on the VCs in the new crt (from remote to local PGs)
\end{itemize}

at that point there are complete CRTs on each end which may be passed up and
used as the remote CRTs for the new intercommunicator.

