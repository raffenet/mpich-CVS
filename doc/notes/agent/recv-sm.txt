Receive side state machine

This state machine is targeted towards packet based systems such as VIA.  That
is to say that it assumes that only complete packets are handed to the state
machine.  Some alterations (likely in the form of additional states) are
required in order to support a the processing of partial packets received by
stream based model like TCP.

Tasks for this state machine:

- recv control and data packets

- potentially provide buffers to associated send CAR

- track buffers provided by associated send CAR

- notify associated send CAR of any progress made

- provide buffer availability information for flow control


This version of the state machine only handles receiving data into a user
provided buffer.  It needs to be expanded to include the forwarding cases.

State [Await Header Pkt]
    Event [Pkt Short](context_id, src, tag, msg_size, msg_data)
        get comm from context_id
        MPICA_recv_incoming_foa(comm, src, tag, &car, &found)

        if (found)
	    unpack data from packet buffer into user buffer
	    decrement completion counter
	    free car
	else
            allocate a temporary buffer
	    copy data from packet into temporary (packed) buffer    
	State_Change([Await Message], [short])

    Event [Pkt Eager](tag, src, context_id, msg_size, msg_data)
        get comm from context_id
        MPID_CA_recv_incoming_foa(comm, src, tag, &car, &found)

        if (found)
	    unpack data from packet buffer into user buffer
        else
            allocate temporary buffers large enough to hold msg data
	    copy data from packet into temporary (packed) buffer    
	record car as active car in VC
	State_Change([Await Data Pkts], [short])

    Event [Pkt Rndv-RTS](context_id, src, tag, remote_liba, msg_size)
        get comm from context_id
        MPID_CA_recv_incoming_foa(comm, src, tag, &car, &found)

	if (found)
            enqueue Rndv-CTS message on VC send queue
	      (message contains local and remote LIBAs)
	else
            store remote LIBA in car

    Event [Pkt Rndv-CTS](local_liba)
	use LIBA to locate send car
	enqueue Rndv-Data on VC send queue
          (reuse previously located send car)

    Event [Pkt Rndv-Data](local_liba, msg_data)
	use LIBA to locate recv car
	unpack data from packet buffer into user buffer
	record car as active car in VC
	State_Change([Await Data Pkts], [rndv-data])

State [Await Data Pkts]
    Event [Pkt Data]
	unpack data from packet buffer into user buffer
	if more data is expected
	    State_Change([Await Data Pkts], [!done])
        else
	    State_Change([Await Header Pkts], [msg recvd])


****************************
NEW STUFF IS DOWN HERE

State [Await Incoming Ctrl Pkt]
    Event [Pkt]
        Invoke_Action[Determine Ctrl Pkt Type]

Action [Determine Ctrl Pkt Type]
    Get_Next_Packet_And_Process_Ring_Buffer()
    switch (packet type)
        case flow
	    Invoke_Action[Process Flow Ctrl Pkt]
        case rndv-rts
	    Invoke_Action[Process Rndv-RTS Ctrl Pkt]
        case rndv-cts
	    Invoke_Action[Process Rndv-CTS Ctrl Pkt]
        case short
	    Invoke_Action[Process Short Ctrl Pkt]
        case eager
	    Invoke_Action[Process Eager Ctrl Pkt]
        case rndv-data
	    Invoke_Action[Process Rndv-Data Ctrl Pkt]

Action [Process Flow Ctrl Pkt]
    // TODO: We need to figure out what needs to happen when we receive an
    // explicit flow control packet.  For that matter, we need to figure out
    // how to deal with flow control in general...
    State_Change([Await Incoming Ctrl Pkt])

Action [Process Rndv-RTS Ctrl Pkt]
    State_Change([Await Incoming Ctrl Pkt])

Action [Process Rndv-CTS Ctrl Pkt]
    State_Change([Await Incoming Ctrl Pkt])

Action [Process Short Ctrl Pkt]
    State_Change([Await Incoming Ctrl Pkt])

Action [Process Eager Ctrl Pkt]
    Invoke_Action([Check For Posted Request])

Action [Check for Posted Request]
    recv_incoming_foa(..., &found)
    if (found)
        Change_State([Recv Posted])
    else
        Change_State([Recv Unexpected])

Action [Process Eager Data in Ctrl Pkt]
    decide whether to keep the data in the packets or make a temporary copy
    // this decision might be affected by the availability of buffers to 
    // serve as replacements if we were to keep the ones we receive data in.
    if copy
        allocate temporary buffer big enough to hold all message data
        copy data from first packet
        return packet ???  // NEED AN INTERFACE FUNCTION HERE
    else
        keep handle to packet with car
        maybe allocate replacement buffers
    record in car how we decided to handle data (copy or keep in packets)
    if there are data pkts available locally
        Invoke_Action([Process Unexpected Data Pkts])
    else
        Change_State([Await Unexpected Data Pkts])

State [Await Unexpected Data Pkts]
    Event [Pkt]
        Invoke_Action([Process Unexpected Data Pkts])

Action [Process Unexpected Data Pkts]
    while there are data pkts available locally
        Get_Next_Packet_And_Process_Ring_Buffer()
        if we are copying data
            make copy
            return packet // NEED OUR INTERFACE AGAIN
        else
            keep handle to packet with car
            maybe allocate replacement buffers
    if all data pkts have been received
        if there are more packets // the first will be a ctrl pkt
            Invoke_Action([Determine Ctrl Pkt Type])  // also grabs pkt
        else
            Change_State([Await Incoming Ctrl Pkt])
    else
        Change_State([Await Unexpected Data Pkts])

Action [Process Rndv-Data Ctrl Pkt]
    Change_State([Recv Posted])

State [Recv Posted Data],[shape=pentagon]
    Event [finished]
        Change_State([Await Incoming Ctrl Pkt])

Function Get_Next_Packet_And_Process_Ring_Buffer()
    get reference to packet so we can move it around
    if we need some more buffers in the ring
        attempt to acquire buffers
        if we got buffers
            add to receive buffer ring for VC
            post flow control update to be sent   
    return pointer to packet
