dnl Process this file with autoconf to produce a configure script.
dnl
dnl aclocal_cache.m4, included by sowing/confdb/aclocal.m4, fixes 
dnl bugs in autoconf caching.
dnl
dnl The file name here refers to a file in the source being configured
AC_INIT(wtime.c)
dnl
dnl Definitions will be placed in this file rather than in the DEFS variable
AC_CONFIG_HEADER(timerconf.h)
AC_CONFIG_AUX_DIR(../../../confdb)
dnl
echo "RUNNING CONFIGURE FOR TIMER"
dnl
dnl
dnl Use AC_ARG_ENABLE to look for --enable-feature and AC_ARG_WITH to look for
dnl --with-capability
dnl Enable better caching control
PAC_ARG_CACHING
AC_ARG_ENABLE(echo, 
[--enable-echo  - Turn on strong echoing. The default is enable=no.] ,set -x)
AC_ARG_ENABLE(strict,[--enable-strict - Turn on strict debugging with gcc],,
enable_strict=no)
dnl
dnl
dnl First check that we have a clean build if we are doing a VPATH build
if test "`cd $srcdir && pwd`" != "`pwd`" && test -f $srcdir/config.status ; then
    AC_MSG_ERROR([You cannot do a VPATH build if the source directory has been
    configured.  Run "make distclean" in $srcdir first.])
fi
dnl
dnl Get the "master" top srcdir if we are a subdir configure
if test -z "$top_srcdir" ; then
   use_top_srcdir=$srcdir   
else
   use_top_srcdir=$top_srcdir
fi
if test -z "$master_top_srcdir" ; then 
    master_top_srcdir=$use_top_srcdir
fi
AC_SUBST(master_top_srcdir)
export master_top_srcdir
#
# Get the master builddir (which may be imported from above)
if test -z "$master_top_builddir" ; then
    master_top_builddir=`pwd`
fi
export master_top_builddir
AC_SUBST(master_top_builddir)
dnl
dnl The recommended order for items in a configure.in file is
dnl     check for programs
dnl     check for libraries
dnl     check for header files
dnl     check for typedefs
dnl     check for structures
dnl     check for compiler characteristics
dnl     check for library functions
dnl     check for system services
dnl Here are some sample tests
dnl
dnl Find a C compiler (choose gcc first)
AC_PROG_CC
dnl Set CFLAGS for enable strict if necessary
PAC_CC_STRICT
AC_CHECK_PROGS(AR,ar)
AC_CHECK_PROGS(RANLIB,ranlib,true)
dnl
dnl Support shared libraries
dnl PAC_ARG_SHAREDLIBS
PAC_CC_SUBDIR_SHLIBS
dnl
dnl Dependency handling
AC_SUBST(MAKE_DEPEND_C)
dnl
dnl Is there libnsl needed for gethostbyname?
dnl AC_SEARCH_LIBS(gethostbyname,nsl)
dnl
dnl Look for Standard headers
AC_HEADER_STDC
dnl Check for a specific header
dnl AC_CHECK_HEADERS(sys/systeminfo.h)
AC_CHECK_HEADERS(sys/time.h unistd.h)
dnl
dnl Default type for timer stamp.
MPID_TIMER_TYPE=long
dnl
dnl Check for functions.  This invokes another test if the function is 
dnl found.  The braces around the second test are essential. 
dnl AC_CHECK_FUNC(setpgrp,[AC_FUNC_SETPGRP])
# clock_gettime is the POSIX gettimeofday
# gethrtime is the Solaris high-resolution timer
dnl
dnl Specific checks that a function works correctly
dnl
dnl
dnl Now that we know what the options are, choose the timer to use
dnl
dnl The default preference is
dnl    Solaris gethrtime
dnl    Posix   clock_gettime
dnl    Unix    gettimeofday (one of two versions)
dnl
dnl Also available are various hardware time stamps
dnl    Linux-x86 cycle counter
dnl    Linux-alpha cycle counter
dnl
dnl We also allow --enable-timer-type=name to select a timer type
AC_ARG_ENABLE(timer-type,[--enable-timer-type=name - Select the timer to use
for MPI_Wtime and internal timestamps.  name may be one of
    gethrtime - Solaris timer (Solaris systems only)
    clock_gettime   - Posix timer (where available)
    gettimeofday - Most Unix systems
    linux86_cycle - Linux x86; returns cycle counts, not time in seconds
    linuxalpha_cycle - Like linux86_cycle, but for Linux Alpha
    gcc_ia64_cycle - IPF ar.itc timer
    ],timer_type=$enable_timer_type)
dnl
if test -z "$timer_type" ; then 
    # Try to pick a timer based on what is available
    AC_CHECK_FUNCS(clock_gettime clock_getres gethrtime gettimeofday)
    if test "$ac_cv_func_gethrtime" = "yes" ; then
        # Sigh.  The Solaris include files do not define hrtime_t
	# Before we accept this choice, make sure that we can 
	# do arithmetic with hrtime_t .
        AC_CACHE_CHECK([that hrtime_t is properly defined for gethrtime],
	pac_cv_hrtime_works,[
	AC_TRY_COMPILE([
#include <sys/time.h>
],[hrtime_t t1, t2; t1 = 1; t2 = 2; t1 = t1 + t2;],
pac_cv_hrtime_works=yes,pac_cv_hrtime_works=no)])
	# A more ambitious test would look to see if casting an 
	# hrtime_t to int64_t works, and even more ambitious
	# would check whether long or long long was 64 bits (or even
	# better, the sizeof hrtime_t).  
    fi
    if test "$ac_cv_func_gethrtime" = "yes" -a \
            "$pac_cv_hrtime_works" = "yes" ; then
        timer_type=gethrtime
    elif test "$ac_cv_func_clock_gettime" = "yes" -a \
              "$ac_cv_func_clock_getres" = "yes" ; then
	 # Test on both because some systems (e.g., cygwin) provide
	 # clock_gettime but not clock_getres
        timer_type=clock_gettime
    elif test "$ac_cv_func_gettimeofday" = "yes" ; then
        timer_type=gettimeofday
    fi
fi
if test -z "$timer_type" ; then
    AC_MSG_ERROR([No timer found])
fi
dnl
dnl Check for valid timer and select datatypes for the time stamp
case "$timer_type" in

    gethrtime)
    MPID_TIMER_TYPE=hrtime_t
    AC_CHECK_FUNC(gethrtime,,[
         AC_MSG_ERROR([Requested timer gethrtime is not available])
])
    ;;

    clock_gettime)
    missing_function=no
    # Solaris places clock_gettime in the rt library
    AC_CHECK_FUNC(clock_gettime,,[missing_function=yes])
    if test "$missing_function" = yes ; then
        AC_SEARCH_LIBS(clock_gettime,rt,missing_function=no)
	if test "$missing_function" = yes ; then
             AC_MSG_ERROR([Requested timer clock_gettime (POSIX) is not available])
        fi
    fi
    AC_CHECK_FUNC(clock_getres,,[missing_function=yes])
    if test "$missing_function" = yes ; then
        AC_MSG_ERROR([Requested timer clock_gettime (POSIX) is not available because clock_getres, also needed, is not available])
    fi
    MPID_TIMER_TYPE="struct timespec"
    # FreeBSD 4.3 incorrectly puts the header into sys/time.h; 
    # time.h is required (see pages 45 and 46 in the POSIX standard).
    # See if we can compile
    AC_CACHE_CHECK([for CLOCK_REALTIME defined in time.h],pac_cv_posix_clock_realtime,[
    AC_TRY_COMPILE([
#include <time.h>],[
    clockid_t cid = CLOCK_REALTIME;],pac_cv_posix_clock_realtime=yes,
pac_cv_posix_clock_realtime=no)])
    if test "$pac_cv_posix_clock_realtime" = "no" ; then
         AC_MSG_WARN([POSIX timer requires definitions in time.h])
	 # Check for the definition in sys/time.h, which is where
	 # OpenBSD and FreeBSD have put it by mistake
         AC_TRY_COMPILE([
#include <time.h>
#include <sys/time.h>],[
    clockid_t cid = CLOCK_REALTIME;],pac_cv_posix_clock_realtime=yes,
pac_cv_posix_clock_realtime=no)
	if test "$pac_cv_posix_clock_realtime" = yes ; then
	    AC_MSG_WARN([sys/time.h required for POSIX timer])
	    AC_DEFINE(NEEDS_SYS_TIME_H,1,[Define if sys/time.h is required to get timer definitions])
	else
	    AC_MSG_ERROR([Cannot find the definition of CLOCK_REALTIME for the POSIX timer])
	fi
    fi
    ;;

    gettimeofday)
    MPID_TIMER_TYPE="struct timeval"
    # We may have already tested for gettimeofday.  If we got a "yes",
    # we're good to go
    if test "$ac_cv_func_gettimeofday" != "yes" ; then
        AC_CHECK_FUNC(gettimeofday,,[
         AC_MSG_ERROR([Requested timer gettimeofday is not available])
])
    fi
    ;;

    linux86_cycle|linux86_cycle_2)
    AC_CACHE_CHECK([that linux86 cycle counter is available],
pac_cv_linux86_cycle,[
    AC_TRY_COMPILE(,[
    long long var, *var_ptr=&var;
    __asm__ __volatile__  ( "cpuid ; rdtsc ; mov %%edx,%1 ; mov %%eax,%0" 
                            : "=m" (*((char *) (var_ptr))), 
                              "=m" (*(((char *) (var_ptr))+4)) 
                            :: "eax", "ebx", "ecx", "edx" ); 
],pac_cv_linux86_cycle=yes,pac_cv_linux86_cycle=no)])
    if test "$pac_cv_linux86_cycle" != "yes" ; then
        AC_MSG_ERROR([Linux86 cycle counter is not available on this system and or with the $CC compiler])
    fi
    MPID_TIMER_TYPE="long long"
    ;;

    gcc_ia64_cycle)
    AC_CACHE_CHECK([that IPF timer is available],
pac_cv_ia64_cycle,[
    AC_TRY_COMPILE(,[
    long var, *var_ptr=&var;
#ifdef __INTEL_COMPILER
#include "ia64regs.h"
    var=__getReg(_IA64_REG_AR_ITC);
#else
    __asm__ __volatile__("mov %0=ar.itc" : "=r" (var_ptr));
#endif
],pac_cv_gcc_ia64_cycle=yes,pac_cv_gcc_ia64_cycle=no)])
    if test "$pac_cv_gcc_ia64_cycle" != "yes" ; then
        AC_MSG_ERROR([IPF cycle counter is not available on this system and or with the $CC compiler])
     fi
     MPID_TIMER_TYPE="long"
     ;;

    linuxalpha_cycle)
    # See the code in mpidtime.c.  This is a trivial test for now.
    AC_CACHE_CHECK([that linux alpha cycle counter is available],
pac_cv_linuxalpha_cycle,[
    AC_TRY_COMPILE(,[
#error "LinuxAlpha cycle counter not supported"
],pac_cv_linuxalpha_cycle=yes,pac_cv_linuxalpha_cycle=no)])
    if test "$pac_cv_linuxalpha_cycle" != "yes" ; then
        AC_MSG_ERROR([LinuxAlpha cycle counter is not available on this system  and/or with the $CC compiler])
    fi
    MPID_TIMER_TYPE="long"
    ;;

    *)
    AC_MSG_ERROR([Invalid timer type $timer_type])
    ;;
esac
dnl Convert timer type to upper case
timer_type=`echo $timer_type | \
    tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
MPICH_TIMER_KIND=USE_$timer_type
AC_SUBST(MPICH_TIMER_KIND)
dnl
dnl Setup other replaceable values
dnl These are exported by the top-level configure
AC_SUBST(NO_WEAK_SYM)
AC_SUBST(NO_WEAK_SYM_TARGET)
AC_SUBST(PROFILE_DEF_MPI)
dnl MPILIBNAME is exported from the calling environment
dnl
dnl Choose the timer type (e.g., long, double, array).  long is the default
AC_SUBST(MPILIBNAME)
AC_SUBST(MPID_TIMER_TYPE)
dnl Generate the Makefile from Makefile.in
AC_OUTPUT_COMMANDS(if test ! -d ../../include ; then mkdir ../../include ; fi)
AC_OUTPUT_COMMANDS(cp mpichtimer.h ../../include)
AC_OUTPUT(Makefile mpichtimer.h)
