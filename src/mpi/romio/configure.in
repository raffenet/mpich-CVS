# -*- Mode: shell-script -*-
# build with
# autoconf --localdir=../confdb configure.in
# (or wherever the confdb is)
#
AC_INIT(adio/include/romioconf.h.in)
VERSION=1.2.6
AC_MSG_RESULT([Configuring ROMIO Version $VERSION])
CONFIGURE_ARGS="$*"
if test -n "$CONFIGURE_ARGS" ; then
    echo "Configuring with args $CONFIGURE_ARGS"
fi

AC_CONFIG_HEADER(adio/include/romioconf.h)

dnl
NOF77=0
ARCH=""
arch_IRIX=""
MPI=""
MPI_INCLUDE_DIR=""
ROMIO_INCLUDE=""
TEST_LIBNAME=""
FILE_SYSTEM=""
# Do not set variables to empty that may be communicated from the
# outside environment (e.g., MPI_LIB, MPI_BIN_DIR, LIBNAME)
DEBUG=no
MIPS=0
BITS=0
FROM_MPICH=${FROM_MPICH:-no}
FROM_MPICH2=${FROM_MPICH2:-no}
if test "$FROM_MPICH" = yes -a "$FROM_MPICH2" = yes ; then
    AC_MSG_WARN([Both FROM_MPICH and FROM_MPICH set to yes; at most one should  be yes])
    
fi
FROM_LAM=${FROM_LAM:-no}
if test "$FROM_LAM" = 1 ; then FROM_LAM=yes ; fi
CFLAGS=${CFLAGS:-""}
LL="\%lld"
AR_LOCAL=l
DEFINE_HAVE_MPI_GREQUEST="#undef HAVE_MPI_GREQUEST"
HAVE_MPI_INFO=""
BUILD_MPI_INFO=""
MPI_FINFO1=""
MPI_FINFO2=""
MPI_FINFO3=""
MPI_FINFO4=""
MPI_FARRAY1=""
MPI_FARRAY2=""
MPI_FARRAY3=""
MPI_FARRAY4=""
MPI_FARRAY5=""
MPI_FARRAY6=""
MPI_FARRAY7=""
DEFS=""
ROMIO_LFLAGS=""
ROMIO_LIBLIST=""
ROMIO_TCFLAGS=""
ROMIO_TCPPFLAGS=""
ROMIO_TFFLAGS=""
NOPROFILE=0
MPIRUN=""
FORTRAN_TEST=""
MAKE=${MAKE:-"make"}
# foll. needed for f77 test programs
F77GETARG="call getarg(i,str)"
F77IARGC="iargc()"
F77MPIOINC=""
FTESTDEFINE=""
FORTRAN_MPI_OFFSET=""
MPIOF_H_INCLUDED=0
MPI_OFFSET_KIND1="!"
MPI_OFFSET_KIND2="!"
F90=""
TEST_CC=""
TEST_F77=""
TRY_WEAK_SYMBOLS=1
#
# Error handlers (not used with MPICH2, which provides its own routines)
MPIO_EXTRA_OBJECTS="get_errh.o set_errh.o"
MPIO_EXTRA_TMP_POBJECTS="get_errh.p set_errh.p"
MPIO_EXTRA_REAL_POBJECTS="_get_errh.o _set_errh.o"
#
# Completion routines for MPIO_Requests.  MPI Implementations with
# generalized requests do not need these
MPIO_REQOBJECTS="iotest.o iotestall.o iotestany.o iotestsome.o iowait.o iowaitall.o iowaitany.o iowaitsome.o ioreq_c2f.o ioreq_f2c.o"
MPIO_REQ_TMP_POBJECTS="iotest.p iowait.p iowaitall.p iowaitany.p iotestall.p iotestany.p iowaitsome.p iotestsome.p"
MPIO_REQ_REAL_POBJECTS="_iotest.o _iowait.o _iowaitall.o _iowaitany.o _iotestall.o _iotestany.o _iowaitsome.o _iotestsome.o"
#
have_aio=no
#
known_filesystems="nfs ufs pfs piofs pvfs pvfs2 testfs xfs hfs sfs"
known_mpi_impls="mpich_mpi sgi_mpi hp_mpi cray_mpi lam_mpi"
#
# Defaults
AC_ARG_ENABLE(aio,[
--enable-aio - Request use of asynchronous I/O routines],,enable_aio=notgiven)
AC_ARG_ENABLE(echo, 
[--enable-echo  - Turn on strong echoing. The default is enable=no.] ,set -x)
AC_ARG_ENABLE(f77,
[--enable-f77 - Turn on support for Fortran 77 (default)],,enable_f77=yes)
AC_ARG_ENABLE(weak-symbols,
[--enable-weak-symbols - Turn on support for weak symbols],,enable_weak_symbols=yes)
AC_ARG_ENABLE(debug,
[--enable-debug - Build a debugging version],,)
AC_ARG_WITH(file-system,[
--with-file-system=name - Build with support for the named file systems],,)
AC_ARG_WITH(mpi,[
--with-mpi=name - Specify MPI implementation to build ROMIO for],,)
dnl
if test "$enable_f77" != "yes" ; then
   NOF77=1
fi
if test "$enable_debug" = "yes" ; then
    DEBUG=yes
fi
MPI=$with_mpi
FILE_SYSTEM=$with_file_system
#
dnl AC_CONFIG_AUX_DIR(../../../confdb)
dnl Set the directory that contains the required install-sh, config.sub,
dnl and config.guess .  Make sure that these are updated (in MPICH2, use
dnl the top-level confdb files).  This separate directory is used for
dnl the moment to allow ROMIO to be separatedly distributed.
dnl scripts.
AC_CONFIG_AUX_DIR(confdb)

#
# Check that an arch was set
# If it wasn't set, try to guess using "util/tarch"
#
if test -z "$ARCH" -a -x $srcdir/util/tarch ; then
    AC_MSG_CHECKING(for architecture)
    ARCH=`$srcdir/util/tarch | sed s/-/_/g`
    if test -z "$ARCH" ; then
       AC_MSG_RESULT(Unknown!)
       AC_MSG_ERROR([Error: Couldn\'t guess target architecture, you must 
set an architecture type with the environment variable ARCH]) 
    fi 
    eval "arch_$ARCH=1"
    AC_MSG_RESULT($ARCH)
fi
#
# check for valid architecture.  Use __ so that _ALPHA_ does not match
# LINUX_ALPHA_
#### WE SHOULD REMOVE THIS SOON
grep __"$ARCH"_ $srcdir/.config_params > /dev/null 2>&1
if test $? != 0 ; then
   AC_MSG_WARN([Unknown architecture $arch... proceeding anyway])
fi
#
#
# Find the home directory if not specified
if test "X$srcdir" != "X." -a -s $srcdir/mpi-io/Makefile.in ; then 
    ROMIO_HOME_TRIAL=$srcdir
else
    # Take advantage of autoconf2 features
    if test -n "$ac_confdir" ; then
        ROMIO_HOME_TRIAL=$ac_confdir
    else
        if test -s configure ; then
	    ROMIO_HOME_TRIAL=`pwd`
	else
	    ac_confdir=`dirname "$0" 2>/dev/null`
	    if test -n "$ac_confdir" ; then
	        ROMIO_HOME_TRIAL=$ac_confdir
	    fi
	fi
    fi
fi
AC_MSG_RESULT([ROMIO home directory is $ROMIO_HOME_TRIAL])
ROMIO_HOME=$ROMIO_HOME_TRIAL
#
# Create the "autoconf" style directory names...
# Most of these are done for us; add the documentation directories
#
# mandir is the root for the man pages
if test -z "$mandir" ; then mandir='${prefix}/man' ; fi
AC_SUBST(mandir)
if test -z "$docdir" ; then docdir='${prefix}/doc' ; fi
AC_SUBST(docdir)
if test -z "$htmldir" ; then htmldir='${prefix}/www' ; fi
AC_SUBST(htmldir) 
#
# check for valid file system
if test -n "$FILE_SYSTEM" ; then
   # if multiple filesystems are passed in, they are '+'-delimited
   # we could set the IFS to tokenize FILE_SYSTEM, but the FILE_SYSTEM env var
   # is used in multiple places in the build system: get rid of the '+'s so we
   # can use the 'for x in $FILE_SYSTEM ...' idiom 
   FILE_SYSTEM=`echo $FILE_SYSTEM|sed -e 's/\+/ /g'`
   for x in $FILE_SYSTEM
   do
      found=no
      # We could also do test -d "ad_$y" to test for known file systems
      # based on having access to the adio code.  Then adding a file 
      # system would not require changing configure to change known_filesystems
      for y in $known_filesystems ; do 
          if test $x = $y ; then
	      found=yes
	      eval "file_system_`echo $x`=1"
	      break
	  fi
      done
      if test "$found" = "no" ; then
         AC_MSG_WARN([Unknown file system $x... proceeding anyway])
      fi
   done
fi
#
# If we are building within a known MPI implementation, we must avoid the
# tests about an existing implementation
if test "$FROM_MPICH" != no -o "$FROM_MPICH2" != no -o "$FROM_LAM" != no ; then
    WITHIN_KNOWN_MPI_IMPL=yes
else
    WITHIN_KNOWN_MPI_IMPL=no
fi
# check for valid MPI implementation
if test -n "$MPI" ; then
   found=no
   for mpi in $known_mpi_impls ; do
      if test "${MPI}_mpi" = "$mpi" ; then
          found=yes
	  break
      fi
   done
   if test $found = no ; then
      AC_MSG_WARN([Unknown MPI implementation $MPI... proceeding anyway])
   fi
fi
#
# check for valid MPI include directory if specified
if test $WITHIN_KNOWN_MPI_IMPL = no ; then
   if test -n "$MPI_INCLUDE_DIR"; then
      if test ! -f "$MPI_INCLUDE_DIR/mpi.h" ; then
         AC_MSG_ERROR([Include file $MPI_INCLUDE_DIR/mpi.h not found])
      fi
   else
#     assume that mpi.h is in the default path
#     set MPI_INCLUDE_DIR to ".", so that it translates to -I. in the
#     compile command. Some compilers complain if it's only -I
      MPI_INCLUDE_DIR=.
   fi
else 
   MPI_INCLUDE_DIR=.
fi
#
# check for valid MPI library if specified
if test $WITHIN_KNOWN_MPI_IMPL = no ; then
   if test -n "$MPI_LIB" ; then
      if test ! -f "$MPI_LIB" ; then
         AC_MSG_ERROR([MPI library $MPI_LIB not found])
      fi
   fi
fi
#
#
AR="${AR:-ar} cr$AR_LOCAL"
if test -z "$RANLIB" ; then
    AC_PROG_RANLIB
fi
MAKE=${MAKE:-make}
#
# USER_CFLAGS and USER_FFLAGS are used only in test/Makefile.in
if test $DEBUG = "yes"; then
    USER_CFLAGS="$CFLAGS -g"
    USER_FFLAGS="$FFLAGS -g"
else
    USER_CFLAGS="$CFLAGS -O"
    USER_FFLAGS="$FFLAGS -O"
fi
#
# Here begin the architecture-specific tests.  
# --------------------------------------------------------------------------
# We must first select the C and Fortran compilers.  Because of the 
# way that the PROG_CC autoconf macro works (and all of the macros that
# require it, includint CHECK_HEADERS), that macro must occur exactly
# once in the configure.in file, at least as of autoconf 2.57 .  
# Unfortunately, this requirement is not enforced.  To handle this,
# we first case on the architecture; then use PROG_CC, then case on the
# architecture again for any arch-specific features.  We also set the
# C_DEBUG_FLAG and F77_DEBUG_FLAG in case debugging is selected.
# 
# For the MPICH and MPICH2 configures, the compilers will already be
# selected, so most of the compiler-selection code will be bypassed.
# --------------------------------------------------------------------------
# For historical reasons
if test -z "$FC" ; then 
    FC=$F77
fi
#
C_DEBUG_FLAG="-g"
F77_DEBUG_FLAG="-g"
C_OPT_FLAG=${CFLAGS:-"-O"}
case $ARCH in 
     sun4)
     CC=${CC:-gcc}
     F77=${FC:-f77}
     ;;

     solaris|solaris86)
     CC=${CC:-cc}
     F77=${FC:-f77}
     if test "$CC" != "gcc" ; then
	C_DEBUG_FLAG="-g -v"
     fi
     ;;
     
     rs6000)
     F77=${FC}
     # Try to use mpcc if no CC specified
     AC_PROGRAMS_CHECK(CC, mpcc, cc)
     if test $NOF77 = 0 && test -z "$F77"; then 
        AC_PROGRAMS_CHECK(F77, mpxlf, f77)
     fi
     ;;

     paragon)
     CC=${CC:-icc}
     F77=${FC:-if77}
     if test "$CC" = "icc"; then
         C_OPT_FLAG="-Knoieee -Mvect -O3"
     fi
     ;;

     tflop|tflops)
     CC=${CC:-pgcc}
     F77=${FC:-pgf77}
     CFLAGS="$CFLAGS -cougar -D__PUMA"
     if test "$CC" = "pgcc" ; then
         C_OPT_FLAG="-Knoieee -Mvect -O3"
     fi
     ;;
     
     freebsd|LINUX|netbsd|openbsd|LINUX_ALPHA)
     CC=${CC:-gcc}
     # Let the prog_f77 file g77/f77/others
     F77=${FC} 
     ;;

     SX4)
     CC=${CC:-mpicc}
     F77=${FC:-mpif90}
     if test $DEBUG != "yes" ; then
        USER_FFLAGS="$FFLAGS -Chopt"
        F77_OPT_FLAG="-Chopt"
    fi
    ;;

    hpux|sppux)
    C_DEBUG_FLAG="-g +w1"
    ;;

    alpha|ALPHA)
    CC=${CC:-cc}
    F77=${FC:-f77}
    dnl CFLAGS="$CFLAGS -g -std1 -warnprotos -verbose"
    C_DEBUG_FLAG="-g -verbose"
    ;;

    CRAY)
    CC=${CC:-cc}
    F77=${FC:-f90}
    NOF77=1
    CFLAGS="$CFLAGS -D_UNICOS"
    ;;

    sgi|IRIX64|IRIX32|IRIXN32)
    arch_IRIX=1
    CC=${CC:-cc}
    F77=${FC:-f77}
    C_DEBUG_FLAG="-g -fullwarn"
    ;;

    sgi5)
    ;;

    *)
    # Fall-through case.  Take FC 
    F77=${FC:-f77}
    ;;
esac

AC_PROG_CC
if test "$NOF77" != 1 ; then
    # Grrr.   The autoconf test for F77 will abort the configure
    # if no compiler is found.  We'd prefer to simply turn off
    # support for Fortran, and/or give a more informative message.
    AC_PROG_F77
fi
if test "$CC" = "gcc" -a -z "$C_DEBUG_FLAG" ; then
     C_DEBUG_FLAG="-g -O -Wall -Wstrict-prototypes -Wmissing-prototypes"
fi
if test $DEBUG = "yes" ; then
    CFLAGS="$CFLAGS $C_DEBUG_FLAG"
else 
    CFLAGS="$CFLAGS $C_OPT_FLAG"
fi
# ---------------------------------------------------------------------------
# Here go the rest of the tests
# ---------------------------------------------------------------------------
if test -n "$arch_sun4" ; then 
    if test "$enable_aio" != "no" ; then
        # Check for aio
	save_libs=$LIBS
	LIBS=
	AC_SEARCH_LIBS(aiowrite,aio rt,,[enable_aio=no])
	ROMIO_LIBLIST="$ROMIO_LIBLIST $LIBS"
	LIBS=$save_libs
    fi
    if test "$enable_aio" = "no" ; then
        have_aio=no
    else 
        AC_DEFINE(AIO_SUN,1,[Define for SUN0S 4])
	have_aio=yes
    fi

    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi
    if test -z "$FILE_SYSTEM" ; then
        file_system_ufs=1
        file_system_nfs=1
        FILE_SYSTEM="ufs nfs"
        AC_MSG_RESULT([configuring for file systems ufs and nfs])
    fi
fi
#
if test -n "$arch_solaris" || test -n "$arch_solaris86" ; then
    if test "$enable_aio" != "no" ; then
        # Check for aio
	save_libs=$LIBS
	LIBS=
	AC_SEARCH_LIBS(aiowrite,aio rt,,[enable_aio=no])
	ROMIO_LIBLIST="$ROMIO_LIBLIST $LIBS"
	MPI_LIB="$MPI_LIB $LIBS"
	LIBS=$save_libs
    fi
    if test "$enable_aio" = "no" ; then
        have_aio=no
    else 
        AC_DEFINE(AIO_SUN,1,[Define for SUN0S 4])
	have_aio=yes
    fi

    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi
    if test -z "$FILE_SYSTEM" ; then
        file_system_ufs=1
        file_system_nfs=1
        FILE_SYSTEM="ufs nfs"
        AC_MSG_RESULT([configuring for file systems ufs and nfs])
    fi
    AC_DEFINE(SOLARIS,1,[Define for Solaris])
    if test $MPI = "mpich" ; then
        TEST_CC=mpicc
        TEST_F77=mpif77
    else
        TEST_CC="$CC"
        TEST_F77="$F77"
    fi
    AR="ar cr"
# solaris does not have l option to ar
# solaris f90 does not have 8-byte integer type
# (it does now!!!! 11/29/01)
fi
#
if test -n "$arch_rs6000"; then
    # Check that aio is available (many systems appear to have aio
    # either installed improperly or turned off).
    # The test is the following: if not cross compiling, try to run a 
    # program that includes a *reference* to aio_write but does not call it
    # If the libraries are not set up correctly, then this will fail.
    AC_MSG_CHECKING([whether aio routines can be used])
    AC_TRY_RUN([
int main( int argc, char **argv )
{
    if (argc > 10) aio_write();
    return 0;
}
],aio_runs=yes,aio_runs=no,aio_runs=unknown)
    AC_MSG_RESULT($aio_runs)						 
    if test "$enable_aio" != "no" -a "$aio_runs" = "no" ; then
        enable_aio=no
    fi
    if test "$enable_aio" = "no" ; then
        have_aio=no
    else
        AC_DEFINE(NO_FD_IN_AIOCB,1,[Define for no fd in the aiocb])
        AC_DEFINE(AIO_HANDLE_IN_AIOCB,1,[Define for aio handle in aiocb])
	have_aio=yes
    fi
    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi
    if test -z "$FILE_SYSTEM" ; then
        if test "$CC" = "mpcc" || test "$CC" = "mpCC" ; then
            file_system_piofs=1
            FILE_SYSTEM="piofs"
            AC_MSG_RESULT([configuring for file systems piofs, ufs, and nfs])
        else 
            AC_MSG_RESULT([configuring for file systems ufs and nfs])
        fi
        file_system_ufs=1
        file_system_nfs=1
        FILE_SYSTEM="$FILE_SYSTEM ufs nfs"
    fi
    AC_DEFINE(AIX,1,[Define for AIX])
# assume long long exists.
    longlongsize=${longlongsize:-8} 
    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
fi    
#
if test -n "$arch_paragon"; then
    AR="ar860 cr$AR_LOCAL"
    MPI_LIB="$MPI_LIB -nx"
    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi
    if test -z "$FILE_SYSTEM" ; then
        file_system_pfs=1
        file_system_ufs=1
        file_system_nfs=1
        FILE_SYSTEM="pfs ufs nfs"
        AC_MSG_RESULT([configuring for file systems pfs, ufs, and nfs])
    fi
    AC_DEFINE(PARAGON,1,[Define for Intel Paragon])
    have_aio=no
# NO_AIO is if configuring for NFS/UFS. It doesn't affect PFS asynch. I/O.
# long long does not exist
    longlongsize=${longlongsize:-0} 
fi    
#
if test -n "$arch_tflop" || test -n "$arch_tflops"; then
    # TFLOP_FLAGS="-cougar -D__PUMA"
    have_aio=no
    AR="xar cr$AR_LOCAL"
    RANLIB="xranlib"
    MPI_LIB="$MPI_LIB"
    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi
    if test -z "$FILE_SYSTEM" ; then
        file_system_ufs=1
        FILE_SYSTEM="ufs"
        AC_MSG_RESULT([configuring for file system ufs])
    fi
fi
#
if test -n "$arch_freebsd" || test -n "$arch_LINUX" || test -n "$arch_LINUX_ALPHA" || test -n "$arch_netbsd" || test -n "$arch_openbsd" ; then
    if test -n "$arch_freebsd" || test -n "$arch_netbsd" || test -n "$arch_openbsd"; then
       AC_DEFINE(FREEBSD,1,[Define for FreeBSD])
       PAC_HAVE_MOUNT_NFS
       if test "$ROMIO_HAVE_MOUNT_NFS" = "1"; then
	  # Gaaa.  The Intel V7.1 compiler replaces types.h (!!) with
	  # a version that *DOES NOT CONTAIN THE DEFINITIONS NEEDED BY OTHER
	  # INCLUDE FILES*!!!!  (Specifically, __SWORD_TYPE, used 
	  # by statfs.h .  This problem was observed on Redhat 8.0 .
	  AC_CHECK_HEADERS(sys/vfs.h sys/param.h sys/mount.h sys/statvfs.h)
	  AC_MSG_CHECKING([whether struct statfs properly defined])
	  AC_TRY_COMPILE([
#ifdef HAVE_SYS_STATVFS_H
#include <sys/statvfs.h>
#endif
#ifdef HAVE_SYS_VFS_H
#include <sys/vfs.h>
#endif
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifdef HAVE_SYS_MOUNT_H
#include <sys/mount.h>
#endif],[
     struct statfs f;],pac_cv_have_statfs=yes,pac_cv_have_statfs=no)
          AC_MSG_RESULT($pac_cv_have_statfs)
	  # At this point, we could check for whether defining 
	  # __SWORD_TYPE as sizet_t or int/long (size of pointer)
	  # would help.  FIXME

	  if test "$pac_cv_have_statfs" = yes ; then
	      AC_DEFINE(HAVE_STRUCT_STATFS,1,[Define if struct statfs can be compiled])
	  fi
	  
       		AC_MSG_CHECKING([for struct statfs.f_fstypename])
		AC_TRY_COMPILE([
			#include <sys/param.h>
			#include <sys/mount.h>
			#include <string.h>],[
			struct statfs f;
			memset(&f, 0, sizeof(f));
			strncmp("nfs", f.f_fstypename, 3);],
			pac_cv_have_statfs_f_fstypename=yes,
			pac_cv_have_statfs_f_fstypename=no)
		AC_MSG_RESULT($pac_cv_have_statfs_f_fstypename)
		if test $pac_cv_have_statfs_f_fstypename = yes ; then
		    AC_DEFINE(ROMIO_HAVE_STATFS_F_FSTYPENAME, 1,[Define if statfs has f_fstypename])
		else
		    AC_DEFINE(ROMIO_HAVE_STATFS_F_FSTYPENAME, 0,[Define if statfs has f_fstypename])
		fi
       fi
       longlongsize=${longlongsize:-0}
# printf doesn't work properly and no integer*8 as far as I can tell
    else 
       AC_DEFINE(LINUX,1,[Define for Linux])
    fi
    # Find the CPP before the header check
    AC_PROG_CPP
    if test "$enable_aio" != "yes" ; then
        have_aio=no
    else
	save_libs=$LIBS
	LIBS=
        # Try to find the aio routines
	use_aio=no
        AC_HEADER_CHECK(aio.h,has_aio_h=yes,has_aio_h=no)
	AC_SEARCH_LIBS(aio_write,aio)
	# What function do we want -lrt for?  In recent Linux, aio_write64
	# is here, as is lio_listio
	AC_SEARCH_LIBS(aio_write64,rt)
	AC_SEARCH_LIBS(pthread_create,pthread,[has_pthread=yes],[has_pthread=no])
        AC_FUNC_CHECK(aio_write,has_aio_write=yes,has_aio_write=no)
	if test "$has_aio_h" = "yes" -a "$has_aio_write" = "yes" -a \
	        "$has_pthread" = "yes" ; then
	    use_aio=yes	
	fi    
	# Check for aiocb_t as a shorthand for struct aiocb
	AC_MSG_CHECKING([for aiocb_t])
	AC_TRY_COMPILE([#include <aio.h>],
[aiocb_t a;],has_aiocb_t=yes,has_aiocb_t=no)
	AC_MSG_RESULT($has_aiocb_t)
	if test "$has_aiocb_t" = "no" ; then 
	    AC_DEFINE(NEEDS_AIOCB_T,1,[Define for aiocb_t definition needed])
        fi
	if test "$use_aio" = "yes" ; then
	    ROMIO_LIBLIST="$ROMIO_LIBLIST $LIBS"
	    have_aio=yes
	else
	    have_aio=no
	fi
	LIBS=$save_libs
    fi
    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi
    if test -z "$FILE_SYSTEM" ; then
        file_system_ufs=1
        file_system_nfs=1
        FILE_SYSTEM="ufs nfs"
        AC_MSG_RESULT([configuring for file systems ufs and nfs])
    fi
fi    
#
if test -n "$arch_SX4" ; then
    have_aio=no
    AC_DEFINE(SX4,1,[Define for NEC SX4])
    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi
    if test -z "$FILE_SYSTEM" ; then
        file_system_sfs=1
        file_system_nfs=1
        FILE_SYSTEM="sfs nfs"
        AC_MSG_RESULT([configuring for file systems sfs and nfs])
    fi
    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
fi
#
if test -n "$arch_hpux" || test -n "$arch_sppux" ; then
    have_aio=no
    RANLIB=":"
    if test -z "$MPI"; then
        if test -f "/opt/mpi/include/mpi.h" ; then
            echo "assuming that you want to use ROMIO with HP MPI"
            MPI=hp
        else 
            echo "assuming that you want to use ROMIO with MPICH"
            MPI=mpich
        fi            
    fi
    if test $MPI = "mpich" ; then
        mpi_mpich=1
        MPI_LIB="$MPI_LIB -lV3"
        CC=${CC:-cc -Ae}
        F77=${FC:-f77 +U77}
    fi
    if test $MPI = "hp" ; then
        mpi_hp=1
        CC=${CC:-mpicc -Ae}
        F77=${FC:-mpif77 +U77}
    fi
    if test $MPI = "lam" && test "$FC" != ""; then
        F77="$F77 +U77"
    fi
    FTESTDEFINE="external iargc, getarg"
    if test -n "$arch_hpux" ; then
        CFLAGS="$CFLAGS -D_LARGEFILE64_SOURCE"
        AC_DEFINE(HPUX,1,[Define for HPUX])
        if test $MPI = "hp" ; then
           F77=${FC:-mpif90 +U77}
        else
           F77=${FC:-f90 +U77}
        fi
    else
        AC_DEFINE(SPPUX,1,[Define for SPPUX (Convex)])
    fi
    if test -z "$FILE_SYSTEM" ; then
        if test -n "$arch_hpux" ; then
	   AC_MSG_CHECKING([for struct flock64])
           AC_TRY_COMPILE([#include <fcntl.h>],[
struct flock64 fl; int i=F_SETLKW64;],flock64_ok="yes",flock64_ok="no")
           AC_MSG_RESULT($flock64_ok)
        else
            flock64_ok="yes"
        fi
        if test $flock64_ok = "yes" ; then
            file_system_hfs=1
            file_system_nfs=1
            FILE_SYSTEM="hfs nfs"
            AC_MSG_RESULT([configuring for file systems hfs and nfs])
        else
            file_system_ufs=1
            file_system_nfs=1
            FILE_SYSTEM="ufs nfs"
            AC_MSG_RESULT([no flock64; configuring for file systems ufs and nfs])
        fi
    fi
    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
    if test "$CC" != "gcc" ; then
        ROMIO_TCFLAGS="-Ae"
    fi
    if test "$F77" != "g77" ; then
        ROMIO_TFFLAGS="+U77"
    fi
fi
#
if test -n "$arch_alpha" || test -n "$arch_ALPHA" ; then
    AC_DEFINE(AIO_PRIORITY_DEFAULT,1,[Define for AIO priority is default])
    if test -z "$MPI" ; then
        MPI=mpich
        mpi_mpich=1
    fi
    if test -z "$FILE_SYSTEM" ; then
        file_system_ufs=1
        file_system_nfs=1
        FILE_SYSTEM="ufs nfs"
        AC_MSG_RESULT([configuring for file systems ufs and nfs])
    fi
    AC_DEFINE(DEC,1,[Define for DEC/Compaq/HP Alpha])
    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
    ROMIO_LIBLIST="$ROMIO_LIBLIST -laio"
fi    
#
if test -n "$arch_CRAY" ; then
    NOF77=1
    FTESTDEFINE="integer ilen"
    F77GETARG="call pxfgetarg(i, str, ilen, ierr)"
    have_aio=no
    RANLIB=":"
    AC_DEFINE(CRAY,1,[Define if Cray])
    if test -z "$MPI" || test -n "$mpi_sgi" ; then
        MPI=cray
        mpi_cray=1
        mpi_sgi=""
# above is to disable configure tests specific to SGI MPI
        AC_DEFINE(MPISGI,1,[Define if SGI MPI])
        AC_DEFINE(HAVE_MPI_COMBINERS,1,[Define if MPI supports datatype combiners])
        AC_DEFINE(NO_MPI_SGI_type_is_contig,1,[Define if no types show contig])
    fi
#       MPISGI needed because of error in Cray's and SGI's 
#       MPI_Type_get_contents (does not increment reference count).
#       Others needed because MPISGI needed.
    if test -z "$FILE_SYSTEM" ; then
        file_system_ufs=1
        file_system_nfs=1
        FILE_SYSTEM="ufs nfs"
        AC_MSG_RESULT([configuring for file systems ufs and nfs])
    fi
    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
fi
#
if test -n "$arch_sgi" ; then
    arch_IRIX=1
    ARCH=IRIX
fi
if test -n "$arch_IRIX64" ; then
    arch_IRIX=1
fi
if test -n "$arch_IRIX32" ; then
    arch_IRIX=1
fi
if test -n "$arch_IRIXN32" ; then
    arch_IRIX=1
fi
if test -n "$arch_sgi5" ; then
    arch_IRIX5=1
    ARCH=IRIX
fi
#
PAC_GET_SPECIAL_SYSTEM_INFO
#
# special case 'sgi5' for use on MESHINE which is much like an SGI running
# irix 5 with r4400 chips, but does not have 'hinv', so above code doesn't
# work
if test -n "$arch_sgi5"; then
   osversion=5
   cputype=4400
   IRIXARCH="$ARCH_$osversion"
   IRIXARCH="$IRIXARCH_$cputype"
# now set arch_IRIX to 1
   arch_IRIX=1
   echo "IRIX-specific architecture is $IRIXARCH"
   AC_DEFINE(IRIX,1,[Define if IRIX])
fi
#
if test -n "$arch_IRIX"; then
   if test $osversion = 4 ; then
	RANLIB="ar ts"
        if test -n "$mpi_sgi"; then
            AC_MSG_ERROR([SGI\'s MPI does not work with IRIX 4.x])
        fi
   elif test $osversion = 5 ; then
        if test -n "$mpi_sgi"; then
            AC_MSG_ERROR([SGI\'s MPI does not work with IRIX 5.x])
        fi
   elif test $osversion = 6 ; then
	if test -z "$MPI"; then
	    if test "$FROM_MPICH2" = "yes" ; then
	        # Building with MPICH2.  Distinguish from MPICH-1
		MPI=mpich2
		mpi_mpich2=1
            elif test -f "/usr/include/mpi.h" ; then
                AC_MSG_WARN([assuming that you want to use ROMIO with SGI\'s MPI])
                MPI=sgi
                mpi_sgi=1
            else 
	        AC_MSG_WARN([assuming that you want to use ROMIO with MPICH])
                MPI=mpich
                mpi_mpich=1
            fi            
	fi
        RANLIB=":"
        AC_DEFINE(AIO_SIGNOTIFY_NONE,1,[Define if no signotify])
	if test $cputype -ge 5000 ; then
            MIPS=4
        else 
            MIPS=3
        fi
   fi
   if test -n "$mpi_sgi" && test -z "$MPI_LIB" ; then
       MPI_LIB="-lmpi"
   fi
#  check if pread64 is defined
   PAC_HAVE_PREAD64
#
   if test -z "$FILE_SYSTEM" ; then
       file_system_nfs=1
       FILE_SYSTEM="nfs"
       AC_MSG_CHECKING(for xfs)
       AC_TRY_COMPILE([
#include <aio.h>],
[aiocb64_t *t1;],file_system_xfs=1;FILE_SYSTEM="xfs $FILE_SYSTEM";)
       if test "$file_system_xfs" = 1 ; then 
          AC_MSG_RESULT(yes)
       else
          AC_MSG_RESULT(no)
          file_system_ufs=1
          FILE_SYSTEM="ufs $FILE_SYSTEM"
       fi
       AC_MSG_RESULT([configuring for file systems $FILE_SYSTEM])
   fi
   AC_DEFINE(IRIX,1,[Define if IRIX])
   MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
   MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
fi

# 
# If no system selected, turn of AIO
if test "$have_aio" != yes ; then
    AC_DEFINE(NO_AIO,1,[Define if AIO should not be used])
fi


AC_HAVE_FUNCS(memalign)

#
# Question: Should ROMIO under MPICH2 ignore the Fortran tests, since 
# MPICH2 provides all of the Fortran interface routines?
#
if test $NOF77 = 0 ; then
    echo "checking Fortran external names"
    PAC_GET_FORTNAMES
    if test -n "$WDEF" ; then
        CFLAGS="$CFLAGS $WDEF"
    fi
    dnl PAC_PROG_F77_NAME_MANGLE
    dnl (need to set the new name format)
    rm -f test/mpif.h
    if test "$MPI_INCLUDE_DIR" != "." && test $WITHIN_KNOWN_MPI_IMPL = no ; then
        if test ! -d test ; then mkdir test ; fi
        ln -s $MPI_INCLUDE_DIR/mpif.h test
    fi
else 
    F77=":"
fi
#
AC_C_INLINE

# Header files
# Find the CPP before the header check
AC_PROG_CPP
AC_CHECK_HEADERS(unistd.h)
#
CROSS_SIZEOF_INT=${CROSS_SIZEOF_INT:-0}
CROSS_SIZEOF_VOID_P=${CROSS_SIZEOF_VOID_P:-0}
AC_CHECK_SIZEOF(int,$CROSS_SIZEOF_INT)
AC_CHECK_SIZEOF(void*,$CROSS_SIZEOF_VOID_P)
AC_CACHE_CHECK([for int large enough for pointers],
pac_cv_int_hold_pointer,[
if test "$ac_cv_sizeof_int" = "0" -o \
	"$ac_cv_sizeof_voidp" = "0" ; then
    pac_cv_int_hold_pointer=unknown
elif test "$ac_cv_sizeof_int" -lt "$ac_cv_sizeof_voidp" ; then
    pac_cv_int_hold_pointer=no
else
    pac_cv_int_hold_pointer=yes
fi
])
if test "$pac_cv_int_hold_pointer" != yes ; then
    AC_DEFINE(INT_LT_POINTER,1,[Define if int smaller than pointer])
fi
#
dnl The original ROMIO configure used a set of complex tests here; this
dnl is a partial reworking using the autoconf2 sizeof macros, and allowing
dnl for the standardized CROSS_xxx varaibles for cross-compilation environments
CROSS_SIZEOF_LONG_LONG=${CROSS_SIZEOF_LONG_LONG:-0}
AC_CHECK_SIZEOF(long long,$CROSS_SIZEOF_LONG_LONG)
if test "$ac_cv_sizeof_long_long" != 0 ; then
    if test "$ac_cv_sizeof_long_long" = "8" ; then
       AC_DEFINE(HAVE_LONG_LONG_64,1,[Define if long long is 64 bits])
       MPI_OFFSET_TYPE="long long"
       DEFINE_MPI_OFFSET="typedef long long MPI_Offset;"
       FORTRAN_MPI_OFFSET="integer*8"
       LL="\%lld"
    elif test "$ac_cv_sizeof_long_long" = "$ac_cv_sizeof_int" ; then
       MPI_OFFSET_TYPE="int"
       DEFINE_MPI_OFFSET="typedef int MPI_Offset;"
       FORTRAN_MPI_OFFSET="integer"
       AC_DEFINE(MPI_OFFSET_IS_INT,1,[Define if MPI_Offset is int])
       LL="\%d"
       MPI_OFFSET_KIND1="!"
       MPI_OFFSET_KIND2="!"
    else
       echo "defining MPI_Offset as long in C and integer in Fortran" 
       MPI_OFFSET_TYPE="long"
       DEFINE_MPI_OFFSET="typedef long MPI_Offset;"
       FORTRAN_MPI_OFFSET="integer"
       LL="\%ld"
       MPI_OFFSET_KIND1="!"
       MPI_OFFSET_KIND2="!"
    fi
else
    echo "defining MPI_Offset as long in C and integer in Fortran" 
    MPI_OFFSET_TYPE="long"
    DEFINE_MPI_OFFSET="typedef long MPI_Offset;"
    FORTRAN_MPI_OFFSET="integer"
    LL="\%ld"
    MPI_OFFSET_KIND1="!"
    MPI_OFFSET_KIND2="!"
fi


#
if test -n "$longlongsize"; then
   if test $WITHIN_KNOWN_MPI_IMPL = no ; then
       PAC_MPI_LONG_LONG_INT
   else
       AC_DEFINE(HAVE_MPI_LONG_LONG_INT,1,[Define if supports long long int])
   fi
fi
#
if test -n "$OFFSET_KIND" -a "A$MPI_OFFSET_KIND1" = "A!" ; then 
  MPI_OFFSET_KIND1="        INTEGER MPI_OFFSET_KIND"
  MPI_OFFSET_KIND2="        PARAMETER (MPI_OFFSET_KIND=$OFFSET_KIND)"
else
 if test "$FORTRAN_MPI_OFFSET" = "integer*8" && test "A$MPI_OFFSET_KIND2" = "A!" && test $NOF77 = 0 ; then
   PAC_MPI_OFFSET_KIND
 fi
 #
  if test "$FORTRAN_MPI_OFFSET" = "integer" && test "A$MPI_OFFSET_KIND2" = "A!" && test $NOF77 = 0 ; then
   PAC_MPI_OFFSET_KIND_4BYTE
  fi
fi
#
# check if MPI_Info functions are defined in the MPI implementation
if test $WITHIN_KNOWN_MPI_IMPL = no ; then
   PAC_MPI_INFO
else
   AC_DEFINE(HAVE_MPI_INFO,1,[Define if MPI Info is available])
   HAVE_MPI_INFO="#define HAVE_MPI_INFO"
   MPI_FINFO1="!"
   MPI_FINFO2="!"
   MPI_FINFO3="!"
   MPI_FINFO4="!"
fi   
#
if test -n "$mpi_sgi"; then
   if test -z "$HAVE_MPI_INFO" ; then
      PAC_CHECK_MPI_SGI_INFO_NULL  # is MPI_INFO_NULL defined in mpi.h?
   fi
   PAC_TEST_MPI_SGI_type_is_contig
   PAC_TEST_MPI_COMBINERS
   PAC_TEST_MPI_HAVE_OFFSET_KIND
fi
#
# check if darray and subarray constructors are defined in the MPI 
# implementation 
if test $WITHIN_KNOWN_MPI_IMPL = no ; then
   PAC_MPI_DARRAY_SUBARRAY
fi
if test $FROM_MPICH2 = yes ; then
   dnl Made this a message instead of a warning because the warning is
   dnl likely to confuse users.
   AC_MSG_RESULT("Overriding Array test for MPICH2")
   unset BUILD_MPI_ARRAY
   AC_DEFINE(HAVE_MPI_DARRAY_SUBARRAY,1,[Define if Darray is available])
   HAVE_MPI_DARRAY_SUBARRAY="#define HAVE_MPI_DARRAY_SUBARRAY"
   MPI_FARRAY1="!"
   MPI_FARRAY2="!"
   MPI_FARRAY3="!"
   MPI_FARRAY4="!"
   MPI_FARRAY5="!"
   MPI_FARRAY6="!"
   MPI_FARRAY7="!"
fi   
#
#
# Test for weak symbol support...
# We can't put # in the message because it causes autoconf to generate
# incorrect code
HAVE_WEAK_SYMBOLS=0
if test -n "$arch_hpux" || test -n "$arch_sppux" ; then
# multiple secondary definitions not allowed by HP compilers
# Fortran interface for HP already uses one secondary defn. 
# therefore, do not use this method for profiling interface.
# build profiling interface explicitly.
   TRY_WEAK_SYMBOLS=0
fi
if test $TRY_WEAK_SYMBOLS = 1 ; then
  AC_MSG_CHECKING([for weak symbol support])
  AC_TRY_LINK([
extern int PFoo(int);
#pragma weak PFoo = Foo
int Foo(int a) { return a; }
],[return PFoo(1);],has_pragma_weak=1)
  #
  # Some systems (Linux ia64 and ecc, for example), support weak symbols
  # only within a single object file!  This tests that case.
  # Note that there is an extern int PFoo declaration before the
  # pragma.  Some compilers require this in order to make the weak symbol
  # extenally visible.  
if test "$has_pragma_weak" = 1 ; then
    AC_MSG_RESULT([pragma weak])
    AC_MSG_CHECKING([that weak symbols are visible to other files])
    rm -f conftest*
    cat >>conftest1.c <<EOF
extern int PFoo(int);
#pragma weak PFoo = Foo
int Foo(int);
int Foo(int a) { return a; }
EOF
    cat >>conftest2.c <<EOF
extern int PFoo(int);
int main(int argc, char **argv) {
return PFoo(0);}
EOF
    ac_link2='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest1.c conftest2.c $LIBS >conftest.out 2>&1'
    if eval $ac_link2 ; then
        AC_MSG_RESULT(yes)
    else
      echo "$ac_link2" 1>&AC_FD_CC
      echo "Failed program was" 1>&AC_FD_CC
      cat conftest1.c 1>&AC_FD_CC
      cat conftest2.c 1>&AC_FD_CC
      if test -s conftest.out ; then cat conftest.out 1>&AC_FD_CC ; fi
      AC_MSG_RESULT(no)
      has_pragma_weak=0
    fi
    rm -f conftest*
  fi
  if test "$has_pragma_weak" = 1 ; then
    HAVE_WEAK_SYMBOLS=1
    AC_DEFINE(HAVE_PRAGMA_WEAK,1,[Define if pragma weak available])
  else
    AC_TRY_LINK([
extern int PFoo(int);
#pragma _HP_SECONDARY_DEF Foo PFoo
int Foo(int a) { return a; }
],[return PFoo(1);],has_pragma_hp_secondary=1)
    if test "$has_pragma_hp_secondary" = 1 ; then 
        AC_MSG_RESULT([pragma _HP_SECONDARY_DEF])
        HAVE_WEAK_SYMBOLS=1
        AC_DEFINE(HAVE_PRAGMA_HP_SEC_DEF,1,[Define for HP weak pragma])
    else
        AC_TRY_LINK([
extern int PFoo(int);
#pragma _CRI duplicate PFoo as Foo
int Foo(int a) { return a; }
],[return PFoo(1);],has_pragma_cri_duplicate=1)
        if test "$has_pragma_cri_duplicate" = 1 ; then
	    AC_MSG_RESULT([pragma _CRI duplicate x as y])
	    HAVE_WEAK_SYMBOLS=1
	    AC_DEFINE(HAVE_PRAGMA_CRI_DUP,1,[Define for CRAY weak dup])
        else    
            AC_MSG_RESULT(no)
        fi
    fi
  fi
fi
if test "$HAVE_WEAK_SYMBOLS" = 1 ; then
    AC_DEFINE(HAVE_WEAK_SYMBOLS,1,[Define if weak symbols available])
fi
AC_SUBST(HAVE_WEAK_SYMBOLS)
#
# if FILE_SYSTEM is not set above, use ufs and nfs as default
#
if test -z "$FILE_SYSTEM" ; then
    file_system_ufs=1
    file_system_nfs=1
    FILE_SYSTEM="ufs nfs"
    AC_MSG_RESULT([configuring for file systems ufs and nfs])
fi
#
# Check whether the MPI Offset type is compatible with struct flock
AC_MSG_CHECKING([whether struct flock compatible with MPI_Offset])
AC_TRY_COMPILE([#include <fcntl.h>],
[struct flock l;
 $MPI_OFFSET_TYPE a=1;
 l.l_start = a; 
 l.l_len   = a;
],pac_cv_struct_flock_and_mpi_offset=yes,pac_cv_struct_flock_and_mpi_offset=no)
AC_MSG_RESULT($pac_cv_struct_flock_and_mpi_offset)
# FIXME: We should look for struct flock64 and the F_SETLK64/F_GETLK64
# ADIOI_Set_lock could use these instead.
if test "$pac_cv_struct_flock_and_mpi_offset" = no ; then
    AC_MSG_CHECKING([whether struct flock compatible with int])
    AC_TRY_COMPILE([#include <fcntl.h>],
[struct flock l;
 int a=1;
 l.l_start = a; 
 l.l_len   = a;
],pac_cv_struct_flock_and_int=yes,pac_cv_struct_flock_and_int=no)
    AC_MSG_RESULT($pac_cv_struct_flock_and_int)
    if test "$pac_cv_struct_flock_and_int" = yes ; then
        AC_DEFINE(NEEDS_INT_CAST_WITH_FLOCK,1,[Define if l_start and l_len data should be cast as int])
    fi
    # FIXME.  Solaris header files define off_t as a UNION if 64bit file
    # sizes are selected.  Gah!
fi

if test -n "$file_system_nfs" ; then
   # Check for problems with locks
   # We no longer do this within the configure test.  Instead,
   # we suggest tha the user run maint/nfslock.c
   AC_MSG_WARN([File locks may not work with NFS.  See the Installation and
users manual for instructions on testing and if necessary fixing this])
fi
if test -n "$file_system_nfs"; then
    AC_DEFINE(NFS,1,[Define for NFS])
fi
if test -n "$file_system_ufs"; then
    AC_DEFINE(UFS,1,[Define for UFS])
fi
if test -n "$file_system_hfs"; then
    AC_DEFINE(HFS,1,[Define for HFS])
fi
if test -n "$file_system_sfs"; then
    AC_DEFINE(SFS,1,[Define for SFS])
fi
if test -n "$file_system_xfs"; then
    AC_DEFINE(XFS,1,[Define for XFS])
    # Check for memalign value (this was P A C_GET_XFS_MEMALIGN,
    # switched to autoconf 2)
    AC_CACHE_CHECK([for memory alignment needed for direct I/O],
pac_cv_memalignval,[
/bin/rm -f confmemalignval
/bin/rm -f /tmp/romio_tmp.bin
AC_TRY_RUN([#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
main() { 
  struct dioattr st;
  int fd = open("/tmp/romio_tmp.bin", O_RDWR | O_CREAT, 0644);
  FILE *f=fopen("confmemalignval","w");
  if (fd == -1) exit(1);
  if (!f) exit(1);
  fcntl(fd, F_DIOINFO, &st);
  fprintf( f, "%u\n", st.d_mem);
  exit(0);
}],pac_cv_memalignval=`cat confmemalignval`,pac_cv_memalignval="unknown",pac_cv_memalignval="unknown")
    /bin/rm -f confmemalignval
    /bin/rm -f /tmp/romio_tmp.bin
])
    if test -n "$pac_cv_memalignval" -a "$pac_cv_memalignval" != 0 -a \
    "$pac_cv_memalignval" != "unknown" ; then
        CFLAGS="$CFLAGS -DXFS_MEMALIGN=$pac_cv_memalignval"
    else
        AC_MSG_RESULT(assuming 128 for memory alignment)
        CFLAGS="$CFLAGS -DXFS_MEMALIGN=128"
    fi
fi

if test -n "$file_system_pvfs"; then
   # Use ROMIO_PVFS instead of PVFS because FREEBSD defines PVFS.
    AC_DEFINE(ROMIO_PVFS,1,[Define for Romio with PVFS])
fi
if test -n "$file_system_pvfs2"; then
    AC_DEFINE(ROMIO_PVFS2,1,[Define for Romio with PVFS2])
fi
if test -n "$file_system_pfs"; then
    AC_DEFINE(PFS,1,[Define for PFS])
fi
if test -n "$file_system_testfs"; then
    AC_DEFINE(ROMIO_TESTFS,1,[Define for TESTFS])
fi
if test -n "$file_system_piofs"; then
    AC_DEFINE(PIOFS,1,[Define for PIOFS])
    USER_CFLAGS="$USER_CFLAGS -bI:/usr/include/piofs/piofs.exp"
    ROMIO_LFLAGS="$USER_FFLAGS -bI:/usr/include/piofs/piofs.exp"
    USER_FFLAGS="$USER_FFLAGS -bI:/usr/include/piofs/piofs.exp"
fi
if test -n "$mpi_mpich"; then
   if test "$FROM_MPICH2" = no; then
      AC_DEFINE(NEEDS_MPI_TEST,1,[Define if mpi_test needed])
      AC_DEFINE(MPICH,1,[Define if using MPICH])
      if test -z "$arch_SX4" ; then
         MPIOF_H_INCLUDED=1
      fi
   fi
fi
if test -n "$mpi_sgi"; then
   AC_DEFINE(MPISGI,1,[Define if SGI MPI])
fi
if test -n "$mpi_lam"; then
   AC_DEFINE(MPILAM,1,[Define if using LAM/MPI])
fi
if test -n "$mpi_hp"; then
   AC_DEFINE(MPIHP,1,[Define if using HP MPI])
   if test "$NOF77" = 0; then
      PAC_CHECK_MPIOF_H
   fi
fi
#
PAC_FUNC_STRERROR
if test -z "$srcdir" -o "$srcdir" = "." ; then srcdir="$ROMIO_HOME" ; fi
AC_SUBST(srcdir)
# The master_top_srcdir is the location of the source for the building
# package.  This is used only as part of the MPICH2 build, including 
# the documentation targets mandoc, htmldoc, and latexdoc
if test -z "$master_top_srcdir" ; then
    if test "$FROM_MPICH2" = yes ; then
        AC_MSG_WARN([Could not determine master_top_srcdir])
    fi
fi
AC_SUBST(master_top_srcdir)
#
# Get the master builddir (which may be imported from above)
if test -z "$master_top_builddir" ; then
    master_top_builddir=`pwd`
fi
export master_top_builddir
AC_SUBST(master_top_builddir)

# The following definitions are needed within adio/common/status_setb.c
if test "$FROM_MPICH" = yes ; then
   AC_DEFINE(MPICH,1,[Define if compiling within MPICH])
elif test "$FROM_MPICH2" = yes ; then 
   AC_DEFINE(MPICH2,1,[Define if compiling within MPICH2])
elif test "$FROM_MPILAM" = yes ; then
   AC_DEFINE(MPILAM,1,[Define if compiling within LAM/MPI])
fi

if test "$FROM_MPICH2" = no -a "$FROM_MPICH" = no ; then 
    if test -z "$LIBNAME"; then
        LIBNAME="$ROMIO_HOME/lib/$ARCH/libmpio.a"
    fi
    #
    if test ! -d $ROMIO_HOME/lib ; then 
        mkdir $ROMIO_HOME/lib
    fi
    if test ! -d $ROMIO_HOME/lib/$ARCH ; then 
        mkdir $ROMIO_HOME/lib/$ARCH
    fi
else
    MPILIBNAME=${MPILIBNAME:-mpich}
    if test -z "$LIBNAME" ; then
        if test -n "$top_build_dir" -a -d "$top_build_dir/lib" ; then
            LIBNAME=$top_build_dir/lib/lib${MPILIBNAME}.a
        else
            LIBNAME="$ROMIO_HOME/lib${MPILIBNAME}.a"
	fi
    fi
fi
if test "$FROM_MPICH2" != no ; then
    # use the error handlers from MPICH2
    MPIO_EXTRA_OBJECTS=
    MPIO_EXTRA_TMP_POBJECTS=
    MPIO_EXTRA_REAL_POBJECTS=
    # Use generalized request to get the multiple-completion routines
    MPIO_REQOBJECTS=
    MPIO_REQ_TMP_POBJECTS=
    MPIO_REQ_REAL_POBJECTS=
fi
AC_SUBST(MPIO_EXTRA_OBJECTS)
AC_SUBST(MPIO_EXTRA_TMP_POBJECTS)
AC_SUBST(MPIO_EXTRA_REAL_POBJECTS)
AC_SUBST(MPIO_REQOBJECTS)
AC_SUBST(MPIO_REQ_TMP_POBJECTS)
AC_SUBST(MPIO_REQ_REAL_POBJECTS)
#
if test $NOF77 = 1 ; then
   F77=":"
else
   FORTRAN_TEST="fperf fcoll_test fmisc pfcoll_test" 
fi
#
if test $WITHIN_KNOWN_MPI_IMPL = no ; then
   PAC_TEST_MPI
   PAC_NEEDS_FINT
else
   NEEDS_MPI_FINT=""
fi
#
if test "$MPI_INCLUDE_DIR" = "." ; then
   ROMIO_INCLUDE="-I../include"
else 
   ROMIO_INCLUDE="-I../include -I$MPI_INCLUDE_DIR"
fi
#
TEST_LIBNAME=$LIBNAME
MPIRUN=mpirun
#
# if MPICH, use mpicc in test programs
#
if test "$FROM_MPICH" = yes ; then
   MPICH_HOME=`dirname $ROMIO_HOME`
   if test -z "$MPI_BIN_DIR" ; then MPI_BIN_DIR=$MPICH_HOME/bin ; fi
   TEST_CC=$MPI_BIN_DIR/mpicc
   MPI_LIB=""
   ROMIO_INCLUDE=""
   USER_CFLAGS=""
   USER_FFLAGS=""
   TEST_LIBNAME=""
   MPIRUN=$MPI_BIN_DIR/mpirun
   if test -n "$arch_SX4" || test -n "$arch_hpux" ; then
      TEST_F77=$MPI_BIN_DIR/mpif90
   else
      TEST_F77=$MPI_BIN_DIR/mpif77
   fi
   CC=$MPI_BIN_DIR/mpicc
#   if test $FROM_MPICH2 != yes ; then
#       BUILD_MPI_ARRAY=1
#       BUILD_MPI_INFO=1
#   fi
   # A later test will insert the mpi2-other/info and array directories based
   # on the value of BUILD_MPI_xxxx.  This lets MPICH2 turn these off,
   # since MPICH2 provides these routines elsewhere
   EXTRA_DIRS="mpi-io/fortran"
   # Some older implementations of the ADI do not include the 
   # MPID_Status_set_bytes routine.   This uses either the 
   # environment variable ADI3_WITHOUT_SET_BYTES or the
   # with arg --without-setbytes
   if test "$ADI2_WITHOUT_SET_BYTES" != yes -a \
           "$with_setbytes" != no ; then
       AC_DEFINE(HAVE_STATUS_SET_BYTES,1,[Define if have MPIR_Status_set_bytes])
   fi
elif test $FROM_LAM = yes ; then
   # LAM does have the status set bytes functionality
   AC_DEFINE(HAVE_STATUS_SET_BYTES,1,[Define if have MPIR_Status_set_bytes])
        
   # Used in the tests/ subdirectory for after ROMIO is built
   TEST_CC=mpicc
   TEST_F77=mpif77
   MPIRUN=mpirun 
   MPI_LIB=
   ROMIO_INCLUDE=
   USER_CFLAGS=
   USER_FFLAGS=
   TEST_LIBNAME=
   EXTRA_DIRS="mpi-io/fortran mpi2-other/info mpi2-other/info/fortran mpi2-other/array mpi2-other/array/fortran"
elif test $FROM_MPICH2 = yes ; then
   # For now, separate the mpich2 from mpich cases
   MPICH_HOME=`dirname $ROMIO_HOME`
   MPICH_HOME=`dirname $MPICH_HOME`
   MPICH_HOME=`dirname $MPICH_HOME`
   if test -z "$MPI_BIN_DIR" ; then MPI_BIN_DIR=$MPICH_HOME/bin ; fi
   # No special compiler script.
   # BUT we need the include paths
   CC="$CC -I${use_top_srcdir}/src/include -I${top_build_dir}/src/include"
   TEST_CC="$CC"
   MPI_LIB="$LIBNAME"
   ROMIO_INCLUDE=""
   USER_CFLAGS=""
   USER_FFLAGS=""
   TEST_LIBNAME=""
   MPIRUN=$MPI_BIN_DIR/mpiexec
   #
   # Turn off the building of the Fortran interface and the Info routines
   EXTRA_DIRS=""
   AC_DEFINE(HAVE_STATUS_SET_BYTES,1,[Define if status_set_bytes available])
   DEFINE_HAVE_MPI_GREQUEST="#define HAVE_MPI_GREQUEST"
fi
#
#
# feature tests:  we can't test features if building as part of MPICH because
# we don't yet have an implementation against which we can test
#
if test $WITHIN_KNOWN_MPI_IMPL = no ; then
   PAC_TEST_MPIR_STATUS_SET_BYTES
   PAC_TEST_MPI_GREQUEST
   AC_DEFINE(PRINT_ERR_MSG,1,[Define for printing error messages])
fi
#
if test -z "$TEST_CC" ; then
   TEST_CC="$CC"
fi
if test -z "$TEST_F77" ; then
   TEST_F77="$F77"
fi
#
# Create the directory lists for the Makefile
FILE_SYS_DIRS=""
for dir in $FILE_SYSTEM ; do
    FILE_SYS_DIRS="$FILE_SYS_DIRS adio/ad_$dir"
done
EXTRA_SRC_DIRS=""
if test "$BUILD_MPI_INFO" = 1 ; then
    EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi2-other/info"
    if test "$NOF77" = 0 -a "$FROM_MPICH2" != yes ; then
        EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi2-other/info/fortran"
    fi
fi
if test "$BUILD_MPI_ARRAY" = 1 ; then
    EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi2-other/array"
    if test "$NOF77" = 0 -a "$FROM_MPICH2" != yes ; then
        EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi2-other/array/fortran"
    fi
fi
if test "$NOF77" = 0 -a "$FROM_MPICH2" != yes ; then
   EXTRA_SRC_DIRS="$EXTRA_SRC_DIRS mpi-io/fortran"
fi
AC_SUBST(EXTRA_SRC_DIRS)
AC_SUBST(FILE_SYS_DIRS)

#
CFLAGS="$CFLAGS -DHAVE_ROMIOCONF_H"
#

AC_CHECK_HEADERS(unistd.h,
        AC_MSG_CHECKING(for large file defines)
        AC_TRY_COMPILE([
                #include <unistd.h>
                ], [
                #ifndef _LFS64_LARGEFILE
                #error no largefile defines
                #endif
                ],
                CFLAGS="${CFLAGS} -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64"
                AC_MSG_RESULT(yes),
                AC_MSG_RESULT(none) )
        )

echo "setting CC to $CC"
echo "setting F77 to $F77"
echo "setting TEST_CC to $TEST_CC"
echo "setting TEST_F77 to $TEST_F77"
echo "setting CFLAGS to $CFLAGS"
echo "setting USER_CFLAGS to $USER_CFLAGS"
echo "setting USER_FFLAGS to $USER_FFLAGS"
#
VPATH='VPATH = .:${srcdir}'
AC_SUBST(VPATH)
AC_SUBST(ARCH)
AC_SUBST(FILE_SYSTEM)
AC_SUBST(CC)
AC_SUBST(CFLAGS)
AC_SUBST(USER_CFLAGS)
AC_SUBST(USER_FFLAGS)
AC_SUBST(MIPS)
AC_SUBST(BITS)
AC_SUBST(MPI)
AC_SUBST(AR)
AC_SUBST(RANLIB)
AC_SUBST(MPI_INCLUDE_DIR)
AC_SUBST(MPI_LIB)
AC_SUBST(F77)
AC_SUBST(NOF77)
AC_SUBST(NOPROFILE)
AC_SUBST(MAKE)
AC_SUBST(arch_IRIX)
AC_SUBST(ROMIO_HOME)
AC_SUBST(LIBNAME)
AC_SUBST(TEST_LIBNAME)
AC_SUBST(LL)
AC_SUBST(F77GETARG)
AC_SUBST(F77IARGC)
AC_SUBST(FTESTDEFINE)
AC_SUBST(FORTRAN_MPI_OFFSET)
AC_SUBST(FROM_MPICH)
AC_SUBST(FROM_MPICH2)
AC_SUBST(FROM_LAM)
AC_SUBST(WITHIN_KNOWN_MPI_IMPL)
AC_SUBST(NEEDS_MPI_FINT)
AC_SUBST(HAVE_MPI_INFO)
AC_SUBST(BUILD_MPI_INFO)
AC_SUBST(HAVE_MPI_DARRAY_SUBARRAY)
AC_SUBST(BUILD_MPI_ARRAY)
AC_SUBST(DEFINE_MPI_OFFSET)
AC_SUBST(DEFINE_HAVE_MPI_GREQUEST)
AC_SUBST(MPI_OFFSET_TYPE)
AC_SUBST(MPI_FINFO1)
AC_SUBST(MPI_FINFO2)
AC_SUBST(MPI_FINFO3)
AC_SUBST(MPI_FINFO4)
AC_SUBST(MPI_FARRAY1)
AC_SUBST(MPI_FARRAY2)
AC_SUBST(MPI_FARRAY3)
AC_SUBST(MPI_FARRAY4)
AC_SUBST(MPI_FARRAY5)
AC_SUBST(MPI_FARRAY6)
AC_SUBST(MPI_FARRAY7)
AC_SUBST(MPI_OFFSET_KIND1)
AC_SUBST(MPI_OFFSET_KIND2)
AC_SUBST(MPIO_REQOBJECTS)
AC_SUBST(TEST_CC)
AC_SUBST(TEST_F77)
AC_SUBST(ROMIO_INCLUDE)
AC_SUBST(ROMIO_LFLAGS)
AC_SUBST(ROMIO_LIBLIST)
AC_SUBST(ROMIO_TCFLAGS)
AC_SUBST(ROMIO_TCPPFLAGS)
AC_SUBST(ROMIO_TFFLAGS)
AC_SUBST(MPIRUN)
AC_SUBST(FORTRAN_TEST)
dnl
dnl Dependency handling
AC_SUBST(MAKE_DEPEND_C)
dnl
dnl Support shared libraries
if test -z "$ENABLE_SHLIB" ; then
   ENABLE_SHLIB=none
fi
AC_SUBST(ENABLE_SHLIB)
AC_SUBST(CC_SHL)
AC_SUBST(LIBTOOL)
# Remove the .a from the library file name (so that we can use .so or
# other appropriate suffix)
SHLIBNAME=`echo $LIBNAME | sed 's/\.a//'`
AC_SUBST(SHLIBNAME)
dnl
if test ! -d adio ; then mkdir adio ; fi
if test ! -d adio/include ; then mkdir adio/include ; fi
if test ! -d mpi2-other ; then mkdir mpi2-other ; fi
# 
# Make sure we remove any configuration file incase there is out-of-date data.
# We remove the version in include in case this is a vpath build
rm -f adio/include/romioconf.h ${use_top_srcdir}/src/mpi/romio/adio/include/romioconf.h ${use_top_srcdir}/adio/include/romioconf.h
#
# Create makefiles for all of the adio devices.  Only the ones that 
# are active will be called by the top level ROMIO make
AC_OUTPUT_COMMANDS([chmod 755 util/romioinstall test/runtests])
AC_OUTPUT(Makefile localdefs mpi-io/Makefile mpi2-other/info/Makefile \
		   mpi2-other/array/Makefile adio/common/Makefile \
		   test/Makefile test/misc.c test/large_file.c \
		   test/runtests util/romioinstall include/mpio.h \
		   include/mpiof.h \
		   adio/ad_nfs/Makefile adio/ad_ufs/Makefile \
		   adio/ad_xfs/Makefile adio/ad_hfs/Makefile \
		   adio/ad_sfs/Makefile adio/ad_pfs/Makefile \
		   adio/ad_testfs/Makefile adio/ad_pvfs/Makefile \
		   adio/ad_pvfs2/Makefile adio/ad_piofs/Makefile \
                   mpi-io/fortran/Makefile mpi2-other/info/fortran/Makefile \
                   mpi2-other/array/fortran/Makefile test/fmisc.f \
                   test/fcoll_test.f test/pfcoll_test.f test/fperf.f )
#
rm -f *.o
if test "$ROMIO_NO_BANNER" != "yes" -a "$FROM_MPICH" = no -a \
         $FROM_MPICH2 = no ; then
cat <<EOF

Please register your copy of ROMIO with us by sending email
to majordomo@mcs.anl.gov with the message
subscribe romio-users
This will enable us to notify you of new releases of ROMIO
as well as bug fixes.

EOF
fi
if test $FROM_MPICH2 = yes -a "$NOF77" = 0 ; then
      sed 5d test/fcoll_test.f > test/tmp
      mv test/tmp test/fcoll_test.f
      sed 5d test/pfcoll_test.f > test/tmp
      mv test/tmp test/fcoll_test.f
      sed 5d test/fperf.f > test/tmp
      mv test/tmp test/fperf.f
      sed 5d test/fmisc.f > test/tmp
      mv test/tmp test/fmisc.f
fi
if test $FROM_MPICH = no -a $FROM_MPICH2 = no ; then
   AC_MSG_RESULT([Configure done. Now type make])
fi
dnl PAC_SUBDIR_CACHE_CLEANUP
exit 0
