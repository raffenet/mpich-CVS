#include "ad_ln_lnio.h"
#include "adio.h"

void ADIOI_LNIO_Free_handle(struct lnio_handle_t *handle) {
  if (!handle->lbone_server) free(handle->lbone_server);
  if (!handle->lbone_location) free(handle->lbone_location);
  if (!handle) free(handle);
}

int ADIOI_LNIO_Open(ADIO_File fd) 
{
  int perm, flag, file_exists, tempfd, ret;
  struct lnio_handle_t *handle;
  char *value;

  //#ifdef JLEE_DEBUG
  printf("ADIOI_LNIO_Open: entering the function for %s\n", fd->filename);
  //#endif 

  handle = (struct lnio_handle_t *)calloc(1, sizeof(struct lnio_handle_t));
  if (!handle) return -1;
  
  // environment setup  
  value = (char *) ADIOI_Malloc((MPI_MAX_INFO_VAL + 1) * sizeof(char));
  MPI_Info_get(fd->info, "LBONE_SERVER", MPI_MAX_INFO_VAL, value, &flag);
  if (flag) {
    handle->lbone_server = strdup(value);
  } else {
    handle->lbone_server = strdup(LBONE_SERVER);
  }
    
  MPI_Info_get(fd->info, "LBONE_PORT", MPI_MAX_INFO_VAL, value, &flag);
  if (flag) {
    handle->lbone_port = atoi(value);
  } else {
    handle->lbone_port = LBONE_PORT;
  }
  
  MPI_Info_get(fd->info, "LBONE_LOCATION", MPI_MAX_INFO_VAL, value, &flag);
  if (flag) {
    handle->lbone_location = strdup(value);
  } else {
    handle->lbone_location = strdup(LBONE_LOCATION);
  }
  
  MPI_Info_get(fd->info, "LORS_BLOCKSIZE", MPI_MAX_INFO_VAL, value, &flag);
  if (flag) {
    handle->lors_blocksize = atoi(value) * MEGA;
  } else {
    if(fd->access_mode & ADIO_WRONLY || fd->access_mode & ADIO_CREATE)
      handle->lors_blocksize = LORS_BLOCKSIZE * MEGA;
    else
      handle->lors_blocksize = MEGA;
  }
  
  MPI_Info_get(fd->info, "LORS_DURATION", MPI_MAX_INFO_VAL, value, &flag);
  if (flag) {
    handle->lors_duration = atoi(value);
  } else {
    handle->lors_duration = LORS_DURATION;
  }
  
  MPI_Info_get(fd->info, "LORS_COPIES", MPI_MAX_INFO_VAL, value, &flag);
  if(flag) {
    handle->lors_copies = atoi(value);
  } else {
    handle->lors_copies = LORS_COPIES;
  }
  
  MPI_Info_get(fd->info, "LORS_THREADS", MPI_MAX_INFO_VAL, value, &flag);
  if (flag) {
    handle->lors_threads = atoi(value);
  } else {
    handle->lors_threads = LORS_THREADS;
  }
  
  MPI_Info_get(fd->info, "LORS_TIMEOUT", MPI_MAX_INFO_VAL, value, &flag);
  if (flag) {
    handle->lors_timeout = atoi(value);
  } else {
    handle->lors_timeout = LORS_TIMEOUT;
  }
  
  MPI_Info_get(fd->info, "LORS_SERVERS", MPI_MAX_INFO_VAL, value, &flag);
  if(flag) {
    handle->lors_servers = atoi(value);
  } else {
    handle->lors_servers = LORS_SERVERS;
  }
  
  MPI_Info_get(fd->info, "LORS_SIZE", MPI_MAX_INFO_VAL, value, &flag);
  if(flag) {
    handle->lors_size = atoi(value) * MEGA;
  } else {
    handle->lors_size = LORS_SIZE * MEGA;
  }
  
  MPI_Info_get(fd->info, "LORS_DEMO", MPI_MAX_INFO_VAL, value, &flag);
  if (flag) {
    g_lors_demo = 1;
  } 
  
  free(value);
  
   //#ifdef JLEE_DEBUG
  printf("ADIOI_LNIO_Open: finished environment setup\n");
  printf("ADIOI_LNIO_Open: lbone_server %s lbone_port %d\n", handle->lbone_server, handle->lbone_port);
  printf("ADIOI_LNIO_Open: lbone_location %s lors_blocksize %d\n", handle->lbone_location, handle->lors_blocksize);
  printf("ADIOI_LNIO_Open: lors_duration %d lors_copies %d\n", handle->lors_duration, handle->lors_copies);
  printf("ADIOI_LNIO_Open: lors_threads %d lors_timeout %d\n", handle->lors_threads, handle->lors_timeout);
  printf("ADIOI_LNIO_Open: lors_servers %d lors_size %d\n", handle->lors_servers, handle->lors_size);
  //#endif 

  if (!handle->lbone_server && !(fd->access_mode & ADIO_RDONLY || 
				 !fd->access_mode || 
				 fd->access_mode & ADIO_RDWR)) {
    errno = EINVAL;
    return -1;
  }  /* Why do we need this? */


  handle->offset = 0;

  /*  Buffered I/O stuff

      handle->b_pos = 0;
      handle->begin = 0;
      handle->end = 0;
      handle->dirty_buffer = 0;
      
      handle->buffer = malloc(handle->lors_blocksize * handle->lors_threads);
      if (!handle->buffer) {
      ADIOI_LN_Free_handle(handle);
      
      errno = EIO;
      return -1;
      }
  */
  
  /* check if the file exists */
  tempfd = open(fd->filename, O_RDONLY);
  if (tempfd == -1) file_exists = 0; 
  else {
    file_exists = 1;
    close(tempfd);
  }
  
 //#ifdef JLEE_DEBUG
  printf("ADIOI_LNIO_Open: specified file %s\n", file_exists ? "exists" : "doesn't exist");
  //#endif 

  if (!file_exists) {  /* file doesn't exist */
    if (!(fd->access_mode & ADIO_CREATE)) {
      errno = ENOENT;
      return -1;
    }
    
    /*      
	    fd = open(handle->filename, amode, perm);
	    if(fd == -1) {
	    ADIO_LN_Free_handle(handle);
	    errno = EIO;
	    return NULL;
	    }
	    close(fd);
    */
    
    //#ifdef JLEE_DEBUG
    printf("ADIOI_LNIO_Open: Calling lorsGetDepotPool\n");
    //#endif 
    
    int i;
    IBP_depot *depot_array = NULL;
    depot_array = (IBP_depot *)calloc(2, sizeof(IBP_depot));
    for (i = 0; i < 1; i++)
      depot_array[i] = (IBP_depot)calloc(1, sizeof(struct ibp_depot));
    depot_array[1] = NULL; 
    /* need to put NULL at the end - or not needed because we did calloc?*/

    strcpy(depot_array[0]->host, "ibp.accre.vanderbilt.edu");
    depot_array[0]->port = 6715;
   
    ret = lorsGetDepotPool(&handle->dp, /*handle->lbone_server, 
					  handle->lbone_port, NULL,*/
			   NULL, 0, depot_array,
			   handle->lors_servers,
			   handle->lbone_location, 
			   handle->lors_size / MEGA + 1,
			   /* shouldn't this be divided by lors_servers? */
			   IBP_SOFT, 
			   handle->lors_duration, 
			   handle->lors_threads,
			   handle->lors_timeout, 
			   LORS_CHECKDEPOTS);
    printf("ret: %d\n", ret);
    if (ret != LORS_SUCCESS) {
      ADIOI_LNIO_Free_handle(handle);
      errno = EIO;
      return -1;
    }
    /* TODO: will probably reorder depots in the depot pool */
    
    //#ifdef JLEE_DEBUG
    printf("ADIOI_LNIO_Open: Calling lorsExnodeCreate\n");
    //#endif 

    ret = lorsExnodeCreate(&handle->ex);
    if (ret != LORS_SUCCESS) {
      ADIOI_LNIO_Free_handle(handle);
      errno = EIO;
      return -1;
    }
  } else { /* file exists */
    if (fd->access_mode & ADIO_EXCL) {
      ADIOI_LNIO_Free_handle(handle);
      errno = EEXIST;
      return -1;
    }
    
    printf("ADIOI_LNIO_Open: calling lorsFileDeserialize\n");
    ret = lorsFileDeserialize(&handle->ex, fd->filename, NULL);
    if (ret != LORS_SUCCESS) {
      ADIOI_LNIO_Free_handle(handle);	
      errno = EIO;
      return -1;
    } 
    printf("ADIOI_LNIO_Open: successfully called lorsFileDeserialize\n");
    
    /*LorsEnum list = NULL, it = NULL;
    LorsMapping *mp = NULL;
    
    lorsExnodeEnum (handle->ex, &list);
    lorsEnumNext(list, &it, &mp);
    lorsEnumFree(list);
    */
    /* do we really need this part? */
    /* if(mp->e2e_bs && handle->lors_blocksize % mp->e2e_bs) {
       int size = (1 + handle->lors_blocksize / mp->e2e_bs)
       * mp->e2e_bs;*/
    /*    free(handle->buffer);
	  handle->buffer = (char *)malloc(size * 4);*/
    /*  handle->lors_blocksize = size;
	}*/
    
    /*  Buffered I/O Stuff
	handle->fill_buffer = 1; */
 
    printf("ADIOI_LNIO_Open: calling lorsUpdateDepotPool\n");
    
    ret = lorsUpdateDepotPool(handle->ex, &handle->dp, 
			      handle->lbone_server, 0, 
			      NULL, handle->lors_threads, 
			      handle->lors_timeout, 0);
    
    if(ret != LORS_SUCCESS) {
      ADIOI_LNIO_Free_handle(handle);
      errno = EIO;
      return -1;
    }

    handle->dp->duration = handle->lors_duration;
    printf("ADIOI_LNIO_Open: successfully called lorsUpdateDepotPool\n");
  }

  fd->fs_ptr = (void *)handle;

  return 0;
}

int ADIOI_LNIO_Close(ADIO_File fd)
{
  int ret;
  struct lnio_handle_t *handle = (struct lnio_handle_t *)fd->fs_ptr;
  
  if (!handle) return -1;
  
  if (!(fd->access_mode & ADIO_RDONLY)) {
    ret = ADIOI_LNIO_Flush(fd); 
    if (ret == -1) {
      return -1;
    }
  }  
  
  lorsExnodeFree(handle->ex);
  if (handle->dp) lorsFreeDepotPool(handle->dp);
  
  /* handle DELETE_ON_CLOSE case - processed in ADIO_Close? */
  
  ADIOI_LNIO_Free_handle(handle);

  return 0;
}


off_t ADIOI_LNIO_Lseek(ADIO_File fd, off_t offset, int whence) 
{
  struct lnio_handle_t *handle = (struct lnio_handle_t *)fd->fs_ptr;

  if (!handle) return -1;
  
  printf("ADIOI_LNIO_Lseek: whence: %s, offset: %d\n", whence == SEEK_SET ? "SEEK_SET" : "not SEEK_SET", offset);

  switch (whence) {
  case SEEK_SET:
    handle->offset = offset;
    break;
  case SEEK_CUR:
    handle->offset += offset;
    break;
  case SEEK_END:
    handle->offset = handle->ex->logical_length + offset;
    break;
  default:
    errno = EINVAL;
    return -1;
  }

  return handle->offset;
}

ssize_t ADIOI_LNIO_Read(ADIO_File fd, void *buf, size_t count)
{
  struct lnio_handle_t *handle = (struct lnio_handle_t *)fd->fs_ptr;
  int ret;
  LorsSet *set;
  
  if (!handle) return -1;

  if(fd->access_mode & ADIO_WRONLY) {
    errno = EINVAL;
    return -1;
  }
  
  if (handle->offset < 0 || handle->offset >= handle->ex->logical_length) {
    return 0;
  }
  
  ret = lorsQuery(handle->ex, &set, handle->offset, count, 0); 
  if (ret != LORS_SUCCESS) {
    errno = EIO;
    return 0; /* not -1? */
  }
  
  if (jrb_empty(set->mapping_map)) {
    /* nothing in the set - data not written yet (not an error) */
    lorsSetFree(set, 0);
    handle->offset += count;
    bzero(buf, count);
    return count;
  }

  ret = lorsSetLoad(set, buf, handle->offset, count, handle->lors_blocksize,
		    NULL/*glob_lc*/, handle->lors_threads, handle->lors_timeout, 0);
  
  
  if (ret < 0) { /* error - if ret == -9, holes in the data */
    errno = EIO;
    return -1;
  }

  lorsSetFree(set, 0);
  handle->offset += count;

  return count;
}


int ADIOI_LNIO_lorsSetMappingVersion(LorsSet *set, int version) {
  LorsEnum list = NULL, it = NULL;
  LorsMapping *mp = NULL;
  ExnodeValue val;
  int ret;

  ret = lorsSetEnum (set, &list);
  if (ret != LORS_SUCCESS) {
    return ret;
  }
  while (1) { /* set the mapping version of each mapping */
    ret = lorsEnumNext(list, &it, &mp);
    if (ret == LORS_END) break;
    val.i = version;
    if (!mp->md) exnodeCreateMetadata(&mp->md);
    /* lorsGetMappingMetadata doesn't call exnodeCreateMetadata 
       when md is NULL. Should we report this? */
    exnodeSetMetadataValue(mp->md, "mapping_version", val, INTEGER, TRUE);
  } 
  lorsEnumFree(list);
  
  return LORS_SUCCESS;
}

ssize_t ADIOI_LNIO_Write(ADIO_File fd, const void *buf, size_t count) 
{
  struct lnio_handle_t *handle = (struct lnio_handle_t *)fd->fs_ptr;
  int ret;
  LorsSet *set, *newset;
  
#ifdef YING_LORS_DEBUG
  LorsSet *tmpSet;
  LorsEnum list = NULL, iter = NULL;
  int lret=0;
  struct ibp_timer timer;
  int nbytes = 0;
  char *tmpbuf=NULL;
#endif
  
  if (!handle || !buf) return -1;
  
  if (fd->access_mode == ADIO_RDONLY) {
    errno = EINVAL;
    return -1;
  }
  
  printf("ADIO_LNIO_Write: count %d, offset %d\n", count, handle->offset);

  /*  if(count > handle->lors_blocksize * handle->lors_threads) {
    count = handle->lors_blocksize * handle->lors_threads;
    }*/
  
  ret = lorsQuery(handle->ex, &set, handle->offset, count, LORS_QUERY_REMOVE);
  if(ret != LORS_SUCCESS) {
    errno = EINVAL;
    return -1;
  }
  
  if (jrb_empty(set->mapping_map)) {
    /* empty set */
    
    //ret = lorsSetInit(&set, hdl->end/hdl->lors_threads, 1, 0);
    ret = lorsSetInit(&set, handle->lors_blocksize, 1, 0);
    if(ret != LORS_SUCCESS) {
      errno = EIO;
      return -1;
    }
    
    ret = lorsSetStore(set, handle->dp, (char *)buf, 
		       handle->offset, count, NULL, 
		       handle->lors_threads, handle->lors_timeout, 
		       LORS_RETRY_UNTIL_TIMEOUT);
    
    if(ret != LORS_SUCCESS) {
      lorsSetFree(set, LORS_FREE_MAPPINGS);
      errno = EIO;
      return -1;
    }

  
    /* set the version of each new mapping to 1 */
    ret = ADIOI_LNIO_lorsSetMappingVersion(set, 1);
    if (ret != LORS_SUCCESS) {
      errno = EIO;
      return -1;
    }
  } else {
    set->copies = handle->lors_copies;
    set->data_blocksize= handle->lors_blocksize; 
    //count / handle->lors_threads; <- why did he do this? 
    
    /* basically repeating what lorsSetUpdate does */

    ret = lorsSetInit(&newset, handle->lors_blocksize, 1, 0);
    if (ret != LORS_SUCCESS) {
      errno = EIO;
      return -1;
    }
    
    ret = lorsSetStore(newset, handle->dp, (char *)buf, 
		       handle->offset, count, NULL, 
		       handle->lors_threads, 
		       handle->lors_timeout, 
		       LORS_RETRY_UNTIL_TIMEOUT);
  
    if (ret != LORS_SUCCESS) {
      lorsSetFree(newset, LORS_FREE_MAPPINGS);
      errno = EIO;
      return -1;
    }

    /* set the version of each new mapping to 1 
       (touched since the last sync) */
    ret = ADIOI_LNIO_lorsSetMappingVersion(newset, 1);
    if (ret != LORS_SUCCESS) {
      lorsSetFree(newset, LORS_FREE_MAPPINGS);
      errno = EIO;
      return -1;
    }

    ret = lorsSetTrim(set, handle->offset, count, handle->lors_threads,
		      handle->lors_timeout, LORS_RETRY_UNTIL_TIMEOUT | 
		      LORS_TRIM_ALL);
    if (ret != LORS_SUCCESS) {
      lorsSetFree(newset, LORS_FREE_MAPPINGS);
      errno = EIO;
      return -1;
    }
    
    ret = lorsSetMerge(newset, set);
    if (ret != LORS_SUCCESS) {
      lorsSetFree(newset, LORS_FREE_MAPPINGS);
      errno = EIO;
      return -1;
    }
    
    lorsSetFree(newset, 0);
  }
  
  ret = lorsAppendSet(handle->ex, set);
  if (ret != LORS_SUCCESS) {
    lorsSetFree(set, LORS_FREE_MAPPINGS);
    errno = EIO;
    return -1;
  }
  
  lorsSetFree(set, 0);
  
  /*updated by YING
    hdl->begin += hdl->b_pos;
    hdl->b_pos=0;
    hdl->end = 0;
    updated by YING*/

  handle->offset += count; 

  return count;
}

int ADIOI_LNIO_lorsSetAddUpdatedMappings(struct lnio_handle_t *handle, 
					 LorsSet *updates, LorsExnode *ex)
{
  LorsSet *set;
  LorsEnum list = NULL, it = NULL;
  LorsMapping *mp = NULL;
  ExnodeValue val;
  ExnodeType type;
  int ret;

  ret = lorsSetInit(&set, handle->lors_blocksize, 1, 0);
  if (ret != LORS_SUCCESS) return ret;

  ret = lorsQuery(ex, &set, 0, ex->logical_length, LORS_QUERY_REMOVE);
  if (ret != LORS_SUCCESS) return ret;
  
  ret = lorsSetEnum(set, &list);
  while (1) {
    ret = lorsEnumNext(list, &it, &mp);
    if (ret == LORS_END) break;
    if (mp->md) {
      exnodeGetMetadataValue(mp->md, "mapping_version", &val, &type);
      if (type == INTEGER && val.i == 1) {
	printf("ADIOI_LNIO_lorsSetAddUpdateMappings: there is a mapping added to updates, offset %Ld, length %d\n", mp->exnode_offset, mp->logical_length);
	val.i = 0;
	exnodeSetMetadataValue(mp->md, "mapping_version", val, INTEGER, TRUE);
      } else { /* remove mapping from the set - version # is 0 (intact) */ 
	ret = lorsSetRemoveMapping(set, mp);
	if (ret != LORS_SUCCESS) return ret;
      }
    } else { /* remove mapping from the set - no version # specified*/
      ret = lorsSetRemoveMapping(set, mp);
      if (ret != LORS_SUCCESS) return ret;
    } 
  }
  
  lorsEnumFree(list);

  ret = lorsSetMerge(set, updates);
  if (ret != LORS_SUCCESS) return ret;

  return LORS_SUCCESS;  
}


int ADIOI_LNIO_Flush(ADIO_File fd) 
{
  struct lnio_handle_t *handle = (struct lnio_handle_t *)fd->fs_ptr;
  int ret, rank, size, count, tempfd, length, i;
  char *buf;

  LorsExnode *new_ex, *temp_ex;
  LorsSet *updates, *new_ex_set;
  LorsEnum list = NULL, it = NULL;
  LorsMapping *mp = NULL;

  MPI_Request request;
  MPI_Status status;


  MPI_Comm_rank(fd->comm, &rank);
  MPI_Comm_size(fd->comm, &size);

  printf("[%d/%d] ADIOI_LNIO_Flush: entering\n", rank, size);

  if (!rank) {  /* master deserializes exnode from the file */
    /* first, create an exnode structure */
    ret = lorsExnodeCreate(&new_ex);
    if (ret != LORS_SUCCESS) {
      errno = EIO;
      return -1;
    }
    
    /* check if the file already exists */
    tempfd = open(fd->filename, O_RDONLY);
    if (tempfd != -1) {
      close(tempfd);
      /* if the file exists, deserialize it */
      ret = lorsFileDeserialize(&new_ex, fd->filename, NULL);
      if (ret != LORS_SUCCESS) {
	errno = EIO;
	return -1;
      }
    }
    /* add updated mappings from master's exnode to updates */
    
    ret = lorsSetInit(&updates, handle->lors_blocksize, 1, 0);
    if(ret != LORS_SUCCESS) {
      errno = EIO;
      return -1;
    }
    
    printf("[%d/%d] ADIOI_LNIO_Flush: calling ADIOI_LNIO_lorsSetAddUpdatedMappings for proc 0\n", rank, size);
    ADIOI_LNIO_lorsSetAddUpdatedMappings(handle, updates, handle->ex);  
  }

  
  if (rank) {  /* non-master */
    /* non-master procs serialize their exnodes and send it to master */
    ret = lorsSerialize(handle->ex, &buf, 0, &length);
    if (ret != LORS_SUCCESS) {
      errno = EIO;
      return -1;
    }
    MPI_Isend((void *)buf, length, MPI_CHAR, 0, rank, fd->comm, &request);
    free(buf);
  } else {  /* master */
    /* master gathers exnodes from non-master procs */
    for (i = 1; i < size; i++) {  /* there are size - 1 senders */
      
      MPI_Probe(MPI_ANY_SOURCE, MPI_ANY_TAG, fd->comm, &status);
      MPI_Get_count(&status, MPI_CHAR, &count);
      buf = (char *)calloc(count + 1, 1);
      printf("[%d/%d] ADIOI_LNIO_Flush: there's a message from proc %d, tag %d, size %d\n", rank, size, status.MPI_SOURCE, status.MPI_TAG, count);
      MPI_Recv(buf, count, MPI_CHAR, status.MPI_SOURCE, status.MPI_TAG, 
	       fd->comm, &status);
      
      ret = lorsExnodeCreate(&temp_ex);
      if (ret != LORS_SUCCESS) {
	errno = EIO;
	return -1;
      }
      
      ret = lorsDeserialize(&temp_ex, buf, count, NULL);
      if (ret != LORS_SUCCESS) {
	errno = EIO;
	return -1;
      }
      
      /* add updated mappings from received exnode to updates */
      printf("[%d/%d] ADIOI_LNIO_Flush: calling ADIOI_LNIO_lorsAddUpdatedMappings for proc %d\n", rank, size, i);
      ADIOI_LNIO_lorsSetAddUpdatedMappings(handle, updates, temp_ex);
      
      lorsExnodeFree(temp_ex);
      free(buf);
    }
  
    /* now master combine the mappings in updates with new_ex */
    /* first, creates a set of mappings from new_ex */
  
    ret = lorsSetInit(&new_ex_set, handle->lors_blocksize, 1, 0);
    if (ret != LORS_SUCCESS) return ret;
   
    ret = lorsQuery(new_ex, &new_ex_set, 0, new_ex->logical_length, 
		    LORS_QUERY_REMOVE);
    if (ret != LORS_SUCCESS) return ret;

    /* then trim each mapping in updates from new_ex_set 
     and add it back to new_ex_set */
    list = NULL; it = NULL; mp = NULL;
    
    ret = lorsSetEnum(updates, &list);
    if (ret != LORS_SUCCESS) return ret;
    
    while (1) {
      ret = lorsEnumNext(list, &it, &mp);
      if (ret == LORS_END) break;
      printf("[%d/%d] there is a mapping in updates, offset %Ld, length %d\n", rank, size, mp->exnode_offset, mp->logical_length);
      ret = lorsSetTrim(new_ex_set, mp->exnode_offset, mp->logical_length,
			handle->lors_threads, handle->lors_timeout, 
			LORS_RETRY_UNTIL_TIMEOUT | LORS_TRIM_ALL);	
      if (ret != LORS_SUCCESS) return ret;      
    }
    
    lorsEnumFree(list);
    
    ret = lorsSetMerge(updates, new_ex_set);
    if (ret != LORS_SUCCESS) return ret;

    ret = lorsAppendSet(new_ex, new_ex_set);
    if (ret != LORS_SUCCESS) return ret; 
    
    printf("new_ex logical_length: %d\n", new_ex->logical_length);
  }
  
  /* now, master serializes new_ex, broadcasts to other procs, and 
     writes to the xml file 
     non-masters receive new_ex and serialize it 
  */

  if (!rank) { /* master */
  /* assume that master is one of the aggregators or has an access to 
     the file system */

    ret = lorsFileSerialize(new_ex, fd->filename, 0, 0); 
    if (ret != LORS_SUCCESS) return ret;
    
    ret = lorsSerialize(new_ex, &buf, 0, &length);
    if (ret != LORS_SUCCESS) return ret;
  
    /* broadcast the serialized exnode to everybody */
    MPI_Bcast((void *)&length, 1, MPI_INT, 0, fd->comm);
    MPI_Bcast((void *)buf, length, MPI_CHAR, 0, fd->comm);
    
    lorsExnodeFree(handle->ex);
    handle->ex = new_ex;
  } else { /* non-master */
    MPI_Bcast((void *)&length, 1, MPI_INT, 0, fd->comm);
    buf = (char *)calloc(length + 1, 1);
    MPI_Bcast((void *)buf, length, MPI_CHAR, 0, fd->comm);
    
    lorsExnodeFree(handle->ex);
    ret = lorsExnodeCreate(&handle->ex);
    if (ret != LORS_SUCCESS) return ret;
    ret = lorsDeserialize(&handle->ex, buf, length, NULL);
    if (ret != LORS_SUCCESS) return ret;
  }
 
  if (buf) free(buf);
  return 0;
}






/*******************************/
/*    Buffered I/O Routines    */
/*******************************/
/*int ADIOI_LNIO_Buffered_close(ADIO_File fd)
{
  int ret;
  struct lnio_handle_t *handle = (struct lnio_handle_t *)fd->fs_ptr;

  if (!handle) return -1;

  if (!(fd->access_mode & ADIO_RDONLY)) {
    if (handle->dirty_buffer) {
      ADIOI_LN_Flush(handle);
    } else {
      ret = lorsFileSerialize(handle->ex, fd->filename, 0, 0);
      if (ret != LORS_SUCCESS) {
	return -1;
      }
    }
  }

  lorsExnodeFree(handle->ex);
  if (handle->dp) lorsFreeDepotPool(handle->dp);
  */
  /* handle DELETE_ON_CLOSE case - processed in ADIO_Close? */
/*
  return 0;
}


off_t ADIOI_LNIO_Buffered_lseek(ADIO_File fd, off_t offset, int whence) 
{
  struct lnio_handle_t *handle = (struct lnio_handle_t *)fd->fs_ptr;

  if (!handle) return -1;

  if (whence == SEEK_SET) {
    if (offset - handle->begin > handle->lors_blocksize * handle->lors_threads 
	|| offset < handle->begin) { 
  */    /* if offset points outside the current buffer */ 
/*   if (handle->dirty_buffer) {
	if (ADIOI_LNIO_Flush(fd)) {
	  errno = EIO;
	  return -1;
	}
      }
      
      handle->fill_buffer = 1; 
      handle->begin = offset;
      handle->b_pos = 0;
      handle->end = 0;
    } else {
      handle->b_pos = offset - handle->begin;
    }
  } else if (whence == SEEK_CUR) {
    if (handle->b_pos + offset > handle->lors_blocksize * hdl->lors_threads 
	|| handle->b_pos + offset < 0) {
********/    /* if offset points outside the current buffer */
/* if (handle->dirty_buffer) {
	if (ADIOI_LNIO_Flush(fd)) {
	  errno = EIO;
	  return -1;
	}
      }	
      
      handle->fill_buffer = 1;
      handle->begin = handle->begin + handle->b_pos + offset;
      handle->b_pos = 0;
      handle->end = 0;
    } else {
      handle->b_pos += offs;
    }
  } else if (whence == SEEK_END) {
    if(ADIOI_LNIO_Flush(fd)) {
      errno = EIO;
      return -1;
    }
    
    handle->fill_buffer = 1;
    handle->begin = handle->ex->logical_length + offs;
    handle->b_pos = 0;
  } else {
    errno = EINVAL;
    return -1;
  }

  return handle->begin + handle->b_pos;
}

ssize_t ADIOI_LNIO_Buffered_read(ADIO_File fd, void *buf, size_t count)
{
  struct lnio_handle_t *handle = (struct lnio_handle_t *)fd->fs_ptr;
  int ret;
  LorsSet *set;
  
  if (!handle) return -1;

  if(fd->access_mode & ADIOO_WRONLY) {
    errno = EINVAL;
    return -1;
  }
  
  if(handle->b_pos < handle->end && !handle->fill_buffer) {
    if(size > handle->end - handle->b_pos){
      size = handle->end - handle->b_pos; 
  */    /* get what the current buffer has */
/* }
    memcpy(buf, handle->buffer + handle->b_pos, size);
    handle->b_pos += size;
    return size;
  }

*/
  /* if handle->end==handle->b_pos, buffer may still has free space, 
     doesn't need to be released */
  /*if ((handle->end < handle->b_pos) || 
      (handle->b_pos == handle->lors_blocksize * handle->lors_threads)){ 
    if(handle->dirty_buffer){
      if(ADIOI_LNIO_Flush(fd)) {
	errno = EIO;
	return -1;
      }
    }
    handle->begin += handle->b_pos;
    handle->b_pos=0;
    handle->end = 0;
    handle->fill_buffer = 1;
  }
  
  if (handle->ex->logical_length <= handle->begin + handle->b_pos) {
  *//* exnode is shorter than required */
/* return 0;
  }
  
  if (size > handle->lors_blocksize * handle->lors_threads - handle->b_pos) 
    size = handle->lors_blocksize * hdl->lors_threads - handle->b_pos;
*/
  //handle->fill_buffer = 0;
/*
  ret = lorsQuery(handle->ex, &set, handle->begin + handle->b_pos, size, 0); 
  if (ret != LORS_SUCCESS) {
*/  /* size = 0 because LORSQUERY */
/*  errno = EIO;
    return 0;
  }
*/
  /* updated by YING */
  /*if (jrb_empty(set->mapping_map)) {
   *//* NOTHING in SET */
/*lorsSetFree(set, 0);
    if (handle->dirty_buffer) {
      if (ibp_flush(handle)) {
	errno = EIO;
	return -1;
      }
    }
    handle->end = size;
    handle->begin += handle->b_pos;
    handle->b_pos = size;
    bzero(buf, size);
    bzero(handle->buffer, size);
    handle->dirty_buffer = 1;
    handle->fill_buffer = 0;
    errno = 0;
    return size;
  }
*//* updated by YING */
  
  
  /*ret = lorsSetLoad(set, hdl->buffer+hdl->b_pos, hdl->begin + hdl->b_pos, 
		    size, hdl->lors_blocksize,
		    glob_lc, hdl->lors_threads, hdl->lors_timeout, 0);
  */
  
  /* updated by YING */	
  /*if ((ret < 0)&&(ret!=-9)) {
    fprintf(stderr,"IN IBP_READ, RETURN -1 due to LORSSETLOAD\n");
    errno = EIO;
    size = -1;
    goto out;
    }*/
  /* updated by YING */
  
  /* updated by YING */
  /*if (ret == -9){
    int lret;
    int curOffset=hdl->begin + hdl->b_pos;
    int leastOffset=-1;
#ifdef YING_LORS_DEBUG
    fprintf(stderr,"IN IBP_READ, ret is -9\n");
#endif
    LorsEnum  list = NULL, iter = NULL;
    lorsSetEnum(set, &list);
    do {
      LorsMapping        *lm = NULL;
      lret = lorsEnumNext(list, &iter, &lm);
      if (lm != NULL){ 
#ifdef YING_LORS_DEBUG
	fprintf(stderr,"Mapping in IBP_READ %d offset:%lld len:%ld %s:%4d\n",lm->id,lm->exnode_offset,lm->logical_length,lm->depot.host,lm->depot.port);
#endif
	if ((leastOffset == -1) || (lm->exnode_offset < leastOffset))
	  leastOffset = lm->exnode_offset;
      }
    }while ( lret != LORS_END ); 
    lorsEnumFree(list);
    lorsSetFree(set, 0);
    ret = leastOffset-curOffset;
    if(hdl->dirty_buffer){
#ifdef YING_LORS_DEBUG
      fprintf(stderr,"CALL IBP_FLUSH_READ3\n");
#endif
      if(ibp_flush(handle)) {
#ifdef YING_LORS_DEBUG
	fprintf(stderr,"IN IBP_READ, RETURN -1 due to IBP_FLUSH\n");
#endif
	errno = EIO;
	size = -1;
	goto out;
      }
    }
    hdl->end = ret;
    hdl->begin += hdl->b_pos;
    hdl->b_pos= ret;
    bzero(buffer,ret);
    bzero(hdl->buffer,ret);
    hdl->dirty_buffer = 1;
  *//* new added */
    /*hdl->dirty_buffer = 1;
    hdl->fill_buffer = 0;
    size = ret;
    errno = 0;
    goto out;
    }*/
  /* updated by YING */
  
  /* new added */
  /*hdl->fill_buffer = 0;
  
  lorsSetFree(set, 0);
  memcpy(buffer, hdl->buffer+hdl->b_pos, ret);
  hdl->end += ret;
  hdl->b_pos += ret;
#ifdef YING_LORS_DEBUG
  fprintf(stderr,"In IBP_READ DEBUG AFTER ,hdl->begin:%d, hdl->b_pos:%d, hdl->end:%d \n",hdl->begin, hdl->b_pos,hdl->end);
#endif
  size = ret;
  errno =0;
  return size;
  }*/
