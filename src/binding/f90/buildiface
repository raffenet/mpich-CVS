#! /usr/bin/perl
# binding.sub provides the routines for reading the prototype file
# and extracting the function definitions.
require "binding.sub";

$prototype_file = "../../include/mpi.h.in";

%mpi_routines = ();
%NeedConstants = ();   # constants needed for declaration, hased by routine

#
# parmc2f translates the C/C++ names to the Fortran 90 name.  %name% will
# be replaced with the argument name in declarations.
%parmc2f = ( 'int' => 'INTEGER',
	     'int[]' => 'INTEGER %name%(*)',
	     'int[][3]' => 'INTEGER %name%(3,*)',
	     'int*' => 'INTEGER',      # assume output scalar (see array
	                               # replacement below)
	     'bool' => 'LOGICAL',
	     'bool[]' => 'LOGICAL %name%(*)',
	     'MPI_Handler_function*' => 'EXTERNAL',
	     'MPI_Win_errhandler_fn*' => 'EXTERNAL',
	     'MPI_Comm_errhandler_fn*' => 'EXTERNAL',
	     'MPI_File_errhandler_fn*' => 'EXTERNAL',
	     'MPI_Comm_copy_attr_function*' => 'EXTERNAL',
	     'MPI_Comm_delete_attr_function*' => 'EXTERNAL',
	     'MPI_Type_copy_attr_function*' => 'EXTERNAL',
	     'MPI_Type_delete_attr_function*' => 'EXTERNAL',
	     'MPI_Win_copy_attr_function*' => 'EXTERNAL',
	     'MPI_Win_delete_attr_function*' => 'EXTERNAL',
	     'MPI_Copy_function*' => 'EXTERNAL',
	     'MPI_Delete_function*' => 'EXTERNAL',
	     'MPI_User_function*' => 'EXTERNAL',
	     'MPI_Grequest_query_function*' => 'EXTERNAL',
	     'MPI_Grequest_free_function*' => 'EXTERNAL',
	     'MPI_Grequest_cancel_function*' => 'EXTERNAL',
	     'MPI_Request' => 'INTEGER',
	     'MPI_Request*' => 'INTEGER',
	     'MPI_Request[]' => 'INTEGER %name%(*)',
	     'MPI_Datatype' => 'INTEGER',
	     'MPI_Datatype*' => 'INTEGER',
	     'MPI_Datatype[]' => 'INTEGER %name%(*)',
	     'MPI_Comm' => 'INTEGER',
	     'MPI_Comm*' => 'INTEGER', # Never an array of comm
	     'MPI_Group' => 'INTEGER',
	     'MPI_Group*' => 'INTEGER', # Never an array of groups
	     'MPI_Errhandler' => 'INTEGER',
	     'MPI_Errhandler*' => 'INTEGER', # Never an array of errhandlers
	     'MPI_Op' => 'INTEGER',
	     'MPI_Op*' => 'INTEGER', # Never an array of ops
	     'MPI_Status*' => 'INTEGER %name%(MPI_STATUS_SIZE)',
	     'MPI_Status[]' => 'INTEGER %name%(MPI_STATUS_SIZE,*)',
	     'MPI_Aint' => 'INTEGER(KIND=MPI_ADDRESS_KIND)',
	     'MPI_Aint*' => 'INTEGER(KIND=MPI_ADDRESS_KIND)',
	     'MPI_Aint[]' => 'INTEGER(KIND=MPI_ADDRESS_KIND) %name%(*)',
	     'MPI_Info' => 'INTEGER',
	     'MPI_Info*' => 'INTEGER', # Never an array of info
	     'MPI_Info[]' => 'INTEGER %name%(*)',
	     'char*' => 'CHARACTER (LEN=*)',
	     'char*[]' => 'CHARACTER (LEN=*) %name%(*)',
	     'char**[]' => 'CHARACTER (LEN=*) %name%(v0,*)',  #special case
				# form Comm_Spawn_multiple
	     'MPI_Win' => 'INTEGER',
	     'MPI_Win*' => 'INTEGER', # Never an array of win
	     'MPI_File' => 'INTEGER',
	     'MPI_File*' => 'INTEGER', # Never an array of files
	     );

# special_args provides for handling of arguments that require special
# features.  The keys are of the form 'Routine-count', with count the 
# position of the argument, starting from one.
%special_args = ( 'Testany-2' => 'MPI_Request[]',
		  'Startall-2' => 'MPI_Request[]',
		  'Testall-2' => 'MPI_Request[]',
		  'Testall-4' => 'MPI_Status[]',
		  'Testsome-2' => 'MPI_Request[]',
		  'Testsome-4' => 'int[]',
		  'Testsome-5' => 'MPI_Status[]',
		  'Type_hindexed-2' => 'int[]',
		  'Type_hindexed-3' => 'int[]',
		  'Type_indexed-2' => 'int[]',
		  'Type_indexed-3' => 'int[]',
		  'Type_struct-2' => 'int[]',
		  'Type_struct-3' => 'int[]',
		  'Type_struct-4' => 'MPI_Datatype[]',
		  'Waitall-2' => 'MPI_Request[]',
		  'Waitall-3' => 'MPI_Status[]',
		  'Waitany-2' => 'MPI_Request[]',
		  'Waitsome-2' => 'MPI_Request[]',
		  'Waitsome-4' => 'int[]',
		  'Waitsome-5' => 'MPI_Status[]',
		  'Group_excl-3' => 'int[]',
		  'Group_incl-3' => 'int[]',
		  'Group_translate_ranks-3' => 'int[]',
		  'Group_translate_ranks-5' => 'int[]',
		  'Cart_coords-4' => 'int[]',
		  'Cart_create-3' => 'int[]',
		  'Cart_create-4' => 'bool[]',
		  'Cart_get-3' => 'int[]',
		  'Cart_get-5' => 'int[]',
		  'Cart_get-4' => 'bool[]',
		  'Cart_map-3' => 'int[]',
		  'Cart_map-4' => 'bool[]',
		  'Cart_rank-2' => 'int[]',
		  'Cart_sub-2' => 'bool[]',
		  'Dims_create-3' => 'int[]',
		  'Graph_create-3' => 'int[]',
		  'Graph_create-4' => 'int[]',
		  'Graph_create-5' => 'bool',
		  'Graph_get-4' => 'int[]',
		  'Graph_get-5' => 'int[]',
		  'Graph_map-3' => 'int[]',
		  'Graph_map-4' => 'int[]',
		  'Graph_neighbors-4' => 'int[]',
		  'Iprobe-4' => 'bool',
		  'Test-2' => 'bool',
		  'Testall-3' => 'bool',
		  'Testany-4' => 'bool',
		  'Test_cancelled-2' => 'bool',
		  'Op_create-2' => 'bool',
		  'Attr_get-4' => 'bool',
		  'Comm_test_inter-2' => 'bool',
		  'Intercomm_merge-2' => 'bool',
		  'Cart_create-5' => 'bool',
		  'Initialized-1' => 'bool',		
		  'Group_range_excl-3' => 'int[][3]',
		  'Group_range_incl-3' => 'int[][3]',
		  'Info_get_valuelen-4' => 'bool',
		  'Is_thread_main-1' => 'bool',
		  'Type_create_subarray-2' => 'int[]',
		  'Type_create_subarray-3' => 'int[]',
		  'Type_create_subarray-4' => 'int[]',
		  'Request_get_status-2' => 'bool',
		  'Info_get-5' => 'bool',
		  'Type_create_indexed_block-3' => 'int[]',
		  'Type_create_darray-4' => 'int[]',
		  'Type_create_darray-5' => 'int[]',
		  'Type_create_darray-6' => 'int[]',
		  'Type_create_darray-7' => 'int[]',
		  'Type_create_struct-2' => 'int[]',
		  'Type_create_struct-3' => 'MPI_Aint[]',
		  'Win_test-2' => 'bool',
		  'Type_create_hindexed-2' => 'int[]',
		  'Type_create_hindexed-3' => 'MPI_Aint[]',
		);

# Some routines must be skipped (custom code is provided for them)
%skip_routines = ( 'Init' => 1, 'Init_thread' => 1, 'Status_c2f' => 1,
		   'Status_f2c' => 1, 'Pcontrol' => 1,
		   );
#
# Read the interface file (e.g., mpi.h.in) and file in the various 
# data structures (they're in global variables)
&ReadInterface( $prototype_file, "MPI_", "[A-Z][a-z_0-9]*", "mpi_routines" );

#
# For some MPI routines, we need to distinguish between arguments that are 
# input arrays versus ones that are output scalars.  For those functions,
# convert input (or output) arrays to [] format.  

# ----------------------------------------------------------------------------
#
# Generate the module for the routines
# First pass.  Ignore the issue of choice routines
# Print header
open (MPIFD, ">mpi.f90" ) || die "Could not open mpi.f90\n";

# Was 
#       USE MPI_CONSTANTS,                                               &
#     &      BASE_MPI_WTIME => MPI_WTIME, BASE_MPI_WTICK => MPI_WTICK
# but this caused problems with the pg compiler.  Need to understand and fix
print MPIFD "       MODULE MPI
!      This module was created by the script buildiface
       USE MPI_CONSTANTS
       USE MPI_BASE
       END MODULE MPI\n";
  
close (MPIFD);
# ----------------------------------------------------------------------------
# This is the file for the routines that have no "choice" arguments.
# An example of a choice argument is a "void *buf" input argument to 
# MPI_Send, which allows any buffer address, both numeric and character.
open ( MPIBASEFD, ">mpi_base.f90" ) || die "Could not open mpi_base.f90\n";
print MPIBASEFD "       MODULE MPI_BASE
       IMPLICIT NONE
!      This module was created by the script buildiface
       INTERFACE\n";

foreach $routine (keys(%mpi_routines)) {
    $ucname = uc($routine);
    $args   = $mpi_routines{$routine};
    @parms  = split(/,/, $args );

    # Check for a routine to skip
    if (defined($skip_routines{$routine})) {
	next;
    }

    # Check for a void * argument (usually choice)
    # As noted above, we don't include the routines with choice arguments
    # in the base module.
    if ($args =~ /void/) {
	$mpi_choice_routines{$routine} = $args;
	print "Skipping $routine because of void argument\n" if $debug;
	next;
    }
    print MPIBASEFD "       SUBROUTINE MPI_$ucname(";
    for ($i=0; $i<=$#parms; $i++) {
	print MPIBASEFD "v$i,";
    }
    print MPIBASEFD "ierror)\n";
    # Determine if we need any constants (e.g., MPI_STATUS_SIZE, 
    # MPI_OFFSET_KIND)
    %use_constants = ();
    $found_constants = 0;
    for ($i=0; $i<=$#parms; $i++) {
	$parm = $parms[$i];
	# Check for special args
	$loc = $i+1;
	if (defined($special_args{"$routine-$loc"})) {
	    $parm = $special_args{"$routine-$loc"};
	}
	# Map the C type to the Fortran type
	$cparm = $parm;
	$cparm =~ s/\s+//g;
	$fparm = $parmc2f{$cparm};
	# Now, does this type contain an MPI constant?
	if ($fparm =~ /(MPI_[A-Z_]*)/) {
	    $use_constants{$1} = 1;
	    $found_constants = 1;
	}
    }
    if ($found_constants) {
	print MPIBASEFD "       USE MPI_CONSTANTS,ONLY:";
	$sep = "";
	foreach $name (keys(%use_constants)) {
	    print MPIBASEFD "$sep$name";
	    $sep = ", ";
	    $NeedConstants{$routine} .= "$name ";
	}
	print MPIBASEFD "\n";
    }

    # Output argument types
    for ($i=0; $i<=$#parms; $i++) {
	$parm = $parms[$i];
	# Check for special args
	$loc = $i+1;
	if (defined($special_args{"$routine-$loc"})) {
	    $parm = $special_args{"$routine-$loc"};
	}
	# Map the C type to the Fortran type
	$cparm = $parm;
	$cparm =~ s/\s+//g;
	$fparm = $parmc2f{$cparm};
	if ($fparm eq "") {
	    print STDERR "$routine: No parm type for $cparm ($parm)\n";
	}
	if ($fparm =~ /%name%/) {
	    $fparm =~ s/%name%/v$i/;
	    print MPIBASEFD "       $fparm\n";
	}
	else {
	    print MPIBASEFD "       $fparm v$i\n";
	}
    }
    print MPIBASEFD "       INTEGER ierror\n";
    print MPIBASEFD "       END SUBROUTINE MPI_$ucname\n\n";
}

# Add special routines (e.g., the ones with unusual arguments)

print MPIBASEFD "
        SUBROUTINE MPI_INIT(ierror)
        INTEGER ierror
        END SUBROUTINE MPI_INIT

        SUBROUTINE MPI_INIT_THREAD(v0,v1,ierror)
        INTEGER v0, v1, ierror
        END SUBROUTINE MPI_INIT_THREAD

        FUNCTION MPI_WTIME()
            DOUBLE PRECISION MPI_WTIME
        END FUNCTION MPI_WTIME
!
        FUNCTION MPI_WTICK()
            DOUBLE PRECISION MPI_WTICK
        END FUNCTION MPI_WTICK
";

print MPIBASEFD "       END INTERFACE\n       END MODULE MPI_BASE\n";
close MPIBASEFD;

open ( MPIFD, ">mpi_constants.f90" ) || die "Cannot open mpi_constants.f90\n";
print MPIFD "        MODULE MPI_CONSTANTS
        IMPLICIT NONE
        INCLUDE 'mpif.h'
        END MODULE MPI_CONSTANTS\n";
close MPIFD;

#
# Generate the choice argument routines
# FIXME: This file is not quite right.  Also note that it is 
# *input* for yet another step, one that generates particular values 
# for the types of the choice arguments.  We should consider using 
# a different extension for this file, such as sed or in, so that 
# it is clearly not a ready-to-use Fortran 90 input file.
# In particular, it needs to be set up so that
#   <typesize>
#   <type>
#   <dims>
#   <type1>
#   <dims1>
# can all be substituted as necessary.  For example
#   <typesize> => 4
#   <type> => real
#   <dims> => (*)
#   <type1> => real
#   <dims1> => (*)
# For scalar arguments, <dims> should be empty.
# Finally, the module name needs to be distinct for each choice of
# <type>, <dims>, <type1>, and <dims1>
open( MPIFD, ">mpi_t1.f90" ) || die "Cannot open mpi_t1.f90\n";
print MPIFD "        MODULE MPI_t1_s
        IMPLICIT NONE
        PRIVATE\n";

# Generate the interface specs
foreach $routine (keys(%mpi_choice_routines)) {
    $ucname = uc($routine);

    print MPIFD "        PUBLIC :: MPI_$ucname\n";
    print MPIFD "        INTERFACE MPI_$ucname\n";
    print MPIFD "           MODULE PROCEDURE MPI_${ucname}_T\n";
    print MPIFD "        END INTERFACE MPI_$ucname\n\n";
}

# Add sizeof
print MPIFD "        PUBLIC :: MPI_SIZEOF\n";
print MPIFD "        INTERFACE MPI_SIZEOF\n";
print MPIFD "          MODULE PROCEDURE MPI_SIZEOF_T\n";
print MPIFD "        END INTERFACE ! MPI_SIZEOF\n\n";

print MPIFD "        CONTAINS\n\n";

# For each choice routine, add the modules
foreach $routine (keys(%mpi_choice_routines)) {
    $ucname = uc($routine);
    $args   = $mpi_routines{$routine};
    @parms  = split(/,/, $args );

    print MPIFD "        SUBROUTINE MPI_${ucname}_T(";
    for ($i=0; $i<=$#parms; $i++) {
	print MPIFD "v$i,";
    }
    print MPIFD "ierror)\n";

    if (defined($NeedConstants{$routine})) {
	print MPIFD "       USE MPI_CONSTANTS,ONLY:";
	$sep = "";
	foreach $name (split(/\s+/,$NeedConstants{$routine})) {
	    print MPIFD "$sep$name";
	    $sep = ", ";
	}
	print MPIFD "\n";
    }

    # print the arg decls ...
    # convert %type% to the various types and %dims% to the dimensions,
    # including scalar.
    $nchoice = 0;
    for ($i=0; $i<=$#parms; $i++) {
	$parm = $parms[$i];
	# Check for special args
	$loc = $i+1;
	if (defined($special_args{"$routine-$loc"})) {
	    $parm = $special_args{"$routine-$loc"};
	}

	if ($parm =~ /void/) {
	    # An alternative to this is to have a separate file for
	    # routines with 2 choice arguments
	    if ($nchoice == 0) {
		print MPIFD "        <type> v$i<dims>\n";
	    }
	    else {
		print MPIFD "        <type$nchoice> v$i<dims$nchoice>\n";
	    }
	    $nchoice ++;
	}
	else {
	    # Map the C type to the Fortran type
	    $cparm = $parm;
	    $cparm =~ s/\s+//g;
	    $fparm = $parmc2f{$cparm};
	    if ($fparm eq "") {
		print STDERR "$routine: No parm type for $cparm ($parm)\n";
	    }
	    if ($fparm =~ /%name%/) {
		$fparm =~ s/%name%/v$i/;
		print MPIFD "        $fparm\n";
	    }
	    else {
		print MPIFD "        $fparm v$i\n";
	    }
	}
    }
    print MPIFD "        INTEGER ierror\n";
    print MPIFD "        EXTERNAL MPI_${ucname}\n";
    print MPIFD "        CALL MPI_${ucname}(";
    for ($i=0; $i<=$#parms; $i++) {
	print MPIFD "v$i,";
    }
    print MPIFD "ierror)\n";
    print MPIFD "        END SUBROUTINE MPI_${ucname}_T\n\n";
}

# Add sizeof
print MPIFD "\
        SUBROUTINE MPI_SIZEOF_T( X, SIZE, IERROR )\
        <type> X\
        INTEGER SIZE, IERROR\
        IERROR = 0\
        SIZE = <typesize>\
        END SUBROUTINE MPI_SIZEOF_T\
";
print MPIFD "\n";

print MPIFD "        END MODULE MPI_t1_s\n";
close MPIFD;

# -----------------------------------------------------------------------------
# This block can be used to create the Makefile
open ( MAKEFD, ">Makefile.sm" ) || die "Cannot create Makefile.sm";
print MAKEFD "# DO NOT EDIT\n# This file created by buildiface $arg_string\n";

print MAKEFD "smvar_do_dependencies = ignore\n";
#print MAKEFD "smvar_debug=1\n";
print MAKEFD "MOD = \@F90MODEXT\@\n";
print MAKEFD "F90INCFLAG = \@F90INCFLAG\@\n";
print MAKEFD "F90_COMPILE_MODS = \$(F90_COMPILE) \$(F90INCFLAG)../f77\n";

print MAKEFD "mpi_sources = create_f90_int.c create_f90_real.c \\\
	create_f90_complex.c create_f90_util.c\n";

# Add the C versions to the C library
print MAKEFD "lib\${MPILIBNAME}_a_SOURCES = \${mpi_sources} \
profilelib_\${MPILIBNAME} = p\${MPILIBNAME}\
INCLUDES = -I../../include -I\${master_top_srcdir}/src/include\n";

print MAKEFD "all-preamble: mpi.\$(MOD)\n";

print MAKEFD "mpi_constants.\$(MOD): \$(srcdir)/mpi_constants.f90\
\t\$(F90_COMPILE_MODS) -c \$(srcdir)/mpi_constants.f90\n";

print MAKEFD "mpi_base.\$(MOD): \$(srcdir)/mpi_base.f90\
\t\$(F90_COMPILE_MODS)  -c \$(srcdir)/mpi_base.f90\n";

print MAKEFD "# Thes copy line in this step makes the F90 modules available to \n";
print MAKEFD "# the mpif90 script before an install takes place\n";
print MAKEFD "mpi.\$(MOD): \$(srcdir)/mpi.f90 mpi_constants.\$(MOD) mpi_base.\$(MOD)\
\t\$(F90_COMPILE_MODS) -c \$(srcdir)/mpi.f90\n";
print MAKEFD "\tcp mpi.\$(MOD) mpi_constants.\$(MOD) mpi_base.\$(MOD) ../../../src/include\n";
#
# Some versions of the Intel f90 compiler require special files that 
# describe which modules to load.
print MAKEFD "\t\@if [ -n \"\@F90_WORK_FILES_ARG\@\" ] ; then \\\
\t    cp work.pc ../../../src/include/mpimod.pc ; \\\
\t    echo \"mpimod.pc\" > mpimod.pcl ; \\\
\t    echo \"\${includedir}/mpimod.pc\" >> mpimod.pcl ;\\\
\t    cp mpimod.pcl ../../../src/include/mpimod.pcl ; \\\
\tfi\n";

print MAKEFD "clean-local:\n";
print MAKEFD "\trm -f *.\$(MOD)\n";

print MAKEFD "maint-clean:\
\trm -f \${mpi_sources} fproto.h\n";

print MAKEFD "install_BIN     = mpif90\n";
print MAKEFD "install_ETC     = mpif90.conf\n";
print MAKEFD "install_INCLUDE = mpi.\$(MOD) mpi_constants.\$(MOD) mpi_base.\$(MOD)\n";
print MAKEFD "optinstall_INCLUDE = mpimod.pcl mpimod.pc\n";

    # Add the documentation
    print MAKEFD "# Documentation sources
doc_sources = mpif90.txt
DOCDESTDIRS = html:www/www1,man:man/man1,latex:doc/refman
doc_HTML_SOURCES  = \${doc_sources}
doc_MAN_SOURCES   = \${doc_sources}
doc_LATEX_SOURCES = \${doc_sources}
";

# ----------------------------------------------------------------------------
# FIXME: Add the steps to handle the choice arguments.  They should be
# selected by configure from a list of possible choices, with an 
# enable switch used to bypass the checks.  In addition, we need a way to 
# dynamically create subsets, given a list of routines and types/dimensions 
# to include.  This allows users to build precisely tailored F90 modules.
# ----------------------------------------------------------------------------

# Since configure copies mpif90 to the bin dir, we need to remove it
# in a distclean step.
print MAKEFD "distclean-local:\n";
print MAKEFD "\trm -f ../../../bin/mpif90\n";
print MAKEFD "\trm -f ../../../src/include/mpi.\$(MOD)\n";
print MAKEFD "\trm -f ../../../src/include/mpi_base.\$(MOD)\n";
print MAKEFD "\trm -f ../../../src/include/mpi_constants.\$(MOD)\n";


close( MAKEFD );

#
# Still to do
# make sure that we fit within the Fortran line length rules
# Look into alternatives for generating a zillion files
# Handle routines with more than one choice argument
#
# ------------------------------------------------------------------------
# Procedures
# print_line( FD, line, count, continue, continuelen )
# Print line to FD; if line size > count, output continue string and
# continue.  Use print_endline to finish a line
sub print_line {
    my $FD = $_[0];
    my $line = $_[1];
    my $count = $_[2];
    my $continue = $_[3];
    my $continue_len = $_[4];
    
    $linelen = length( $line );
    #print "linelen = $linelen, print_line_len = $print_line_len\n";
    if ($print_line_len + $linelen > $count) {
	print $FD $continue;
	$print_line_len = $continue_len;
    }
    print $FD $line;
    $print_line_len += $linelen;
}
sub print_endline {
    my $FD = $_[0];
    print $FD "\n";
    $print_line_len = 0;
}
