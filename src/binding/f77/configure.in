dnl
dnl This has been derived from the MPICH-1 configure for the Fortran
dnl binding.  It still needs major editing.
dnl
AC_INIT(Makefile.in)
use_alias_types=no
dnl
dnl Cygwin uses PREREQ to decide which autoconf/autoheader to run.  
dnl It does not do this correctly, since it compares against 2.13 but
dnl needs to compare agains 2.57 (as of July 30, 2003).  
dnl AC _PREREQ(2.13) 
dnl needed for SHELL, added in 2.13
rm -f ${srcdir}/mpi_fortconf.h mpi_fortconf.h
AC_CONFIG_HEADER(mpi_fortconf.h)
dnl We need install.sh, config.guess, etc. for the code that
dnl finds the Fortran libraries
AC_CONFIG_AUX_DIR(../../../confdb)
dnl
dnl Allow device to supply a mpid_fortdefs.h header file
dnl
dnl To enable this feature, the device setup script must set the environment
dnl variable HAVE_MPID_FORTDEFS_H and copy mpid_fortdefs.h to mpich/include
dnl and mpich2/src/binding/f77.  The device is also responsible for
dnl installing the header file.
dnl
if test -z "$HAVE_MPID_FORTDEFS_H" ; then
    HAVE_MPID_FORTDEFS_H=0
fi
AC_SUBST(HAVE_MPID_FORTDEFS_H)

PAC_ARG_CACHING

AC_ARG_ENABLE(strict,
[--enable-strict  - Turn on strict compilation testing when using gcc],,
enable_strict=no)

AC_ARG_ENABLE(echo,
[--enable-echo    - Turn on echoing from within the configure script],
set -x)

AC_ARG_ENABLE(weak-symbols,
[--enable-weak-symbols - Use weak symbols to provide the profiling interface
    (default)],
enable_weak=$enableval,enable_weak="yes")

AC_ARG_ENABLE(f90,
[--enable-f90 - Find and use a Fortran 90 compiler (default:enable)],
enable_f90=$enableval,enable_f90="yes")

AC_ARG_ENABLE(f90modules,
[--enable-f90modules - Build an MPI module for use with Fortran 90],
do_f90_modules=$enableval,do_f90_modules="yes")

AC_ARG_ENABLE(use-pointer,
[--enable-use-pointer - Use the common pointer extension for MPI_BOTTOM and
    related special values],
    use_pointer_in_f77=$enableval,use_pointer_in_f77="no")
dnl Change the default to yes soon

AC_ARG_ENABLE(runtimevalues,
[--enable-runtimevalues - Determine various parameters of the Fortran 
                         environment at run time, such as the values for
                         .TRUE. and .FALSE. .  This allows a single MPICH
                         library to be used with multiple Fortran compilers],
use_runtimevalues=$enableval,use_rutimevalues=false)
dnl
dnl
dnl The default is the usual MPICH library
AC_ARG_WITH(flibname,
[--with-flibname=name  - Specify name of library containing Fortran interface
routines],[FLIBNAME=$withval;set_FLIBNAME="yes"],FLIBNAME=mpich)
AC_SUBST(FLIBNAME)

dnl
dnl The default is a special wrapper library
AC_ARG_WITH(fwrapname,
[--with-fwrapname=name  - Specify name of library containing Fortran interface
routines],[FWRAPNAME=$withval;set_FWRAPNAME="yes"],FWRAPNAME=fmpich)
AC_SUBST(FWRAPNAME)

AC_ARG_WITH(cross,
[--with-cross=file - Specify the values of variables that configure cannot
determine in a cross-compilation environment],,with_cross=no)
dnl [--with-cross=file - Use the file for cross compilation.  The file should 
dnl             contain assignments of the form
dnl             CROSS_SIZEOF_INT=4
dnl              for each cross compilation variable.  The command
dnl                 egrep 'CROSS_[A-Z_]*=' configure | sed 's/=.*//g'
dnl              will list each variable],

AC_ARG_WITH(mpichconfig,
[--with-mpichconfig=file - Use file for the MPICH configuration.
              Normally, this file is mpichlib.conf, but other files
              may be used.],
[if test -z "$withval" -o "X$withval" = "Xyes" ; then 
    mpichconfig_file=../../util/mpichlib.conf
else 
    mpichconfig_file=$withval
fi
],mpichconfig_file="")

AC_ARG_WITH(subname,
[--with-subname=name - Use this name for forming the names of the 
              directories to install the mpif.h include file and 
              libraries, as well as the mpif77-name.conf file.  This
              should be used to support multiple Fortran compilers with
              a single MPICH build.  It must be used in conjunction with
              --with-mpichconfig],
subname=$withval,subname="")

dnl
dnl First check that we have a clean build if we are doing a VPATH build
if test "`cd $srcdir && pwd`" != "`pwd`" && test -f $srcdir/config.status ; then
    AC_MSG_ERROR([You cannot do a VPATH build if the source directory has been
    configured.  Run "make distclean" in $srcdir first.])
fi

#
# Get the "master" top srcdir if we are a subdir configure
if test -z "$top_srcdir" ; then
   use_top_srcdir=$srcdir   
else
   use_top_srcdir=$top_srcdir
fi
if test -z "$master_top_srcdir" ; then 
    master_top_srcdir=$use_top_srcdir
fi
AC_SUBST(master_top_srcdir)
export master_top_srcdir
#
# Get the master builddir (which may be imported from above)
if test -z "$master_top_builddir" ; then
    master_top_builddir=`pwd`
fi
export master_top_builddir
AC_SUBST(master_top_builddir)

if test "$with_cross" != "no" ; then
    if test -s "$with_cross" ; then
        AC_MSG_RESULT([Reading values from cross-compilation file $with_cross])
        . $with_cross
    fi
    # with_cross may have been passed down from above (in a calling configure)
    # so set the cross-compilation options independent of whether the
    # file exists.
    # Autoconf 2.52 no longer sets cross_compiling except with the
    # awkward "targethost" options.
    pac_cross_compiling=yes
    cross_compiling=yes
    ac_cv_prog_cc_cross=yes
    ac_cv_prog_f77_cross=yes
    ac_cv_prog_cxx_cross=yes
    export cross_compiling
fi

if test "$use_runtimevalues" = "yes" ; then
    AC_DEFINE(F77_RUNTIME_VALUES,1,[Define if Fortran environment should be determined at runtime])
fi

if test -n "$subname" -a -z "$mpichconfig_file" ; then
    AC_MSG_ERROR([Must specify --with-mpichconfig with --with-subname])
fi

# Read any cross-compilation variable values
if test "$cross_file" != "/dev/null" -a -s "$cross_file" ; then
    . $cross_file
fi

if test -n "$mpichconfig_file" -a -s "$mpichconfig_file" ; then
    . $mpichconfig_file
    pac_lib_mpi_is_building="yes"
fi


#
# Define the installation directory names (defaults)
if test -n "$subname" ; then
    # add the leading hyphen
    subname="-$subname"
    f77includedir='${includedir}'"/${subname}"
    f77libdir='${libdir}'
    f77bindir='${bindir}'
    if test "$set_FLIBNAME" != "yes" ; then
	FLIBNAME="mpich$subname"
    fi
    if test "$set_FWRAPNAME" != "yes" ; then
	FWRAPNAME="fmpich$subname"
    fi
else
    subname="-`echo $F77 | sed 's/ /-/g'`"
    # Don't include the (sub)name in the defaults
    f77includedir='${includedir}'
    f77libdir='${libdir}'
    f77bindir='${bindir}'
fi
AC_SUBST(f77includedir)
AC_SUBST(f77libdir)
AC_SUBST(f77bindir)
AC_SUBST(subname)

AC_SUBST(INCLUDES)
    # We should replace mpicc with the values used in the MPICH build.
    # This is best done with an environment variable (? what about 
    # config.status re-execution?)
    INCLUDES="$mpich_includes"
    if test "$hasMPE" = "unknown" ; then
	hasMPE="yes"
    fi
    AC_SUBST(MPIVERSION)

PAC_PROG_CC
dnl Set CFLAGS for enable strict if necessary
PAC_CC_STRICT
AC_C_CONST
# Check on support for long double and long long types.
AC_CACHE_CHECK([whether long double is supported],
pac_cv_have_long_double,[
AC_TRY_COMPILE(,[long double a;],
pac_cv_have_long_double=yes,pac_cv_have_long_double=no)])
if test "$pac_cv_have_long_double" = "yes" ; then
    AC_DEFINE(HAVE_LONG_DOUBLE,1,[Define if long double is supported])
fi
AC_CACHE_CHECK([whether long long is supported],
pac_cv_have_long_long,[
AC_TRY_COMPILE(,[long double a;],
pac_cv_have_long_long=yes,pac_cv_have_long_long=no)])
if test "$pac_cv_have_long_long" = "yes" ; then
    AC_DEFINE(HAVE_LONG_LONG_INT,1,[Define if long long is supported])
fi
dnl
dnl Autoconf bug: AC_PROG_F77 sets FFLAGS 
dnl Autoconf "feature" AC_PROG_F77 prefers g77 to f77.
# Allow FC as a synonym for F77, but only if F77 is not set.
if test -n "$FC" -a -z "$F77" ; then 
    F77="$FC"
fi
save_FFLAGS="$FFLAGS"
AC_PROG_F77
FFLAGS="$save_FFLAGS"
# Bug in autoconf.  Restore cross settings
if test "$pac_cross_compiling" = "yes" -a "$ac_cv_prog_f77_cross" = "no" ; then
    AC_MSG_RESULT([Resetting cross compilation to yes])
    cross_compiling=yes
    ac_cv_prog_cc_cross=yes
    ac_cv_prog_f77_cross=yes
    ac_cv_prog_f90_cross=yes
    ac_cv_prog_cxx_cross=yes
fi

AC_SUBST(FOPTIONS)
if test -z "$FLINKER" ; then
   FLINKER="$F77"
fi
AC_SUBST(FLINKER)
# We need F90 to get the OFFSET_KIND and ADDRESS_KIND values.
if test "$enable_f90" != "no" ; then
    PAC_PROG_F90
    if test -z "$F90" ; then
        enable_f90=no
    else
        if test -z "$F90LINKER" ; then
            F90LINKER="$F90"
        fi
    fi
    AC_SUBST(F90LINKER)
fi
dnl
dnl Checks for programs
PAC_PROG_MAKE

AC_PATH_PROG(AR,ar)
AC_PROG_INSTALL
PAC_PROG_MKDIR_P
# Note that we set RANLIB to true if we don't find it (some systems neither
# need it nor provide it)
AC_CHECK_PROGS(RANLIB,ranlib,true)
AC_SUBST(RANLIB)
# allow for a different linker for Fortran programs
AC_SUBST(F77LINKER)
if test -z "$F77LINKER" ; then
    F77LINKER="$F77"
fi

AC_SUBST(MPILIBNAME)
#
# The following variables are used in mpif77.in and reflect the MPI
# implementation that is in use.
# 
# Here are the commands to substitute the compilers to be used to create
# shared libraries.  The choices for the first two come down from the
# top-level configure.  FC_SHL must be determined in this configure
AC_SUBST(CC_SHL)
AC_SUBST(ENABLE_SHLIB)
AC_SUBST(FC_SHL)
AC_SUBST(FC_LINKPATH_SHL)
if test "$ENABLE_SHLIB" = "gcc" ; then
   # Assume that the compiler is g77 if gcc style shared libraries chosen
   FC_SHL="$FC -shared -fpic"
   FC_LINKPATH_SHL="-Wl,-rpath -Wl,"
fi
AC_SUBST(LIBTOOL)

if test "$pac_lib_mpi_is_building" = "yes" ; then
    # These values are EXPORTED by the MPICH configure
    # Alternately, if we are building a *new* Fortran library for a
    # pre-existing MPICH build, we need to get these variables from
    # the MPICH library configuration file.
    AC_SUBST(LIB_PATH)
    AC_SUBST(BASE_LIB_LIST)
    AC_SUBST(HASMPE)
    F77_LDFLAGS="$ROMIO_LFLAGS"
    AC_SUBST(F77_LDFLAGS)
    BASE_FFLAGS="$ROMIO_TFFLAGS"
    AC_SUBST(BASE_FFLAGS)
    AC_SUBST(includebuild_dir)
    AC_SUBST(MPI_WITH_PMPI)
    # Shared library support (replace with libtool?)
    AC_SUBST(SHAREDKIND)
    AC_SUBST(SHARED_LIB_SEARCH_PATH_LEADER)
    AC_SUBST(SHARED_LIB_LOCALDIR)
    AC_SUBST(sharedlibbuild_dir)
    AC_SUBST(sharedlib_dir)
    MPI2_OBJECTS='${MPI2_OBJECTS}'
    AC_SUBST(MPI2_OBJECTS)
fi
if test "$DEBUG_DUMP" = "yes" ; then
    rm -f config.env
    echo "Environment before push" >>config.env
    set >>config.env
    echo "End of env" >> config.env
fi
PAC_LANG_PUSH_COMPILERS
if test "$DEBUG_DUMP" = "yes" ; then
    echo "Environment after push" >>config.env
    set >>config.env
    echo "End of env" >> config.env
fi
dnl
dnl Historical note:
dnl If using the nag Fortran compilers, you may need -lg2c.
dnl The reason is that when it is included, codes fail in exit.  The
dnl problem was tracked down to the fact that the nag fortran routines
dnl do not initialize the argument values in the way that g2c expects.
dnl So, g2c is discovered, but it will not work.
dnl 
dnl
dnl This option requires the config.guess etc.
#
# Tru64 Unix (at least V5.0) implements neither the RANDOM variable nor the
# mktemp function.  This will cause config.guess to fail.  To workaround this,
# we define RANDOM using date if it is not defined
# Grr.  This doesn't work because configure execute config.guess in 
# a separate shell, using sh .  The only fix is to specify a -host 
# when running configure.  Sigh.
#if test -z "$RANDOM" ; then
#    RANDOM=`date '+%H%M%S'`
#    export RANDOM
#fi
FLIBS_save="$FLIBS"
FLIBS=""
AC_F77_LIBRARY_LDFLAGS
PAC_PROG_F77_CHECK_FLIBS
dnl
PAC_PROG_F77_LINKER_WITH_C
dnl For name mangle, we need the library flags
PAC_PROG_F77_NAME_MANGLE
dnl
# Warn about mixed name mangling, since many of the tests will fail
if test "$pac_cv_prog_f77_name_mangle" = "mixed" ; then
    AC_MSG_WARN([The compiler $F77 uses mixed case names.  Fortran is monocase
and many Fortran programs may use either upper or lower case names for MPI
calls.  Consider specifying a particular parameter to your Fortran compiler
to select either upper or lower case names.  For the Absoft compiler, 
-f selects lower case and -N109 selects upper case.  Specify new command
line options by setting the environment variable F77 to include
the options (e.g., setenv F77 \"f77 -f\")])
fi

dnl Once we have name mangle, we can try to limit the number of needed libs
PAC_PROG_F77_IN_C_LIBS
AC_SUBST(F77_IN_C_LIBS)

#
# Eventually, we should include a test for proper handling of characters.
# The Absoft compiler may require -N90 

AC_LANG_FORTRAN77
PAC_PROG_F77_EXCLAIM_COMMENTS(has_exclaim="yes",has_exclaim="no")
PAC_PROG_F77_NEW_CHAR_DECL(CHARDECL="(LEN=*)",CHARDECL="*(*)")
AC_SUBST(CHARDECL)
dnl PAC_F77_CHECK_COMPILER_OPTION(-g)
PAC_PROG_F77_HAS_INCDIR(include)
if test -n "$F77_INCDIR" ; then
    # For building the Fortran files, add the directory where we are building 
    # the object to the include list.  This is needed for g77, which makes
    # includes relative to the source directory of the file, not the 
    # directory that the command is executed in
    FINCLUDES="$F77_INCDIR`pwd`/src"
fi
AC_SUBST(FINCLUDES)
#
PAC_PROG_F77_LIBRARY_DIR_FLAG

AC_SUBST(MPIFPMPI)
if test "$MPI_WITH_PMPI" = "no" ; then
    # If the PMPI routines are not in the same library with the MPI
    # routines, we may need to remove the pmpi declarations
    PAC_PROG_F77_ALLOWS_UNUSED_EXTERNALS([MPIFPMPI=",PMPI_WTIME,PMPI_WTICK"],[
    MPIFPMPI=""; 
    AC_MSG_WARN([Removed PMPI_WTIME and PMPI_WTICK from mpif.h])])
else
    MPIFPMPI=",PMPI_WTIME,PMPI_WTICK"
fi
dnl If Fortran has a pointer extension, we can create a null pointer 
dnl instead of using the hack of checking for a specific address.
PAC_PROG_F77_HAS_POINTER(f77_has_pointer=yes,f77_has_pointer=no)
rm -f mpif_bottom.h
if test "$f77_has_pointer" = "yes" -a "$use_pointer_in_f77" = "yes" ; then
    cat >>mpif_bottom.h <<EOF
C
C     (C) 2001 by Argonne National Laboratory.\n";
C     See COPYRIGHT in top-level directory.\n";
C
C     DO NOT EDIT";
C     This file created by buildiface $arg_string\n";
C
        pointer (MPI_BOTTOM_PTR,MPI_BOTTOM)
	pointer (MPI_STATUS_IG_PTR,MPI_STATUS_IGNORE)
	pointer (MPI_STATUSES_IG_PTR,MPI_STATUSES_IGNORE)
        data MPI_BOTTOM_PTR/0/, MPI_STATUS_IG_PTR/0/
	data MPI_STATUSES_IG_PTR/0/
EOF
    AC_DEFINE(USE_POINTER_FOR_BOTTOM,1,[Define if we want to use nonstandard Fortran Pointer feature])
    dnl Note that with this, we do not need the call to mpir_init_fcm
    dnl in initfcmn.f .
else
    cat >>mpif_bottom.h <<EOF
C
C     (C) 2001 by Argonne National Laboratory.\n";
C     See COPYRIGHT in top-level directory.\n";
C
C     DO NOT EDIT";
C     This file created by buildiface $arg_string\n";
C
      COMMON /MPIPRIV/ MPI_BOTTOM,MPI_STATUS_IGNORE,MPI_STATUSES_IGNORE      
C
C     Without this save, some Fortran implementations may make the common
C     dynamic!
C    
C     For a Fortran90 module, we might replace /MPIPRIV/ with a simple
C     SAVE MPI_BOTTOM
C
      SAVE /MPIPRIV/
EOF
fi

dnl Up to size checking code in master configure.in (where it tries to 
dnl find the matching C sizes) as part of defining mpi_integer8 etc.
dnl The results are available in pac_cv_sizeof_f77_<type>
dnl Size is 0 if unknown or unavailable (or cross-compiling)
dnl Due to limitations in autoconf, we cannot put these into a loop.
dnl We also check integer to find the type of MPI_Fint
dnl
dnl Cross-compilation results can be included with the --with-cross=file
dnl option.
CROSS_F77_SIZEOF_INTEGER=${CROSS_F77_SIZEOF_INTEGER:-0}
CROSS_F77_SIZEOF_REAL=${CROSS_F77_SIZEOF_REAL:-0}
CROSS_F77_SIZEOF_DOUBLE_PRECISION=${CROSS_F77_SIZEOF_DOUBLE_PRECISION:-0}
PAC_PROG_F77_CHECK_SIZEOF_EXT(integer,$CROSS_F77_SIZEOF_INTEGER)
PAC_PROG_F77_CHECK_SIZEOF_EXT(real,$CROSS_F77_SIZEOF_REAL)
PAC_PROG_F77_CHECK_SIZEOF_EXT(double precision,$CROSS_F77_SIZEOF_DOUBLE_PRECISION)
# If we have sizes for real and double, we do not need to call mpir_get_fsize
# at run time.
#
AC_TRY_COMPILE(,[      integer*1 i],has_integer_1=1,has_integer_1=0)
AC_TRY_COMPILE(,[      integer*2 i],has_integer_2=2,has_integer_2=0)
AC_TRY_COMPILE(,[      integer*4 i],has_integer_4=4,has_integer_4=0)
AC_TRY_COMPILE(,[      integer*8 i],has_integer_8=8,has_integer_8=0)
AC_TRY_COMPILE(,[      integer*16 i],has_integer_16=16,has_integer_16=0)
AC_TRY_COMPILE(,[      real*4 a],has_real_4=4,has_real_4=0)
AC_TRY_COMPILE(,[      real*8 a],has_real_8=8,has_real_8=0)
AC_TRY_COMPILE(,[      real*16 a],has_real_16=16,has_real_16=0)

# Create the default datatype names for the standard MPI Fortran types
MPI_CHARACTER=0x4c000118
AC_SUBST(MPI_CHARACTER)

len_integer=$pac_cv_f77_sizeof_integer
# Convert to two digit hex
len=$len_integer
#
# Take len and turn it into two hex digits (there are 8 bits available
# in the built-in datatype handle for the length; see
# src/mpid/common/datatype/mpid_datatype.h).  This code is taken
# from the code in mpich2/configure.in 
if test "$len" -gt 255 ; then
     AC_MSG_ERROR([Type sizes greater than 255 bytes not supported (type INTEGER is $len bytes)]) 
fi
tmplen=$len
hexlen=""
while test $tmplen -gt 0 ; do
    lowdigit=`expr $tmplen - 16 \* \( $tmplen / 16 \)`
    case $lowdigit in 
    10) char=a ;;
    11) char=b ;;
    12) char=c ;;
    13) char=d ;;
    14) char=e ;;
    15) char=f ;;
     *) char=$lowdigit ;;
    esac
    hexlen="$char$hexlen"
    tmplen=`expr $tmplen / 16`
done
if test $len -lt 16 ; then
    hexlen="0$hexlen"
fi
len_integer=$hexlen
if test "$len_integer" = 0 ; then
   # We have a problem
   AC_MSG_WARN([Unable to determine size of an INTEGER type; using 4])
   # We make the length 4
   len_integer="04"
fi
MPI_INTEGER=0x4c00${len_integer}19
MPI_REAL=0x4c00${len_integer}1a
MPI_LOGICAL=0x4c00${len_integer}1b
AC_SUBST(MPI_INTEGER)
AC_SUBST(MPI_REAL)
AC_SUBST(MPI_LOGICAL)

len_double=$pac_cv_f77_sizeof_double_precision
# Convert to two digit hex
len=$len_double
#
# Take len and turn it into two hex digits (there are 8 bits available
# in the built-in datatype handle for the length; see
# src/mpid/common/datatype/mpid_datatype.h).  This code is taken
# from the code in mpich2/configure.in 
if test "$len" -gt 255 ; then
     AC_MSG_ERROR([Type sizes greater than 255 bytes not supported (type DOUBLE is $len bytes)]) 
fi
tmplen=$len
hexlen=""
while test $tmplen -gt 0 ; do
    lowdigit=`expr $tmplen - 16 \* \( $tmplen / 16 \)`
    case $lowdigit in 
    10) char=a ;;
    11) char=b ;;
    12) char=c ;;
    13) char=d ;;
    14) char=e ;;
    15) char=f ;;
     *) char=$lowdigit ;;
    esac
    hexlen="$char$hexlen"
    tmplen=`expr $tmplen / 16`
done
if test $len -lt 16 ; then
    hexlen="0$hexlen"
fi
len_double=$hexlen
if test "$len_double" = 0 ; then
   # We have a problem
   AC_MSG_WARN([Unable to determine size of a DOUBLE PRECISION type; using 8])
   # We make the length 8
   len_double="08"
fi
MPI_COMPLEX=0x4c00${len_double}1c
MPI_DOUBLE_PRECISION=0x4c00${len_double}1d
MPI_2INTEGER=0x4c00${len_double}1e
MPI_2REAL=0x4c00${len_double}1f
AC_SUBST(MPI_COMPLEX)
AC_SUBST(MPI_DOUBLE_PRECISION)
AC_SUBST(MPI_2INTEGER)
AC_SUBST(MPI_2REAL)

len_doublecplx=`expr $pac_cv_f77_sizeof_double_precision \* 2`
if test "$len_doublecplx" = 0 ; then
   # We have a problem
   AC_MSG_WARN([Unable to determine size of a DOUBLE PRECISION type; using 8])
   # We make the length 8*2 (in hex)
   len_doublecplx="10"
fi
len=$len_doublecplx
#
# Take len and turn it into two hex digits (there are 8 bits available
# in the built-in datatype handle for the length; see
# src/mpid/common/datatype/mpid_datatype.h).  This code is taken
# from the code in mpich2/configure.in 
if test "$len" -gt 255 ; then
     AC_MSG_ERROR([Type sizes greater than 255 bytes not supported (type DOUBLE COMPLEX is $len bytes)]) 
fi
tmplen=$len
hexlen=""
while test $tmplen -gt 0 ; do
    lowdigit=`expr $tmplen - 16 \* \( $tmplen / 16 \)`
    case $lowdigit in 
    10) char=a ;;
    11) char=b ;;
    12) char=c ;;
    13) char=d ;;
    14) char=e ;;
    15) char=f ;;
     *) char=$lowdigit ;;
    esac
    hexlen="$char$hexlen"
    tmplen=`expr $tmplen / 16`
done
if test $len -lt 16 ; then
    hexlen="0$hexlen"
fi
len_doublecplx=$hexlen

MPI_DOUBLE_COMPLEX=0x4c00${len_doublecplx}20
MPI_2DOUBLE_PRECISION=0x4c00${len_doublecplx}21
MPI_2COMPLEX=0x4c00${len_doublecplx}22
AC_SUBST(MPI_DOUBLE_COMPLEX)
AC_SUBST(MPI_2DOUBLE_PRECISION)
AC_SUBST(MPI_2COMPLEX)

#
# Temporary for the vast majority of systems that use 4 byte reals and
# 8 byte doubles
# Lengths at this point are in hex, hench "10" = 10 base 16 = 16 base 10.
if test "$len_double" = "08" ; then
    F77_COMPLEX8=$MPI_COMPLEX
fi
if test "$len_doublecplx" = "10" ; then
    F77_COMPLEX16=$MPI_DOUBLE_COMPLEX
fi
if test "$len_long_double" = "10" ; then
    F77_COMPLEX32="0x4c002023"
fi

len_2dc=`expr $pac_cv_f77_sizeof_double_precision \* 4`
firstdigit=0
seconddigit=0
while test $len_2dc -ge 16 ; do
    firstdigit=`expr $firstdigit + 1`
    len_2dc=`expr $len_2dc - 16`    
done
case $len_2dc in
    10) seconddigit=a ;;
    11) seconddigit=b ;;
    12) seconddigit=c ;;
    13) seconddigit=d ;;
    14) seconddigit=e ;;
    15) seconddigit=f ;;
     *) seconddigit=$len_2dc ;;
esac
len_2dc="$firstdigit$seconddigit"
#echo "2double complex = $len_2dc"
MPI_2DOUBLE_COMPLEX=0x4c00${len_2dc}23
AC_SUBST(MPI_2DOUBLE_COMPLEX)
#
# Predefined values for LB, UB, and PACKED
MPI_PACKED="0x4c00010f"
MPI_LB="0x4c000010"
MPI_UB="0x4c000011"
AC_SUBST(MPI_PACKED)
AC_SUBST(MPI_LB)
AC_SUBST(MPI_UB)

# We must convert all hex values to decimal (!)
# It would be nice to use expr to extract the next character rather than
# the heavier-weight sed, but expr under Tru64 Unix discards leading zeros,
# even when used only with the match (:) command.  Rather than have configure
# figure out if expr works, we just use sed.  Sigh.
for var in CHARACTER INTEGER REAL LOGICAL DOUBLE_PRECISION COMPLEX \
    DOUBLE_COMPLEX 2INTEGER 2REAL 2COMPLEX 2DOUBLE_PRECISION 2DOUBLE_COMPLEX \
    PACKED UB LB ; do  
    fullvar="MPI_$var"
    eval fullvarvalue=\$$fullvar
    #echo "$fullvar = $fullvarvalue"
    value=0
    fullvarvalue=`echo $fullvarvalue | sed -e 's/..\(.*\)/\1/'`
    for pos in 3 4 5 6 7 8 9 10 ; do
        # This works, even for Tru64, because only a single character
	# is extracted
        char=`expr $fullvarvalue : '\(.\)'`
	# FIXME: Tru64 Unix eliminates leading zeros (!)
	# How do we fix something that broken?
	fullvarvalue=`echo $fullvarvalue | sed -e 's/.\(.*\)/\1/'`
        case $char in 
            a) char=10 ;;
	    b) char=11 ;;
	    c) char=12 ;;
	    d) char=13 ;;
	    e) char=14 ;;
	    f) char=15 ;;
        esac
        value=`expr $value \* 16 + $char`
    done
    #echo "$fullvar = $value"
    eval $fullvar=$value
done

# Compare the sizes of these types to the C types

AC_LANG_C

AC_HEADER_STDC
AC_CHECK_HEADERS(stdlib.h string.h)

# Get defaults for cross compilation case
CROSS_SIZEOF_CHAR=${CROSS_SIZEOF_CHAR:-0}
CROSS_SIZEOF_SHORT=${CROSS_SIZEOF_SHORT:-0}
CROSS_SIZEOF_INT=${CROSS_SIZEOF_INT:-0}
CROSS_SIZEOF_LONG=${CROSS_SIZEOF_LONG:-0}
CROSS_SIZEOF_LONG_LONG=${CROSS_SIZEOF_LONG_LONG:-0}
CROSS_SIZEOF_FLOAT=${CROSS_SIZEOF_FLOAT:-0}
CROSS_SIZEOF_DOUBLE=${CROSS_SIZEOF_DOUBLE:-0}
CROSS_SIZEOF_LONG_DOUBLE=${CROSS_SIZEOF_LONG_DOUBLE:-0}
CROSS_SIZEOF_VOID_P=${CROSS_SIZEOF_VOID_P:-0}
CROSS_OFFSET_KIND=${CROSS_OFFSET_KIND:-0}
CROSS_ADDRESS_KIND=${CROSS_ADDRESS_KIND:-0}

AC_CHECK_SIZEOF(char,$CROSS_SIZEOF_CHAR)
AC_CHECK_SIZEOF(short,$CROSS_SIZEOF_SHORT)
AC_CHECK_SIZEOF(int,$CROSS_SIZEOF_INT)
AC_CHECK_SIZEOF(long,$CROSS_SIZEOF_LONG)
AC_CHECK_SIZEOF(long long,$CROSS_SIZEOF_LONG_LONG)
AC_CHECK_SIZEOF(float,$CROSS_SIZEOF_FLOAT)
AC_CHECK_SIZEOF(double,$CROSS_SIZEOF_DOUBLE)
AC_CHECK_SIZEOF(long double,$CROSS_SIZEOF_LONG_DOUBLE)
# sizeof(void*) is needed for ADDRESS_KIND below
AC_CHECK_SIZEOF(void*,$CROSS_SIZEOF_VOID_P)

#
# Preload the C mpi types
# THESE MUST MATCH THE DEFINITIONS IN MPI.H and MPIF.H
# We use these to match the optional Fortran types
char_mpi=${MPI_CHAR:-0}
short_mpi=${MPI_SHORT:-0}
int_mpi=${MPI_INT:-0}
long_mpi=${MPI_LONG:-0}
long_long_mpi=${MPI_LONG_LONG:-0}
float_mpi=${MPI_FLOAT:-0}
double_mpi=${MPI_DOUBLE:-0}
long_double_mpi=${MPI_LONG_DOUBLE:-0}

#
# The following code was correct for MPI-1, which allowed these datatypes
# to be an alias for another MPI type.  MPI-2 requires these to 
# be distinct types, so these are enumerated
if test "$use_alias_types" = yes ; then
    for len in 1 2 4 8 16 ; do
        eval F77_INTEGER$len=0
        #eval testval=\$"pac_cv_f77_sizeof_integer_$len"
        eval testval=\$"has_integer_$len"
        if test "$testval" = 0 ; then continue ; fi
        noval="yes"
        AC_MSG_CHECKING([for C type matching Fortran integer*$len])
        for c_type in char short int long "long_long" ; do
	    eval ctypelen=\$"ac_cv_sizeof_$c_type"
  	    if test "$testval" = "$ctypelen" -a "$ctypelen" -gt 0 ; then
	        AC_MSG_RESULT($c_type)
	        eval F77_INTEGER$len=\$"${c_type}_mpi"
	        noval="no"
	        break
            fi
        done
        if test "$noval" = "yes" ; then
            AC_MSG_RESULT([unavailable])
        fi
    done

    # Complex is set separately above
    for len in 4 8 16 ; do
        len2=`expr $len + $len`
        eval F77_REAL$len=0
        #eval F77_COMPLEX$len2=0
        #eval testval=\$"pac_cv_f77_sizeof_real_$len"
        eval testval=\$"has_real_$len"
        if test "$testval" = 0 ; then continue ; fi
        noval="yes"
        AC_MSG_CHECKING([for C type matching Fortran real*$len])
        for c_type in float double "long_double" ; do
	    eval ctypelen=\$"ac_cv_sizeof_$c_type"
	    if test "$testval" = "$ctypelen" -a "$ctypelen" -gt 0 ; then
	        AC_MSG_RESULT($c_type)
	        eval F77_REAL$len=\$"${c_type}_mpi"
	        #eval F77_COMPLEX$len2=\$"${c_type}_cplx_mpi"
                noval="no"
	        break
            fi
        done
        if test "$noval" = "yes" ; then
            AC_MSG_RESULT([unavailable])
        fi
    done
else 
   # Simply determine which types exist.  These may have been set by the
   # toplevel configure
   for var in INTEGER1 INTEGER2 INTEGER4 INTEGER8 INTEGER16 \
        REAL4 REAL8 REAL16 COMPLEX8 COMPLEX16 COMPLEX32 ; do  
	eval varname=MPI_$var
        eval varvalue=\$$varname
	#echo "$varname = $varvalue"
	if test "$varvalue" = MPI_DATATYPE_NULL ; then
	    eval F77_$var=0
	else
  	    eval F77_$var=\$$varname
	fi
   done
fi
# We must convert all hex values to decimal (!)
for var in INTEGER1 INTEGER2 INTEGER4 INTEGER8 INTEGER16 \
    REAL4 REAL8 REAL16 COMPLEX8 COMPLEX16 COMPLEX32 ; do  
    fullvar="F77_$var"
    eval fullvarvalue=\$$fullvar
    if test "$fullvarvalue" = 0 -o -z "$fullvarvalue" ; then 
        eval $fullvar=MPI_DATATYPE_NULL
        continue
    fi
    #echo "$fullvar = $fullvarvalue"
    value=0
    # See the comments above on why expr with : cannot be used here
    fullvarvalue=`echo $fullvarvalue | sed -e 's/..\(.*\)/\1/'`
    for pos in 3 4 5 6 7 8 9 10 ; do
        #char=`expr substr $fullvarvalue $pos 1`
        char=`expr $fullvarvalue : '\(.\)'`
	# We don't test for success of expr here because some expr's are
	# buggy and set the status to one on expressions like
        #    expr 00ccc : '\(.\)'
        # while both
        #    expr 00ccc : '\(..\)' 
        # and
        #    expr 100cc : '\(.\)'
        # return a zero status.  So the status is set even on success,
        # if the result is a single character that is a zero (!)
	#rc=$?
	#if test "$rc" != 0 ; then
	dnl #    AC_MSG_WARN([Failure (status $rc) in extracting first char from $fullvarvalue])
	#    break
	#fi
	fullvarvalue=`echo $fullvarvalue | sed -e 's/.\(.*\)/\1/'`
        case $char in 
            a) char=10 ;;
	    b) char=11 ;;
	    c) char=12 ;;
	    d) char=13 ;;
	    e) char=14 ;;
	    f) char=15 ;;
        esac
        value=`expr $value \* 16 + $char`
	if test $? != 0 ; then
	    AC_MSG_WARN([Failure to evaluate $value \* 16 + $char])
	fi
    done
    #echo "$fullvar = $value"
    eval $fullvar=$value
done
AC_SUBST(F77_INTEGER1)
AC_SUBST(F77_INTEGER2)
AC_SUBST(F77_INTEGER4)
AC_SUBST(F77_INTEGER8)
AC_SUBST(F77_INTEGER16)
AC_SUBST(F77_REAL4)
AC_SUBST(F77_REAL8)
AC_SUBST(F77_REAL16)
AC_SUBST(F77_COMPLEX8)
AC_SUBST(F77_COMPLEX16)
AC_SUBST(F77_COMPLEX32)

noval="yes"
AC_MSG_CHECKING([for C type matching Fortran integer])
for c_type in char short int long "long_long" ; do
    eval ctypelen=\$"ac_cv_sizeof_$c_type"
    if test "$pac_cv_f77_sizeof_integer" = "$ctypelen" -a \
       "$ctypelen" -gt 0 ; then
	c_type=`echo $c_type | sed -e 's/_/ /g'`
	AC_MSG_RESULT($c_type)
	MPI_FINT=$c_type
	noval="no"
	break
    fi
done
if test "$noval" = "yes" ; then
    # Set a default
    MPI_FINT="int"
    AC_MSG_RESULT([unavailable])
fi
AC_SUBST(MPI_FINT)
dnl
dnl We also need to check the size of MPI_Aint vs MPI_Fint, and
dnl define AINT_LARGER_THAN_FINT if aint is larger (this 
dnl affects code in MPI_Address)
if test "$ac_cv_sizeof_voidp" != "0" -a \
        "$ac_cv_sizeof_voidp" -gt "$pac_cv_f77_sizeof_integer" ; then
    AC_DEFINE(HAVE_AINT_LARGER_THAN_FINT,1,[Define if addresses are larger than Fortran integers])
fi
dnl
dnl
dnl Include a defined value for Fint is int
if test "$MPI_FINT" = "int" ; then
    AC_DEFINE(HAVE_FINT_IS_INT,1,[Define if Fortran integer are the same size as C ints])
fi
dnl 
dnl Also get sizeof_integer (== sizeof_mpi_fint) and sizeof_int.  
dnl These are available as SIZEOF_F77_INTEGER and SIZEOF_INT
if test "$SIZEOF_F77_INTEGER" != "$SIZEOF_INT" ; then
   AC_MSG_WARN([Fortran integers and C ints are not the same size.  The current Fortran binding does not support this case])
fi

#
# Set size of MPI_Status.  We may need sizeof_int here as well
#
if test -z "$MPI_STATUS_SIZE" ; then
    if test -n "$SIZEOF_MPI_STATUS" ; then
        # compute from the C sizeof
	MPI_STATUS_SIZE=`expr $SIZEOF_MPI_STATUS / $ac_cv_sizeof_int`
	if test "$MPI_STATUS_SIZE" = "0" ; then
	    AC_MSG_WARN([Could not compute the size of MPI_Status])
	    MPI_STATUS_SIZE=5
        fi
    else
        AC_MSG_WARN([MPI_STATUS_SIZE was not defined!])
        # The default size is 5.  See mpi.h.in
        MPI_STATUS_SIZE=5
    fi
fi
AC_SUBST(MPI_STATUS_SIZE)

PAC_PROG_C_UNALIGNED_DOUBLES(,
[AC_MSG_WARN(Your C compiler $CC does not support unaligned accesses
to doubles.  This is required for interoperation with 
Fortran (the Fortran standard requires it).
You may need to specify an additional argument to your C compiler to 
force it to allow unaligned accesses.)])

#
# Bsend overhead is sent down from the top level configure.
# Set a conservative default if it isn't provided.
BSEND_OVERHEAD=${BSEND_OVERHEAD:-128}
AC_SUBST(BSEND_OVERHEAD)

MPI_MAX_PROCESSOR_NAME="${MPI_MAX_PROCESSOR_NAME:-128}"
AC_SUBST(MPI_MAX_PROCESSOR_NAME)
#
# Try for weak symbols for the profiling interface.
if test "$enable_weak" = "yes" ; then
    PAC_PROG_C_WEAK_SYMBOLS(AC_DEFINE(HAVE_WEAK_SYMBOLS,1,[Define if weak symbols supported]))
    # Check for the ability to support multiple weak symbols
    if test "$pac_cv_prog_c_weak_symbols" = "pragma weak" ; then
       PAC_PROG_C_MULTIPLE_WEAK_SYMBOLS(AC_DEFINE(HAVE_MULTIPLE_PRAGMA_WEAK,1,[Define if multiple weak symbols may be defined]))
    fi
fi
# These values are exported from the upper-layer configure.
AC_SUBST(PROFILE_DEF_MPI)
AC_SUBST(NO_WEAK_SYM)
AC_SUBST(NO_WEAK_SYM_TARGET)
AC_SUBST(NEEDSPLIB)
#
# If weak symbols are *not* supported, we may want to be careful
# about including 
# external pmpi_wtime, pmpi_wtick
# in the mpif.h file .  For now, we'll just declare them as 
# double precision without including an external declaration for them.
#
# Try to get values for Fortran logical variables.
if test "$cross_compiling" = "no" ; then
    AC_MSG_CHECKING([for values of Fortran logicals])
    # Use a Fortran main program.  This simplifies some steps, since getting
    # all of the Fortran libraries (including shared libraries that are not
    # in the default library search path) can be tricky.  Specifically,
    # The PROG_F77_RUN_PROC_FROM_C failed with some installations of the
    # Portland group compiler.
dnl     AC_CACHE_VAL(pac_cv_prog_f77_true_false_value,[
dnl     PAC_PROG_F77_RUN_PROC_FROM_C([
dnl #include <stdio.h>
dnl int main()
dnl {
dnl     $MPI_FINT itrue, ifalse;
dnl     FILE *f = fopen("conftestval", "w" );
dnl     if (!f) exit(1);
dnl     ftest_( &itrue, &ifalse );
dnl     fprintf( f, "%d %d\n", itrue, ifalse );
dnl     exit(0);
dnl }
dnl ],[
dnl         subroutine ftest( itrue, ifalse )
dnl         logical itrue, ifalse
dnl         itrue  = .TRUE.
dnl         ifalse = .FALSE.
dnl         return
dnl         end
dnl ],[
dnl     pac_cv_prog_f77_true_false_value=`cat conftestval`
dnl ],,:)])
    AC_CACHE_VAL(pac_cv_prog_f77_true_false_value,[
# Compile a C routine to print the values of true and false
cat >conftestc.c <<EOF
#include <stdio.h>
#include "confdefs.h"
#ifdef F77_NAME_UPPER
#define ftest_ FTEST
#elif defined(F77_NAME_LOWER) || defined(F77_NAME_MIXED)
#define ftest_ ftest
#endif
void ftest_( $MPI_FINT *, $MPI_FINT *);
void ftest_( $MPI_FINT *itrue, $MPI_FINT *ifalse )
{ 
  FILE *f = fopen("conftestval","w");
  if (!f) exit(1);
  fprintf( f, "%d %d\n", *itrue, *ifalse );
  fclose(f);
}
EOF
# Create the Fortran program
cat >conftest.f <<EOF
       program main
       logical itrue, ifalse
       itrue = .TRUE. 
       ifalse = .FALSE.
       call ftest( itrue, ifalse )
       end
EOF
# Compile the two files
    pac_tmp_compile='$CC -c $CFLAGS $CPPFLAGS conftestc.c >&5'
    if AC_TRY_EVAL(pac_tmp_compile) && test -s conftestc.o ; then
        AC_LANG_SAVE
        AC_LANG_FORTRAN77
        saveLIBS=$LIBS
        LIBS="conftestc.o $LIBS"
        if AC_TRY_EVAL(ac_link) && test -s conftest$ac_exeext ; then
	    if ./conftest$ac_exeext ; then
	        # success
		pac_cv_prog_f77_true_false_value=`cat conftestval`
            else
	        # failure 
		AC_MSG_WARN([Unable to run the program to determine the values of logicals])
		echo "configure: failed program was:" >&AC_FD_CC
		cat conftest.f >&AC_FD_CC
	    fi
        else
	    # failure
            AC_MSG_WARN([Unable to build program to determine values of logicals])
	    echo "configure: failed program was:" >&AC_FD_CC
	    cat conftest.f >&AC_FD_CC
        fi
	LIBS=$saveLIBS
        AC_LANG_RESTORE
    else
        AC_MSG_WARN([Unable to compile the C routine for finding the values of logicals])
	echo "configure: failed program was:" >&AC_FD_CC
	cat conftestc.c >&AC_FD_CC
    fi
])
    true_val="`echo $pac_cv_prog_f77_true_false_value | sed -e 's/ .*//g'`"
    false_val="`echo $pac_cv_prog_f77_true_false_value | sed -e 's/.*  *//g'`"
    if test -n "$true_val" -a -n "$false_val" ; then
        AC_DEFINE(F77_TRUE_VALUE_SET,1,[Define if we know the value of Fortran true and false])
        AC_DEFINE_UNQUOTED(F77_TRUE_VALUE,$true_val,[The value of true in Fortran])
        AC_DEFINE_UNQUOTED(F77_FALSE_VALUE,$false_val,[The value of false in Fortran])
	AC_MSG_RESULT([True is $true_val and False is $false_val])
    else
	AC_MSG_RESULT([could not determine])
    fi
fi

PAC_LANG_POP_COMPILERS

# If the system is Cray or Cray-like, then we need to handle character
# data in a special way.  This code does that.
if test "$target_os" = "CRAY" ; then
    # If tested code does NOT compile, then define _TWO_WORD_FCD
    AC_MSG_CHECKING([whether TWO_WORD_FCDs are used])
    AC_TRY_COMPILE([#include <fortran.h>],
[void  *buf;_fcd temp;temp = _fcdtocp(buf);],
compile_check=yes,compile_check=no)
    AC_MSG_RESULT($compile_check)
    if test "$compile_check" = "no" ; then
        TEMP_CFLAGS=$CFLAGS
        CFLAGS="-D_TWO_WORD_FCD $CFLAGS"
        AC_MSG_CHECKING([whether program compiles if _TWO_WORD_FCD is defined ])
        AC_TRY_COMPILE([#include <fortran.h>],
[void  *buf;_fcd temp;temp = _fcdtocp(buf);],
compile_check=yes,compile_check=no)
        AC_MSG_RESULT($compile_check)
        if test "$compile_check" = "no" ; then
	    AC_MSG_WARN([You may have problems compiling the Fortran interface
specifically calls to  _fcdtocp])
        elif test "$compile_check" = "yes" ; then
            AC_DEFINE(_TWO_WORD_FCD,1,[Define if characters use two-word descriptors])
        fi
        CFLAGS=$TEMP_CFLAGS
    fi
fi

if test -n "$arch_UXPM" -o -n "$arch_uxpv" ; then
    # This asserts that Fortran passes functions by passing the address of the
    # pointer to the function.
    # We really need a TEST for this
    AC_DEFINE(FORTRAN_SPECIAL_FUNCTION_PTR,1,[Define if Fortran functions are passed by passing the address of the pointer to the function])
    # Suggested values for these are
    dnl CFLAGS=-O
    dnl    #FFLAGS=-Oe,-U -Aabe ( Parameter e is not supported on  uxp/m )
    dnl FLINKER=frt
    dnl FLIBS="$FLIB_PATH $LIB_LIST"
fi

#
# Most systems allow the Fortran compiler to process .F and .F90 files
# using the C preprocessor.  However, some systems either do not
# allow this or have serious bugs (OSF Fortran compilers have a bug
# that generates an error message from cpp).  The following test
# checks to see if .F works, and if not, whether "cpp -P -C" can be used
rm -f conftest*
AC_MSG_CHECKING([whether Fortran compiler processes .F files with C preprocessor])
cat >conftest.F <<EOF
        program main
#define SIZE 10
        integer a(SIZE)
        end
EOF
pac_cv_fort_accepts_F=no
pac_Fcompile='${F77} -c $FFLAGS $CPPFLAGS conftest.F 1>&AC_FD_CC'

if AC_TRY_EVAL(pac_Fcompile) && test -s conftest.o ; then
   pac_cv_fort_accepts_F=yes
else
    # Can we use cpp?
    pac_Fcpp='${CPP} -C -P $CPPFLAGS conftest.F >conftest.f 2>&AC_FD_CC'
    if AC_TRY_EVAL(pac_Fcpp) && test -s conftest.f ; then
        pac_fFcompile='${F77} -c $FFLAGS $CPPFLAGS conftest.f 1>&AC_FD_CC'
	if AC_TRY_EVAL(pac_fFcompile) && test -s conftest.o ; then
	    pac_cv_fort_accepts_F="no, use cpp"
	fi
    fi
fi
rm -f conftest.*
AC_MSG_RESULT($pac_cv_fort_accepts_F)
case "$pac_cv_fort_accepts_F" in 
    yes)
    F77CPP=""
    ;;
    "no, use cpp")
    F77CPP="$CPP -C -P"
    ;;
    no) 
    F77CPP="false"
    ;;
esac
AC_SUBST(F77CPP)
#
# For Fortran 90, we'll also need MPI_ADDRESS_KIND and MPI_OFFSET_KIND
# Since our compiler might BE a Fortran 90 compiler, try and determine the
# values.  
if test -z "$F90" ; then
    AC_CACHE_CHECK([whether Fortran compiler is a Fortran 90 compiler],
    pac_cv_prog_f77_is_f90,[
    pac_cv_prog_f77_is_f90=no
    cat >>conftest.f90 <<EOF
        program main
        integer, dimension(10) :: n
        integer k
	print *,  range(k)
        end
EOF
    if $F77 -o conftest $FFLAGS conftest.f90 >/dev/null 2>&1 ; then
        if test -x conftest ; then
	    pac_cv_prog_f77_is_f90=yes
        fi
    fi
])
    if test "$pac_cv_prog_f77_is_f90" = yes ; then
        F90=$F77
	if test -z "$F90FLAGS" ; then 
	    F90FLAGS="$FFLAGS"
        fi
    fi
fi
if test -n "$F90" ; then
    PAC_LANG_PUSH_COMPILERS
    PAC_LANG_FORTRAN90
    # Offset kind should be for 8 bytes if possible (Romio prefers that)
    # address should be sizeof void *
    testsize=$ac_cv_sizeof_voidp
    if test "$testsize" = 0 ; then
        # Set a default
        testsize=4
    fi  
    dnl Using the {} around testsize helps the comments work correctly
    PAC_PROG_F90_INT_KIND(ADDRESS_KIND,${testsize},$CROSS_F90_ADDRESS_KIND)
    if test "$ac_cv_sizeof_void_p" = 8 ; then
        OFFSET_KIND=$ADDRESS_KIND
    else
        PAC_PROG_F90_INT_KIND(OFFSET_KIND,8,$CROSS_F90_OFFSET_KIND)
    fi
    #
    # Some compilers won't allow a -1 kind (e.g., absoft).  In this case, 
    # use a fallback (sizeof(int) kind)
    if test "$ADDRESS_KIND" = "-1" -o "$OFFSET_KIND" = "-1" ; then
        PAC_PROG_F90_INT_KIND(simpleintkind,${pac_cv_f77_sizeof_integer})
        if test "$simpleintkind" = "-1" ; then
	    # Wild guess; probably means that Fortran 90 is not available
   	    simpleintkind=4
        fi
        if test "$ADDRESS_KIND" = "-1" ; then
	    ADDRESS_KIND=$simpleintkind
        fi
        if test "$OFFSET_KIND" = "-1" ; then
	    OFFSET_KIND=$simpleintkind
        fi
    fi
    PAC_LANG_POP_COMPILERS
fi

AC_SUBST(ADDRESS_KIND)
AC_SUBST(OFFSET_KIND)
#
# We'd also like to identify a Fortran 77 type that can be used for
# offsets and for addresses, so that we can pass that information back 
# up to allow other tools (such as user programs and test suites)
# to properly declare the variables

dnl Check for other Fortran 90 features, such as different include/use
dnl module directory and special flags.  Build modules if requested
if test -n "$F90" -a "$enable_f90" != "no" ; then
    F90_SUFFIX="$ac_f90ext"
    # For now, top_srcdir_val is MPIR_HOME; 
    # The build dir is relative at ../..
    top_srcdir_val="$MPIR_HOME"
    if test "$do_f90_modules" = "yes" -a -n "$top_srcdir_val" ; then
        echo "Setting up F90 Module support"
	if test ! -d ../../f90modules ; then mkdir ../../f90modules ; fi
	# if we're the developers, we may need to create the
	# initial configure files.
	if test ! -x $top_srcdir_val/f90modules/configure -a \
	          -s $top_srcdir_val/f90modules/configure.in -a \
		  -x $top_srcdir_val/f90modules/makeconfigure ; then
	    (cd $top_srcdir_val/f90modules ; ./makeconfigure)
	fi
	# Should F90LINKER be F90TESTLINKER?
        (cd ../../f90modules ; \
	            export F90 ; export MPIR_HOME ; export VPATH ; \
	   	    export libbuild_dir ; export includebuild_dir ; \
		    export MAKE ; F90LINKER="$F90LINKER" ; \
		    export F90LINKER ; export F77 ; \
 	   	    $top_srcdir_val/f90modules/configure --with-mpich)
        if test ! -s ../../f90modules/Makefile ; then 
	    # turn off f90
	    F90=""
	else		    
 	    F90_MODINCFLAG="`$MAKE -f ../../f90modules/Makefile f90modflag`"
  	    F90MODINCSPEC="`$MAKE -f ../../f90modules/Makefile f90modspec`"
            if test -z "$USER_SET_F90INC" -a -z "$F90INC" ; then 
	        # This should use a test or try to get it from the f90module.
	        F90INC=`$MAKE -f ../../f90modules/Makefile f90incflag`
            fi
        fi
    fi
else 
     # Remove the f90modules/Makefile since this is the only way
     # to tell the top-level makefile not to build the f90 modules.
     # (We need a better way)
     rm -f ../../f90modules/Makefile
fi
AC_SUBST(F90_SUFFIX)
f90includedir='${includedir}'
f90libdir='${libdir}'
AC_SUBST(f90includedir)
AC_SUBST(f90libdir)
AC_SUBST(F90_LDFLAGS)
AC_SUBST(F90INC)
AC_SUBST(F90_MODINCFLAG)
AC_SUBST(F90MODINCSPEC)
AC_SUBST(F90FLAGS)
AC_SUBST(F90LINKER)
AC_SUBST(F90LIB_PATH)
if test -z "$F90_LIBDIR_LEADER" ; then 
    F90_LIBDIR_LEADER="-L"
fi
AC_SUBST(F90_LIBDIR_LEADER)

dnl
dnl If both C and Fortran are gnu, define the following to simplify 
dnl shared library support.  
AC_MSG_CHECKING([whether using gcc and g77 together])
if test "$ac_cv_prog_gcc" = "yes" -a "$ac_cv_prog_g77" = "yes" ; then
    AC_DEFINE(USE_GCC_G77_DECLS,1,[Define if using gcc and g77 together])
    AC_MSG_RESULT(yes)
else 
    AC_MSG_RESULT(no)
fi
dnl In the MPICH case, make a copy of the definitions file available to the
dnl mpi.h file.
dnl Despite the fact that this appears *before* AC_OUTPUT, these actions 
dnl happen *after* AC_OUTPUT
dnl AC_OUTPUT_COMMANDS([if test -n "$includebuild_dir" ; then \
dnl 	cp include/mpi_fortdefs.h $includebuild_dir/mpi_fortdefs.h ; fi],
dnl 	[includebuild_dir=$includebuild_dir] )
dnl AC_OUTPUT_COMMANDS([chmod a+x mpif77 ; \
dnl     if test -n "$binbuild_dir" ; then cp mpif77 $binbuild_dir/mpif77 ; fi], 
dnl         [binbuild_dir=$binbuild_dir] )
dnl
dnl First, ensure that echo works within the config.status 
AC_OUTPUT_COMMANDS([if test "$enable_echo" ; then set -x ; fi ])
dnl This must be run before converting C to !
dnl Also note that this must only be done once.  Because of the way configure
dnl works, this step can sometimes be repeated, creating an invalid file.
dnl We do this by looking for MPIPRIV in the mpif.h file
AC_OUTPUT_COMMANDS([
if grep MPIPRIV mpif.h 2>&1 1>/dev/null ; then 
    :
else 
    rm -rf .tmp ; 
    cat mpif.h mpif_bottom.h > .tmp ;
    rm -f mpif.h ; mv .tmp mpif.h
fi
])
dnl By modifying mpif.h to use ! for comments, it can work with many f90 
dnl compilers without creating a separate version.  
dnl Note that this is run AFTER the AC_OUTPUT actions
AC_OUTPUT_COMMANDS([if test "$has_exclaim" = "yes" ; then 
    rm -rf .tmp
    cp mpif.h .tmp
    sed -e 's/^C/\!/g' .tmp > mpif.h
    rm -rf .tmp
fi
],[has_exclaim=$has_exclaim])
dnl
FC="$F77"
AC_SUBST(FC)
AC_SUBST(CFLAGS) # some autoconf versions need this explicitly
# These last 2 sets of flags are used to pass flags needed only to compile
# and use MPI programs, not to build the MPI library itself.
AC_SUBST(MPI_FFLAGS)
if test -z "$MPI_LDFLAGS" ; then
    # Pickup any flags from LDFLAGS.
    MPI_LDFLAGS="$LDFLAGS"
fi
AC_SUBST(MPI_LDFLAGS)
if test -z "$top_build_dir" ; then
    top_build_dir=`cd ../../.. ; pwd`
fi
if test -z "$includebuild_dir" ; then
    includebuild_dir=$top_build_dir/src/include
fi
if test -z "$libbuild_dir" ; then
    libbuild_dir=$top_build_dir/lib
fi
dnl
dnl Dependency handling
AC_SUBST(MAKE_DEPEND_C)

AC_SUBST(MPIVERSION)

AC_OUTPUT_COMMANDS([chmod a+x mpif77 ;
   if test ! -d ../../../bin  ; then mkdir ../../../bin ; fi 
   sed -e 's%includedir=.*%includedir='$includebuild_dir% \
       -e 's%libdir=.*%libdir='$libbuild_dir% mpif77 > ../../../bin/mpif77 ;
   chmod a+x ../../../bin/mpif77 ],
includebuild_dir=$includebuild_dir
libbuild_dir=$libbuild_dir
)
AC_OUTPUT_COMMANDS([cp mpif.h ../../../src/include])
AC_OUTPUT(Makefile mpif.h mpif77.conf mpif77 setbotf.f)
exit 0
dnl
dnl The following needs to be moved into AC_OUTPUT_COMMANDS (and generally
dnl cleaned up)
dnl Add the following to the output step after the AC_OUTPUT

if test -n "$F90" ; then
    # Remove all comments from mpif.h
    /bin/rm -f $includebuild_dir/mpif.h.copy
    cp $includebuild_dir/mpif.h $includebuild_dir/mpif.h.copy
    if test "$fixupmpif" = "no" ; then
	# Regular Fortran doesn't have ! for comments, so we just delete them
        sed -e '/^C/d' -e 's/\!.*$//g' $includebuild_dir/mpif.h.copy > $includebuild_dir/mpif.h
    else
        sed -e 's/^C/\!/g' $includebuild_dir/mpif.h.copy > $includebuild_dir/mpif.h
    fi
    /bin/rm -f $includebuild_dir/mpif.h.copy
else
    # ROMIO might have added ! comments to mpif.h
    if test -z "$fixupmpif" -o "$fixupmpif" = "no" ; then
        /bin/rm -f $includebuild_dir/mpif.h.copy
        cp $includebuild_dir/mpif.h $includebuild_dir/mpif.h.copy
	# Regular Fortran doesn't have ! for comments, so we just delete them
        sed -e '/^C/d' -e 's/\!.*$//g' $includebuild_dir/mpif.h.copy > $includebuild_dir/mpif.h
        /bin/rm -f $includebuild_dir/mpif.h.copy
    fi
fi
