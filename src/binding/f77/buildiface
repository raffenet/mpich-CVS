#! /usr/bin/perl -w
#
# This file builds candidate interface files from the descriptions in 
# mpi.h
#
# Here are the steps:
# 1) Find the prototypes in mpi.h.in (Look for *Begin Prototypes*)
# 2) For each function, match the name and args:
#    int MPI_xxxx( ... )
# 3) Create a new file with the name lc(xxxx)f.c (lowercase of name), 
#    containing 
#    Copyright
#    Profiling block indicator
#    Fortran name version of function, with MPI objects replaced by 
#    MPI_Fint etc. as appropriate
#    
#
# Setup global variables
$buildfiles = 1;
$build_prototypes = 1;
$print_line_len = 0;
$debug = 0;
@arg_addresses = ();

#feature variables
$do_logical = 1;
$do_fint    = 1;
$do_weak    = 1;
$do_subdecls = 1;
$do_bufptr = 1;

# Process arguments
#
# Args
# -feature={logical,fint,subdecls,weak,bufptr}, separated by :, value given 
# by =on or =off, eg
# -feature=logical=on:fint=off
# The feature names mean:
#    logical - Fortran logicals are converted to/from C
#    fint    - Fortran integers and C ints are different size (not implemented)
#    subdecls - Declarations for PC-Fortran compilers added
#    weak    - Use weak symbols 
#    bufptr  - Check for MPI_BOTTOM as a special address.  This is
#              not needed if a POINTER declaration is available.
foreach $_ (@ARGV) {
    if (/-noprototypes/) { $build_prototypes = 0; }
    elsif (/-feature=(.*)/) {
	foreach $feature (split(/:/,$1)) {
	    print STDERR "Processing feature $feature\n" if $debug;
	    # Feature values are foo=on,off
	    ($name,$value) = split(/=/,$feature);
	    if ($value eq "on") { $value = 1; } 
	    elsif ($value eq "off") { $value = 0; }
	    # Set the variable based on the string
	    $varname = "do_$name";
	    $$varname = $value;
	}
    }
    else {
	print STDERR "Unrecognized argument $_\n";
    }
}

%tof77 = ( 'MPI_Datatype' => 'MPI_Fint *',
	   'MPI_Comm' => 'MPI_Fint *',
	   'MPI_File' => 'MPI_Fint *',
	   'MPI_Win' => 'MPI_Fint *',
	   'MPI_Request' => 'MPI_Fint *',
	   'MPI_Group' => 'MPI_Fint *',
	   'MPI_Op' => 'MPI_Fint *',
	   'MPI_Info' => 'MPI_Fint *',
	   'MPI_Errhandler' => 'MPI_Fint *',
	   'MPI_Aint' => 'MPI_Fint *',   # Should be MPIR_FAint
	   'int' => 'MPI_Fint *',
	   'int [][3]' => 'MPI_Fint *',
	   'MPI_Datatype *' => 'MPI_Fint *',
	   'MPI_Comm *', 'MPI_Fint *',
	   'MPI_File *', 'MPI_Fint *',
	   'MPI_Win *', 'MPI_Fint *', 
	   'MPI_Group *', 'MPI_Fint *',
	   'MPI_Request *' => 'MPI_Fint *',
	   'MPI_Aint *' => 'MPI_Fint *',   # Should be MPIR_FAint
	   'int *' => 'MPI_Fint *',
	   'MPI_Op *' => 'MPI_Fint *',
	   'MPI_Status *' => 'MPI_Fint *',
	   'MPI_Info *' => 'MPI_Fint *',
	   'MPI_Errhandler *' => 'MPI_Fint *',
	   );

%argsneedcast = ( 'MPI_Request *' => '(MPI_Request *)(ARG)',
		  'MPI_Status *'  => '(MPI_Status *)(ARG)',
		  'int [][3]' => '(int (*)[3])(ARG)'
);

# name_map maps the filenames.  Most filenames are created automatically
# from the routine name, but some names have too many characters (15, 
# including the extension(.o) is a limit for ar in some systems).
%name_map = ( 'add_error_class' => 'adderrclass',
	      'add_error_code' => 'adderrcode',
	      'add_error_string' => 'adderrstring',
	      'buffer_attach' => 'bufattach',
	      'buffer_detach' => 'bufdetach',
	      'comm_call_errhandler' => 'commcallerr',
	      'comm_create_errhandler' => 'commcreerr',
	      'comm_create_keyval' => 'commnewkey',
	      'comm_delete_attr' => 'commdelattr',
	      'comm_disconnect' => 'commdisc',
	      'comm_free_keyval' => 'commfreekey',
	      'comm_get_errhandler' => 'commgeterr',
	      'comm_get_name' => 'commgetnam',
	      'comm_get_parent' => 'commparent',
	      'comm_remote_group' => 'commrgroup',
	      'comm_remote_size' => 'commrsize',
	      'comm_set_errhandler' => 'commseterr',
	      'comm_spawn_multiple' => 'spawnmult',
	      'comm_test_inter' => 'commtestic',
	      'errhandler_create' => 'errhcreate',
	      'errhandler_free' => 'errhfree',
	      'errhandler_get' => 'errhget',
	      'errhandler_set' => 'errhset',
	      'file_call_errhandler' => 'filecallerr',
	      'file_create_errhandler' => 'filecreerr',
	      'file_get_errhandler' => 'filegeterr',
	      'file_set_errhandler' => 'fileseterr',
	      'get_processor_name' => 'getpname',
	      'graph_neighbors_count' => 'grfnbcount',
	      'graph_neighbors' => 'grfnbrs',
	      'grequest_complete' => 'greqcomplete',
	      'grequest_start' => 'greqstart',
	      'group_difference' => 'groupdiff',
	      'group_intersection' => 'groupinter',
	      'group_range_excl' => 'grouprexcl',
	      'group_range_incl' => 'grouprincl',
	      'group_translate_ranks' => 'grouptranks',
	      'info_get_nkeys' => 'infognk',
	      'info_get_nthkey' => 'infognthk',
	      'info_get_valuelen' => 'infovallen',
	      'intercomm_create' => 'iccreate',
	      'intercomm_merge' => 'icmerge',
	      'is_thread_main' => 'isthrmain',
	      'pack_external_size' => 'packesize',
	      'reduce_scatter' => 'redscat',
	      'request_get_status' => 'reqgetstat',
	      'sendrecv_replace' => 'sndrcvrpl',
	      'status_set_cancelled' => 'statgetcl',
	      'status_set_elements' => 'statsetel',
	      'test_cancelled' => 'testcancel',
	      'type_contiguous' => 'typecontig',
	      'type_create_darray' => 'typedarray',
	      'type_create_hindexed' => 'typechind',
	      'type_create_hvector' => 'typechvec',
	      'type_create_indexed_block' => 'typecindb',
	      'type_create_keyval' => 'typenewkey',
	      'type_create_resized' => 'typecresize', 
	      'type_create_struct' => 'typecstruct',
	      'type_create_subarray' => 'typecsubarr',
	      'type_delete_attr' => 'typedelattr',
	      'type_free_keyval' => 'typefreekey',
	      'type_get_contents' => 'typegetcnts',
	      'type_get_envelope' => 'typegetenv',
	      'type_get_extent' => 'typeextent',
	      'type_get_name' => 'typegname',
	      'type_get_true_extent' => 'typegtext',
	      'type_set_attr' => 'typesetattr',
	      'type_set_name' => 'typesetname',
	      'unpack_external' => 'unpackext',
	      'unpublish_name' => 'unpubname',
	      'win_call_errhandler' => 'wincallerr',
	      'win_create_errhandler' => 'wincreerr',
	      'win_create_keyval' => 'winnewkey',
	      'win_delete_attr' => 'windelattr',
	      'win_free_keyval' => 'winfreekey',
	      'win_get_errhandler' => 'wingeterr',
	      'win_set_errhandler' => 'winseterr',
);

#
# Special routines have very different calling seqences in C and Fortran
# or different behavior.
%special_routines = ( 'Init' => 1, 'Init_thread' => 1, 'Pcontrol' => '1',
		      'Address' => 1, 'Get_address' => 1 );

#
# Most routines can be processed automatically.  However, some
# require some special processing.  For example, those routines with
# LOGICAL arguments need some special handling.  To detect this, there
# are two entries in a %special_args hash: the routine name, and the routine
# name -arg#.  E.g., for MPI_Test, the hash has keys
# "Test" and "Test-2".  The value for "Test-2" is "out:logical"; this 
# indicates that the variable is an out variable with logical type.
# Processing types (the second field after the :) are
#    logical: convert to/from Fortran and C representations of logical
#    index:   convert to/from Fortran (1-based) and C (0-based) origins
#    array:   handle arrays of items that may have different lengths
#             in C and Fortran because the integer types have 
#             different sizes.  The term has an additional :expression,
#             the third term give the array size.
#    addnull: Add a null character to a *copy* of the input string,
#             after trimming any blanks.
#    blankpad: Add blanks and remove nulls.  Use a copy of the string
#             for the call to the C routine.
#    bufptr:  Detect MPI_BOTTOM.  Note that a better alternative is to
#             use MPI_Address and MPI_Get_address to make addresses
#             relative to the Fortran MPI_BOTTOM.  The lines that
#             define this are commented out below.
%special_args = ( 
#    'Allreduce' => '1:2', 'Allreduce-1' => 'in:bufptr',	
#		 'Allreduce-2' => 'in:bufptr', 
#    'Bcast' => '1', 'Bcast-1' => 'in:bufptr',		 
#    'Gather' => '1:4', 'Gather-1' => 'in:bufptr', 'Gather-4' => 'in:bufptr',
#    'Gatherv' => '1:4', 'Gatherv-1' => 'in:bufptr', 'Gatherv-4' => 'in:bufptr',
#    'Scatter' => '1:4', 'Scatter-1' => 'in:bufptr', 'Scatter-4' => 'in:bufptr',
#    'Scatterv' => '1:5', 'Scatterv-1' => 'in:bufptr', 'Scatterv-5' => 'in:bufptr',
#    'Allgather' => '1:4', 'Allgather-1' => 'in:bufptr', 'Allgather-4' => 'in:bufptr',
#    'Allgatherv' => '1:4', 'Allgatherv-1' => 'in:bufptr', 'Allgatherv-4' => 'in:bufptr',
#    'Alltoall' => '1:4', 'Alltoall-1' => 'in:bufptr', 'Alltoall-4' => 'in:bufptr',
#    'Alltoallv' => '1:5', 'Alltoallv-1' => 'in:bufptr', 'Alltoallv-5' => 'in:bufptr',
#    'Reduce' => '1:2', 'Reduce-1' => 'in:bufptr', 'Reduce-2' => 'in:bufptr',
#    'Reduce_scatter' => '1:2', 'Reduce_scatter-1' => 'in:bufptr', 
#		  'Reduce_scatter-2' => 'in:bufptr',
#    'Scan' => '1:2', 'Scan-1' => 'in:bufptr', 'Scan-2' => 'in:bufptr',
    'Cart_create' => '4:5', 'Cart_create-4' => 'in:logical_array:*v2', 
    'Cart_create-5' => 'in:logical', 
    'Cart_get' => '4', 'Cart_get-4' => 'out:logical_array:*v2',
    'Comm_test_inter' => '2', 'Comm_test_inter-2' => 'out:logical',
    'Get_processor_name' => '1', 'Get_processor_name-1' => 'out:blankpad',
    'Initialized' => '1', 'Initialized-1' => 'out:logical',
    'Iprobe' => '4', 'Iprobe-4' => 'out:logical',
#    'Send' => '1', 'Send-1' => 'in:bufptr',
#    'Ssend' => '1', 'Ssend-1' => 'in:bufptr',
#    'Rsend' => '1', 'Rsend-1' => 'in:bufptr',
#    'Bsend' => '1', 'Bsend-1' => 'in:bufptr',
#    'Isend' => '1', 'Isend-1' => 'in:bufptr',
#    'Issend' => '1', 'Issend-1' => 'in:bufptr',
#    'Irsend' => '1', 'Irsend-1' => 'in:bufptr',
#    'Ibsend' => '1', 'Ibsend-1' => 'in:bufptr',
#    'Irecv' => '1', 'Irecv-1' => 'in:bufptr',
#    'Recv' => '1', 'Recv-1' => 'in:bufptr',		  
#    'Send_init' => '1', 'Send_init-1' => 'in:bufptr',
#    'Bsend_init' => '1', 'Bsend_init-1' => 'in:bufptr',
#    'Ssend_init' => '1', 'Ssend_init-1' => 'in:bufptr',
#    'Rsend_init' => '1', 'Rsend_init-1' => 'in:bufptr',
#    'Recv_init' => '1', 'Recv_init-1' => 'in:bufptr',
#    'Sendrecv' => '1:6', 'Sendrecv-1' => 'in:bufptr', 'Sendrecv-6' => 'in:bufptr',
#    'Sendrecv_replace' => '1', 'Sendrecv_replace-1' => 'in:bufptr',
    'Test_cancelled' => '2', 'Test_cancelled-2' => 'out:logical',
    'Test' => '2', 'Test-2' => 'out:logical',
    'Testall' => '3', 'Testall-3' => 'out:logical',
    'Testany' => '3:4', 'Testany-4' => 'out:logical',
    'Testany-3' => 'out:index',
    'Testsome' => '4', 'Testsome-4' => 'out:index_array:*v3',
    'Type_set_name' => '2', 'Type_set_name-2' => 'in:addnull',
    'Waitany' => '3', 'Waitany-3' => 'out:index',
    'Waitsome' => '4', 'Waitsome-4' => 'out:index_array:*v3'
    );

$arg_string = join( ' ', @ARGV );
if ($build_prototypes) {
    open( PROTOFD, ">fproto.h" ) || die "Cannot open fproto.h\n";
    print PROTOFD "/* -*- Mode: C; c-basic-offset:4 ; -*- */\
/*  \
 *  (C) 2001 by Argonne National Laboratory.\
 *      See COPYRIGHT in top-level directory.\
 *\
 * This file is automatically generated by buildiface $arg_string\
 * DO NOT EDIT\
 */\
/* Prototypes for Fortran Interface Functions */\n";
}

open( FD, "<../../include/mpi.h.in" ) || die "Cannot open mpi.h.in\n";

# Skip to prototypes
while (<FD>) {
    if ( /\/\*\s*Begin Prototypes/ ) { last; }
}

# Read each one
while (<FD>) {
    if (/\/\*\s*End Prototypes/ ) { last; }
    if (/^int\s*MPI_([A-Z][a-z0-9_]*)\s*\((.*)/) {
	$routine_name = $1;
	$args = $2;
	while (! ($args =~ /;/)) {
	    $args .= <FD>;
	}
	$args =~ s/\)\s*;//g;
	$args =~ s/[\r\n]*//g;
	$lcname = lc($routine_name);
	# Eventually, we'll create a new file here.  
	# For C++, we may create similar files by looking up 
	# the corresponding routines.
	if (defined($special_routines{$routine_name})) {
	    print "Skiping $routine_name\n" if $debug;
	}
	else {
	    # Check for duplicates in the list of routines
	    if (defined($mpi_routines{$routine_name})) {
		print STDERR "Duplicate prototypes for $routine_name\n";
	    }
	    # Clear variables
	    $clean_up = "";
	    &clean_args;
	    $mpi_routines{$routine_name} = $args;
	    if ($buildfiles) {
		if (defined($name_map{$lcname})) {
		    $filename = $name_map{$lcname} . "f.c";
		}
		else {
		    $filename = $lcname . "f.c";
		}
		$OUTFD = OUTPUTFILED;   # Needed for pre 5.6 versions of perl
		open ($OUTFD, ">$filename" ) || die "Cannot open $filename\n";
		# Add the name to the list of files"
		$files[$#files+1] = $filename;
	    }
	    else {
		$OUTFD = STDOUT;
	    }
	    &print_header( $routine_name, $lcname );
	    if ($do_subdecls) {
		print $OUTFD "FORTRAN_API void FORT_CALL ";
	    }
	    else {
		print $OUTFD "void ";
	    }
	    print $OUTFD "mpi_${lcname}_ ";
	    # Print args not only prints the arguments but fills the
	    # array @arg_addresses to indicate the number of dereference
	    # operations are needed to recover the original value (since
	    # all Fortran parameters are passed either by value-result or
	    # by reference, many value parameters in the C calls are 
	    # replaced by reference parameters in the Fortran interface.
	    &print_args( $OUTFD, $args );

	    &print_attr;
	    print $OUTFD "{\n";
	    &print_special_decls( $routine_name );
	    print $OUTFD "    *ierr = MPI_$routine_name";
	    &print_call_args( $args );
	    # Print any post call processing
	    &print_post_call( $routine_name, $args );
	    print $OUTFD "}\n";
	    if ($buildfiles) {
		close ($OUTFD);
	    }
	    if ($build_prototypes) {
		if ($do_subdecls) {
		    print PROTOFD "FORTRAN_API void FORT_CALL mpi_${lcname}_ ";
		}
		else {
		    print PROTOFD "void mpi_${lcname}_ ";
		}
		&print_args( PROTOFD, $args );
		print PROTOFD ";\n";
	    }
	}
    }
}
# Build the special routines
&build_specials;

#
# This block can be used to create the Makefile
open ( MAKEFD, ">Makefile.sm" ) || die "Cannot create Makefile.sm";
print MAKEFD "# DO NOT EDIT\n# This file created by buildiface $arg_string\n";
# This line is unfortunately necessary to ensure that a working
# autoconf is used.
print MAKEFD "smvar_autoconf = /home/gropp/bin/linux/autoconf\n";
#print MAKEFD "smvar_debug = 1\n";
print MAKEFD "smvar_do_dependencies = 0\n";
&print_line(  MAKEFD, "mpi_sources = ", 80, "\\\n\t", 8 );
for ($i=0; $i<=$#files; $i++) {
    $name = $files[$i];
    &print_line( MAKEFD, "$name ", 80, "\\\n\t", 8 );
}
&print_endline( MAKEFD );

print MAKEFD "lib\${MPILIBNAME}_a_SOURCES = \${mpi_sources}\
\
profilelib_\${MPILIBNAME} = p\${MPILIBNAME}\
INCLUDES = -I../../include -I\${top_srcdir}/src/include\
maint-clean:\
\trm -f \${mpi_sources} fproto.h\n";

close( MAKEFD );

#
# ------------------------------------------------------------------------
# Procedures
# print_line( FD, line, count, continue, continuelen )
# Print line to FD; if line size > count, output continue string and
# continue.  Use print_endline to finish a line
sub print_line {
    my $FD = $_[0];
    my $line = $_[1];
    my $count = $_[2];
    my $continue = $_[3];
    my $continue_len = $_[4];
    
    $linelen = length( $line );
    #print "linelen = $linelen, print_line_len = $print_line_len\n";
    if ($print_line_len + $linelen > $count) {
	print $FD $continue;
	$print_line_len = $continue_len;
    }
    print $FD $line;
    $print_line_len += $linelen;
}
sub print_endline {
    my $FD = $_[0];
    print $FD "\n";
    $print_line_len = 0;
}

# Print the header of the file, containing the definitions etc.
sub print_header {
    my $routine_name = $_[0];
    my $lcname = $_[1];
    print $OUTFD "/* -*- Mode: C; c-basic-offset:4 ; -*- */\
/*  \
 *  (C) 2001 by Argonne National Laboratory.\
 *      See COPYRIGHT in top-level directory.\
 *\
 * This file is automatically generated by buildiface $arg_string\
 * DO NOT EDIT\
 */\
#include \"mpi_fortimpl.h\"\n\n";

    &print_profiling_block( $routine_name, $lcname );
    &print_name_map_block( $routine_name, $lcname );
}

#
# Print the (ugly) profiling name definition block.
sub print_profiling_block {
    my $routine_name = $_[0];
    my $lcname = $_[1];
    my $ucname = uc($lcname);

    if ($do_weak) {
	print $OUTFD "\
/* Begin MPI profiling block */\
#if defined(HAVE_WEAK_SYMBOLS)\
#if defined(HAVE_PRAGMA_WEAK)\

#if defined(F77_NAME_UPPER)\
#pragma weak MPI_$ucname = PMPI_$ucname\
#elif defined(F77_NAME_LOWER_2USCORE)\
#pragma weak mpi_${lcname}__ = pmpi_${lcname}__\
#elif !defined(F77_NAME_LOWER_USCORE)\
#pragma weak mpi_$lcname = pmpi_$lcname\
#else\
#pragma weak mpi_${lcname}_ = pmpi_${lcname}_\
#endif\
\
#elif defined(HAVE_PRAGMA_HP_SEC_DEF)\
#if defined(F77_NAME_UPPER)\
#pragma _HP_SECONDARY_DEF PMPI_$ucname  MPI_$ucname\
#elif defined(F77_NAME_LOWER_2USCORE)\
#pragma _HP_SECONDARY_DEF pmpi_${lcname}__  MPI_${ucname}__\
#elif !defined(F77_NAME_LOWER_USCORE)\
#pragma _HP_SECONDARY_DEF pmpi_$lcname  mpi_$ucname\
#else\
#pragma _HP_SECONDARY_DEF pmpi_${lcname}_  mpi_${ucname}_\
#endif\
\
#elif defined(HAVE_PRAGMA_CRI_DUP)\
#if defined(F77_NAME_UPPER)\
#pragma _CRI duplicate MPI_$ucname as PMPI_$ucname\
#elif defined(F77_NAME_LOWER_2USCORE)\
#pragma _CRI duplicate mpi_${lcname}__ as pmpi_${lcname}__\
#elif !defined(F77_NAME_LOWER_USCORE)\
#pragma _CRI duplicate mpi_${lcname} as pmpi_${lcname}\
#else\
#pragma _CRI duplicate mpi_${lcname}_ as pmpi_${lcname}_\
#endif\
#endif /* HAVE_PRAGMA_WEAK */\
#endif /* HAVE_WEAK_SYMBOLS */\
/* End MPI profiling block */\n\n";
    }
}

#
# Print the code that modifies the name
# The function prototypes must be loaded *after* the name block so that the
# name used in the function prototypes will match the one that is declared
# in this file.
sub print_name_map_block {
    my $routine_name = $_[0];
    my $lcname = $_[1];
    my $ucname = uc($lcname);
    
    # This include the code to map names for the profiling interface,
    # using the same macro as for the rest of the MPI code
    print $OUTFD "
/* Map the name to the correct form */
#ifndef MPICH_MPI_FROM_PMPI
#ifdef F77_NAME_UPPER
#define mpi_${lcname}_ PMPI_${ucname}
#elif defined(F77_NAME_LOWER_2USCORE)
#define mpi_${lcname}_ pmpi_${lcname}__
#elif !defined(F77_NAME_LOWER_USCORE)
#define mpi_${lcname}_ pmpi_${lcname}
#else
#define mpi_${lcname}_ pmpi_${lcname}_
#endif

#else
#ifdef F77_NAME_UPPER
#define mpi_${lcname}_ MPI_${ucname}
#elif defined(F77_NAME_LOWER_2USCORE)
#define mpi_${lcname}_ mpi_${lcname}__
#elif !defined(F77_NAME_LOWER_USCORE)
#define mpi_${lcname}_ mpi_${lcname}
/* Else leave name alone */
#endif

#endif /* MPICH_MPI_FROM_PMPI */

/* Prototypes for the Fortran interfaces */
#include \"fproto.h\"
";
}

# Print the arguments for the routine DEFINITION.
sub print_args { 
    my @parms = split(/\s*,\s*/, $_[1] );
    my $OUTFD = $_[0];
    my $count = 1;
    my $last_args = "";

    # Clear the @arg_addresses array.
    $#arg_addresses = 0;

    # Special case: if the only parm is "void", remove it from the list
    print STDERR "Nparms = $#parms, parms = " . join(',',@parms) . "\n" if $debug;
    if ($#parms == 0 && $parms[0] eq "void") {
	$#parms = -1;
    }
    print $OUTFD "( ";
    foreach $parm (@parms) {
	# Match type to replacement
	print "parm = :$parm:\n" if $debug;
	# Remove blanks from the parm
	$parm =~ s/\s//;
	if ($parm =~ /char\s*\*/) {
	    # char's go out at char *v FORT_MIXED_LEN(d) 
	    # and FORT_END_LEN(d) at the end
	    # FORT_END_LEN and FORT_MIXED_LEN contain the necessary comman
	    # if they are prsent at all.
	    print $OUTFD "char *v$count FORT_MIXED_LEN(d$count), ";
	    $last_args .= "FORT_END_LEN(d$count) ";
	}
	elsif ($parm =~/\[/) {
	    # Argument type is array, so we need to 
	    #  a) mark as containing a star
	    #  b) place parameter correctly
	    $star_count = 1;
	    $arg_addresses[$count] = $star_count;
	    # Split into raw type and []
	    $parm =~ /\s*([^\s]*)\s*(\[\s*\])/;
	    $basetype = $1;
	    $foundbrack = $2;
	    if (defined($tof77{$basetype})) {
		$nstar_before = ($basetype =~ /\*/);
		$basetype = $tof77{$basetype};
		$nstar_after = ($basetype =~ /\*/);
		if ($nstar_before != $nstar_after) {
		    $star_count++;
		}
	    }
	    print $OUTFD "$basetype v$count\[\], ";
	}
	else {
	    $nstar_before = ($parm =~ /\*/);
	    $nstar_after = $nstar_before;
	    print "Nstar = $nstar\n" if $debug;
	    if (defined($tof77{$parm})) {
		$parm = $tof77{$parm};
		$nstar_after = ($parm =~ /\*/);
	    }
	    print $OUTFD "${parm}v$count, ";
	    $star_count = 0;
	    if ($nstar_before != $nstar_after) {
		$star_count = 1;
	    }
	    $arg_addresses[$count] = $star_count;
	}
	$count++;
    }
    # Add the new error return code
    print $OUTFD "MPI_Fint *ierr ${last_args}";
    print $OUTFD ")\n";
}

# Print the arguments for the routine CALL.  
# Handle the special arguments
sub print_call_args {
    my @parms = split(/\s*,\s*/, $_[0] );
    my $count = 1;
    my $first = 1;
    print $OUTFD "( ";
    # Special case: if the only parm is "void", remove it from the list
    if ($#parms == 0 && $parms[0] eq "void") {
	$#parms = -1;
    }

    foreach $parm (@parms) {
	if (!$first) { print $OUTFD ", "; } else { $first = 0; }

	if (defined($special_args{"${routine_name}-$count"})) {
	    # We must handle this argument specially
	    &print_special_call_arg( $routine_name, $count );
	}
	else {
	    # Convert to/from object type as required.  
	    if (defined($argsneedcast{$parm})) {
		$argval = "v$count";
		if ($arg_addresses[$count] > 0) {
		    $argval = "*$argval";
		}
		$callparm = $argsneedcast{$parm};
		$callparm =~ s/ARG/$argval/;
		print $OUTFD "$callparm";
	    }
	    else {
		# Since MPICH objects are ints, we don't need to do 
		# anything unless MPI_Fint and int are different.
# print STDERR "XXX $count $#arg_addresses XXX\n";
		if ($arg_addresses[$count] > 0) {
		    print $OUTFD "*";
		}
		print $OUTFD "v$count";
	    }
	}
	$count++;
    }
    print $OUTFD " );\n";
}

# Print the option function attribute; this supports GCC, particularly 
# the __atribute__ weak option.
sub print_attr {
    if ($do_weak) {
	print $OUTFD "FUNC_ATTRIBUTES\n";
    }
}

#
# Special processing
# Buffer pointers
sub bufptr_ftoc {
}
sub bufptr_in_decl {
    my $count = $_[0];
}
sub bufptr_in_arg {
    my $count = $_[0];
    if ($do_bufptr) {
	print $OUTFD "MPIR_F_PTR(v$count)";
    }
    else {
	print $OUTFD "v$count";
    }
}
# bufptr_ctof( cvar, fvar )
sub bufptr_ctof {
    my $coutvar = $_[0];
    my $outvar  = $_[1];
}
# Logical variables
sub logical_ftoc {
}
sub logical_in_decl {
    my $count = $_[0];
    if ($do_logical) {
	print $OUTFD "    int l$count;\n";
    }
}
sub logical_in_arg {
    my $count = $_[0];
    if ($do_logical) {
	print $OUTFD "l$count";
    }
    else {
	print $OUTFD "v$count";
    }
}
# logical_ctof( cvar, fvar )
sub logical_ctof {
    my $coutvar = $_[0];
    my $outvar  = $_[1];
    if ($do_logical) {
	print $OUTFD "    *$outvar = MPIR_TO_FLOG($coutvar);\n";
    }
}
sub logical_out_decl {
    my $count = $_[0];
    if ($do_logical) {
	print $OUTFD "    int l$count;\n";
    }
}
sub logical_out_arg {
    my $count = $_[0];
    if ($do_logical) {
	print $OUTFD "\&l$count";
    }
    else {
	print $OUTFD "v$count";
    }
}
#
# Logical variables, but for an array.  
# Array args can use the global $Array_size and $Array_typedef if necessary
sub logical_array_ftoc {
    print $OUTFD "\
    {int li; 
     for (li=0; li<$Array_size; li++) {
        l$count\[li\] = MPIR_FROM_FLOG(v$count\[li\]);
     }
    }
";
}
sub logical_array_in_decl {
    my $count = $_[0];
    print $OUTFD "    int *l$count = (int *)malloc($Array_size * sizeof(int));\n";
}
sub logical_array_in_arg {
    my $count = $_[0];
    print $OUTFD "l$count";
}

sub logical_array_ctof {
    my $coutvar = $_[0];
    my $outvar  = $_[1];
    print $OUTFD "\
    {int li;
     for (li=0; li<$Array_size; li++) {
        $outvar\[li\] = MPIR_TO_FLOG($outvar\[li\]);
     }
    }
";
}
sub logical_array_out_decl {
}
sub logical_array_out_arg {
    my $count = $_[0];
    print $OUTFD "v$count";
}
# 
# Index variables.
# Index variables are not optional, since the values of the variable
# are changed.
sub index_ftoc {
}
sub index_ctof {
    my $coutvar = $_[0];
    my $outvar  = $_[1];
    print $OUTFD "    *$outvar = (MPI_Fint)$coutvar;\n";
    print $OUTFD "    if ($coutvar >= 0) *$outvar = *$outvar + 1;\n";
}
sub index_out_decl {
    my $count = $_[0];
    print $OUTFD "    int l$count;\n";
}
sub index_out_arg {
    my $count = $_[0];
    print $OUTFD " \&l$count";
}
#
# Index variables, but for an array.  
# Array args can use the global $Array_size and $Array_typedef if necessary
sub index_array_ftoc {
}
sub index_array_ctof {
    my $coutvar = $_[0];
    my $outvar  = $_[1];
    print $OUTFD "\
    {int li;
     for (li=0; li<$Array_size; li++) {
        if ($outvar\[li\] >= 0) $outvar\[li\] += 1;
     }
    }
"
}
sub index_array_out_decl {
}
sub index_array_out_arg {
    my $count = $_[0];
    print $OUTFD "v$count";
}

# This is the routine that handles the post-call processing
sub print_post_call {
    my $routine_name = $_[0];
    my $args = $_[1];
    if (!defined($special_args{$routine_name})) { return; }
    # Erg.  Special processing
    foreach $count (split(/:/,$special_args{$routine_name})) {
	$rule = $special_args{"${routine_name}-$count"};
	($direction,$method,$Array_size) = split(/:/,$rule);
	print STDERR "$routine_name: dir = $direction, method = $method\n" if $debug;
	if ($direction eq "out") {
	    $processing_routine = "${method}_ctof";
	    &$processing_routine( "l$count", "v$count" );
	}
	if ($clean_up ne "") {
	    print $OUTFD $clean_up;
	}
    }
}

# Blankpad strings
sub blankpad_out_decl {
}
sub blankpad_out_arg {
    my $count = $_[0];
    print $OUTFD "v$count";
}
sub blankpad_ctof {
    my $coutvar = $_[0];
    my $outvar  = $_[1];
    
    # find the null character.  Replace with blanks from there to the
    # end of the string.  The declared lenght is given by a variable
    # whose name is derived from outvar
    $strlen = $outvar;
    $strlen =~ s/^v/d/;
    print $OUTFD "\
    {char *p = $outvar;
        while (*p) p++;
        while ((p-$outvar) < $strlen) { *p++ = ' '; }
    }
";
}

# Add null to input strings
# We must make a copy 
sub addnull_in_decl {
    my $count = $_[0];
    print $OUTFD "    char *p$count;\n";
}
sub addnull_in_arg {
    my $count = $_[0];
    print $OUTFD "p$count";
}
sub addnull_ftoc {
    my $count = $_[0];
    
    # Working backwards from the length argument, find the first 
    # nonblank character
    # end of the string.  The declared lenght is given by a variable
    # whose name is derived from outvar
    $strlen = "v$count";
    $strlen =~ s/^v/d/;
    print $OUTFD "\
    {char *p = v$count + $strlen - 1;
     int  li;
        while (*p == ' ') p--;
        p2 = (char *)malloc( p-v$count + 1 );
        for (li=0; li<(p-v$count); li++) { p$count\[li\] = v$count\[li\]; }
        p$count\[li\] = 0; 
    }
";
    $clean_up .= "    free( p$count );\n";
}

# This routine handles the special arguments in the *call*
sub print_special_call_arg {
    my $routine_name = $_[0];
    my $count = $_[1];

    $rule = $special_args{"${routine_name}-$count"};
    ($direction,$method,$Array_size) = split(/:/,$rule);

    $processing_routine = "${method}_${direction}_arg";
    &$processing_routine( $count );
}

# This routine prints any declarations that are needed 
sub print_special_decls {
    my $routine_name = $_[0];

    if (defined($special_args{$routine_name})) {
	# First do the declarations
	foreach $count (split(/:/,$special_args{$routine_name})) {
	    $rule = $special_args{"${routine_name}-$count"};
	    ($direction,$method,$Array_size) = split(/:/,$rule);
	    $processing_routine = "${method}_${direction}_decl";
	    &$processing_routine( $count );
	}
	# Then do the precall steps
	foreach $count (split(/:/,$special_args{$routine_name})) {
	    $rule = $special_args{"${routine_name}-$count"};
	    ($direction,$method,$Array_size) = split(/:/,$rule);
	    if ($direction eq "in") {
		$processing_routine = "${method}_ftoc";
		&$processing_routine( $count );
	    }
	}
    }
}

#
# --------------------------------------------------------------------------
# Create mpif.h.in from mpi.h
#

open ( MPIFD, "<../../include/mpi.h.in" ) || die "Could not open mpi.h.in\n";
#
# First, find the values that we need
while (<MPIFD>) {
    if (/#\s*define\s+(MPI_[A-Z_0-9]*)\s*([^\s]*)/) {
	$mpidef{$1} = $2;
    }
    elsif (/typedef\s+enum\s*{\s*(.*)/) {
	# Eat until we find the closing right brace
	$enum_line = $1;
	while (! ($enum_line =~ /}/)) { $enum_line .= <MPIFD>; }
	# Now process for names and values
	while ( ($enum_line =~ /\s*(MPI_[A-Z_0-9]*)\s*=\s*([a-fx0-9]*)(.*)/ ) ){
	    $mpidef{$1} = $2;
	    $enum_line = $3;
	    print "Defining $1 as $2\n" if $debug;
	}
	
    } 
}
close (MPIFD);
#
$cchar = "C";
open ( MPIFFD, ">mpif.h.in" ) || die "Could not open mpif.h.in\n";

sub print_mpif_int {
    my $key = $_[0];
    my $value = $mpidef{$key};
    # Remove any casts
    print "Input value = $value\n" if $debug;
    if ($value =~ /\(MPI/) {
	$value =~ s/\(MPI_[A-Za-z0-9]*\s*\)//;
	print "cast removal: $value\n" if $debug;
    }
    # Remove any surrounding ()
    if ($value =~ /\(\s*[-a-fx0-9]*\)/) {
	$value =~ s/\(\s*([-a-fx0-9]*)\s*\)/$1/;
	print "paren removal: $value\n" if $debug;
    }
    # Convert hex to decimal
    if ($value =~ /^0x[a-f\d]*/) {
	$value = hex $value;
	print "hex conversion: $value\n" if $debug;
    }
    print MPIFFD "       INTEGER $key\n";
    print MPIFFD "       PARAMETER ($key=$value)\n";
}

# Now, write out the file
print MPIFFD "$cchar      DO NOT EDIT
$cchar       This file created by buildiface $arg_string\n";
#
# Status elements
print MPIFFD "       INTEGER MPI_SOURCE, MPI_TAG, MPI_ERROR\n";
print MPIFFD "       PARAMETER (MPI_SOURCE=2,MPI_TAG=3,MPI_ERROR=4)\n";
print MPIFFD "       INTEGER MPI_STATUS_SIZE\n";
print MPIFFD "       PARAMETER (MPI_STATUS_SIZE=\@MPI_STATUS_SIZE\@)\n";
#
# Error Classes
print MPIFFD "       INTEGER MPI_SUCCESS\n";
print MPIFFD "       PARAMETER (MPI_SUCCESS=0)\n";
foreach $key (keys(%mpidef)) {
    if ($key =~ /MPI_ERR_/) {
	&print_mpif_int( $key );
    }
}
# Predefined error handlers
foreach $key (ERRORS_ARE_FATAL, ERRORS_RETURN) {
    &print_mpif_int( "MPI_$key" );
}
# Compare operations
foreach $key (IDENT,CONGRUENT,SIMILAR,UNEQUAL) {
    &print_mpif_int( "MPI_$key" );
}
# Collective operations
foreach $key (MAX, MIN, SUM, PROD, LAND, BAND, LOR, BOR, LXOR, BXOR, MINLOC, MAXLOC, REPLACE ) {
    &print_mpif_int( "MPI_$key" );
}
# Objects
foreach $key ('COMM_WORLD', 'COMM_SELF', 'GROUP_EMPTY', 'COMM_NULL', 'WIN_NULL', 'FILE_NULL', 'GROUP_NULL', 'OP_NULL', 'DATATYPE_NULL', 'REQUEST_NULL', 'ERRHANDLER_NULL') {
    &print_mpif_int( "MPI_$key" );
}
# Attributes
foreach $key (TAG_UB, HOST, IO, WTIME_IS_GLOBAL, UNIVERSE, LASTUSEDCODE, APPNUM) {
    &print_mpif_int( "MPI_$key" );
} 
# String sizes
# Missing - max processor name!
foreach $key (MAX_ERROR_STRING, MAX_NAME_STRING, MAX_PORT_NAME, MAX_OBJECT_NAME, MAX_INFO_KEY, MAX_INFO_VAL) {
    &print_mpif_int( "MPI_$key" );
}
# predefined constants
print MPIFFD "       INTEGER MPI_UNDEFINED, MPI_UNDEFINED_RANK\n";
print MPIFFD "       PARAMETER (MPI_UNDEFINED=$mpidef{'MPI_UNDEFINED'})\n";
# mpi_undefined_rank is defined as mpi-undefined
print MPIFFD "       PARAMETER (MPI_UNDEFINED_RANK=$mpidef{'MPI_UNDEFINED'})\n";
&print_mpif_int( "MPI_KEYVAL_INVALID" );
foreach $key ('BSEND_OVERHEAD', 'PROC_NULL', 'ANY_SOURCE', 'ANY_TAG', 'ROOT') {
    &print_mpif_int( "MPI_$key" );
}
#
# Topology types
foreach $key (GRAPH, CART) {
    &print_mpif_int( "MPI_$key" );
}
#
# version
&print_mpif_int( "MPI_VERSION" );
&print_mpif_int( "MPI_SUBVERSION" );
#
# Datatypes
# These are determined and set at configure time
foreach $key (COMPLEX, DOUBLE_COMPLEX, LOGICAL, REAL, DOUBLE_PRECISION, INTEGER, '2INTEGER', '2COMPLEX', '2DOUBLE_PRECISION', '2REAL', '2DOUBLE_COMPLEX', CHARACTER) {
    print MPIFFD "       INTEGER MPI_$key\n";
    print MPIFFD "       PARAMETER (MPI_$key=\@MPI_$key\@)\n";
}
# HACK!
# Value of MPI_BYTE from top level configure!
$mpidef{"MPI_BYTE"} = hex "0x4c000111";
&print_mpif_int( "MPI_BYTE" );
&print_mpif_int( "MPI_UB" );
&print_mpif_int( "MPI_LB" );
&print_mpif_int( "MPI_PACKED" );

# Optional types
foreach $key (INTEGER1, INTEGER2, INTEGER4, INTEGER8, INTEGER16,
              REAL4, REAL8, REAL16, COMPLEX8, COMPLEX16, COMPLEX32) {
    print MPIFFD "       INTEGER MPI_$key\n";
    print MPIFFD "       PARAMETER (MPI_$key=\@F77_$key\@)\n";
}
#
# Fortran 90 types
print MPIFFD "       INTEGER MPI_ADDRESS_KIND, MPI_OFFSET_KIND\n";
print MPIFFD "       PARAMETER (MPI_ADDRESS_KIND=\@ADDRESS_KIND\@)\n";
print MPIFFD "       PARAMETER (MPI_OFFSET_KIND=\@OFFSET_KIND\@)\n";
# 

close( MPIFFD );


#
# Look through $args for parameter names (foo\s\s*name)
# and remove them
sub clean_args {
    my $newargs = "";
    my $comma = "";
    for $parm (split(',',$args)) {
	if ( ($parm =~ /^\s*([A-Za-z0-9_]+)\s+[A-Za-z0-9_]+$/) ) {
	    $parm = $1;
	}
	elsif ( ($parm =~ /\s*([A-Za-z0-9_]+\s*\*)\s*[A-Za-z0-9_]+$/) ) {
	    $parm = $1;
	}
	elsif ( ($parm =~ /^\s+([^\s].*)\s*$/) ) {
	    $parm = $1;
	}
	$newargs .= "$comma$parm";
	$comma = ",";
    }
    print STDERR "$newargs\n" if $debug;
    $args = $newargs;
}

# print_type_decl( $FD, $lcname )

sub print_routine_type_decl {
    my $OUTFD = $_[0];
    my $lcname = $_[1];
    if ($do_subdecls) {
	print $OUTFD "FORTRAN_API void FORT_CALL ";
    }
    else {
	print $OUTFD "void ";
    }
    print $OUTFD "mpi_${lcname}_ ";
}

#
# Build the special routines
sub build_specials {
    # The init routine contains some configure-time values.
    # We may not want to do this if we are supporting multiple
    # Fortran compilers with different values for Fortran .TRUE. and
    # .FALSE., but to get started, this is easiest.
    $OUTFD = "INITFFD";
    open( $OUTFD, ">initf.c" ) || die "Cannot open initf.c\n";
    $files[$#files+1] = "initf.c";
    &print_header( "MPI_Init", "init" );
    # This is temporary.  Eventually, these should move into
    # support file.
    # Note that the global variables have values.  This is to work around
    # a bug in some C environments (e.g., Mac OS/X) that don't load
    # external symbols that don't have a value assigned at compile time 
    # (so called common symbols)
    print $OUTFD "
#if !defined(F77RUNTIME_VALUES) && defined(F77_TRUE_VALUE_SET)
const MPI_Fint MPIR_F_TRUE= F77_TRUE_VALUE, MPIR_F_FALSE= F77_FALSE_VALUE;
#else
MPI_Fint MPIR_F_TRUE = 1, MPIR_F_FALSE = 0;
#endif
";
    # This is also temporary.
    print $OUTFD "
void *MPIR_F_MPI_BOTTOM = 0;
";

    &print_routine_type_decl( $OUTFD, "init" );
    $args = "";
    &print_args( $OUTFD, $args );
    &print_attr;
    print $OUTFD "{\n";
    print $OUTFD "#ifndef F77RUNTIME_VALUES
    /* any compile/link time values go here */
#else
#   abort \"Fortran values must be determined at configure time\"
#endif
";
    print $OUTFD "    /* still to do MPI_BOTTOM, STATUS_NULL */\n";

    print $OUTFD "    *ierr = MPI_Init( 0, 0 );\n";
    # Still to do:
    #   Initialize the Fortran versions of the predefined keyvals.
    #   Find the value of MPI_BOTTOM.  
    #     Call a Fortran routine that calls a C routine that is passed
    #     MPI_BOTTOM from the common block.  
    #     
    print $OUTFD "}\n";
    close ($OUTFD);
    if ($build_prototypes) {
	&print_routine_type_decl( PROTOFD, "init" );
	&print_args( PROTOFD, $args );
	print PROTOFD ";\n";
    }
    
    $OUTFD = "PCONTROLFFD";
    open( $OUTFD, ">pcontrolf.c" ) || die "Cannot open pcontrolf.c\n";
    $files[$#files+1] = "pcontrolf.c";
    &print_header( "MPI_Pcontrol", "pcontrol" );
    &print_routine_type_decl( $OUTFD, "pcontrol" );
    $args = "int";
    &print_args( $OUTFD, $args );
    &print_attr;
    print $OUTFD "{\n";
    print $OUTFD "    *ierr = MPI_Pcontrol( (int)*v1 );\n";
    print $OUTFD "}\n";
    close ($OUTFD);
    if ($build_prototypes) {
	&print_routine_type_decl( PROTOFD, "pcontrol" );
	&print_args( PROTOFD, $args );
	print PROTOFD ";\n";
    }

    $OUTFD = "ADDRESSFFD";
    open ($OUTFD, ">addressf.c" ) || die "Cannot open addressf.c\n";
    $files[$#files+1] = "addressf.c";
    &print_header( "MPI_Address", "address" );
    &print_routine_type_decl( $OUTFD, "address" );
    $args = "void *, int *";
    &print_args( $OUTFD, $args );
    &print_attr;
    print $OUTFD "{
    MPI_Aint a, b;
    *ierr = MPI_Address( v1, &a );
    b = a - (MPI_Aint) MPIR_F_MPI_BOTTOM;
    *v2 = (MPI_Fint)( b );
#ifdef HAVE_AINT_LARGER_THAN_FINT
    /* Check for truncation */
    if (((MPI_Aint)*v2 - b != 0) {
        *ierr = MPIR_Err_create_code( MPI_ERR_ARG, \"inttosmall\", 0 );
	(void)MPIR_Err_return_comm( 0, \"MPI_Address\",  *ierr );
    }
#endif
}\n";
    close ($OUTFD);
    if ($build_prototypes) {
	&print_routine_type_decl( PROTOFD, "address" );
	&print_args( PROTOFD, $args );
	print PROTOFD ";\n";
    }
}
#
# ISSUES NOT YET HANDLED
# ----------------------------------------------------------------------------
# Fortran Integer conversion.
# If C ints and Fortran integers are not the same size, we have to do
# more.  In the case of arrays, we must make temporary copies.
# In MPICH1, there is also code for the case where the sizes of 
# the C and Fortran integers are not known.  Roughly, the code could look 
# like
# #ifdef HAVE_FINT_IS_INT
#   straight-forward code
# #else
# #ifdef HAVE_FINT_TYPE_UNKNOWN
# if (sizeof(int) == sizeof(MPI_Fint)) {
#  straight-forward code
# } else
# #endif
# {
#   code that converts arrays, calls routine, frees arrays
# }
# #endif
#
# There are several options for allocating the temporary arrays
# For some, like cartesian dimension arrays, it is reasonable to 
# use a predeclared array (and signal an error if too large)
# For the others, use a predeclared array with a special case
# for extra-large
#
# ----------------------------------------------------------------------------
# Character buffer handling for choice arguments
#  If Fortran passes character arrays as a pair of arguments (rather than
# putting the second argument at the end of the arg list), then all of the
# choice arg routines must check the *count* of the number of arguments, 
# and then, if there are too many args, assume that the choice buffer
# is a character.  Note that for Sendrecv, there is no unique
# solution unless you know more about the MPI datatypes.
# 
