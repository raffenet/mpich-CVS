# 
# Globus device code:          Copyright 2005 Northern Illinois University
# Borrowed MPICH-G2 code:      Copyright 2000 Argonne National Laboratory and Northern Illinois University
# Borrowed MPICH2 device code: Copyright 2001 Argonne National Laboratory
# 
# XXX: INSERT POINTER TO OFFICIAL COPYRIGHT TEXT
# 

# FIXME: this script assumes the build and target platforms are the same.  cross compilation support needs to be added for
# machines like IBM BG/L.

#
# NOTE: this file is sourced from the top-level configure script with the current working directory set to the top-level
# build directory.
#
# variables of potential interest...
#
# $master_top_srcdir - top-level source directory
# $master_top_builddir - top-level build directory
# $device_name - better be ch3
# $device_args - contains name of channel select plus an channel args
# $with_device - device name and arguments
# $ac_configure_args - all arguments passed to configure
#

echo ""
echo "START OF MPICH2PREREQ FOR THE GLOBUS DEVICE"

MPILIBNAME="mpig"
if test "$set_FWRAPNAME" != "yes" ; then
    FWRAPNAME="f${MPILIBNAME}"
fi

# # define to the address where bug reports for this package should be sent.
# PACKAGE_BUGREPORT="mpi@globus.org"
# export PACKAGE_BUGREPORT
# cat >>confdefs.h <<_ACEOF
# #define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
# _ACEOF
# 
# # define to the full name of this package.
# PACKAGE_NAME="MPI-G"
# export PACKAGE_NAME
# cat >>confdefs.h <<_ACEOF
# #define PACKAGE_NAME "$PACKAGE_NAME"
# _ACEOF
# 
# # define to the version of this package.
# if grep CVS ${master_top_srcdir}/maint/Version >/dev/null 2>&1 ; then
#     PACKAGE_VERSION=`date "+%Y%m%d%H%M"`
# else
#     PACKAGE_VERSION=`cat $master_top_srcdir/maint/Version`
# fi
# export PACKAGE_VERSION
# cat >>confdefs.h <<_ACEOF
# #define PACKAGE_VERSION "$PACKAGE_VERSION"
# _ACEOF
# 
# # define to the full name and version of this package.
# PACKAGE_STRING="${PACKAGE_NAME} ${PACKAGE_VERSION}"
# export PACKAGE_STRING
# cat >>confdefs.h <<_ACEOF
# #define PACKAGE_STRING "$PACKAGE_STRING"
# _ACEOF
# 
# # define to the one symbol short name of this package.
# PACKAGE_TARNAME="${PACKAGE_NAME}"
# export PACKAGE_TARNAME
# cat >>confdefs.h <<_ACEOF
# #define PACKAGE_TARNAME "$PACKAGE_TARNAME"
# _ACEOF

#
# mpig_mkdir_p()
#
# simulate "mkdir -p" since it is not available everywhere.  portions of this code were taken from confdb/aclocal.m4.
#
mpig_mkdir_p()
{(
    saveIFS="${IFS}"
    IFS="/"
    tmp_curdir=""
    for tmp_subdir in $1 ; do
        tmp_curdir="${tmp_curdir}${tmp_subdir}"
        if test -n "${tmp_curdir}" -a ! -d "${tmp_curdir}" ; then
	    mkdir "${tmp_curdir}"
	fi
        tmp_curdir="${tmp_curdir}/"
    done
    IFS="${saveIFS}"
)}

#
# verify that GLOBUS_LOCATION points at a valid installation of globus
#
if test -z "${GLOBUS_LOCATION}" ; then
    echo ""
    echo "ERROR: the environment variable GLOBUS_LOCATION must be set before configuring"
    echo "       MPICH2 with the Globus device."
    echo ""
    exit 1
fi

if test ! -d "${GLOBUS_LOCATION}" ; then
    echo ""
    echo "ERROR: ${GLOBUS_LOCATION} does not exist."
    echo "       Please verify that the environment variable GLOBUS_LOCATION properly"
    echo "       specifies the location of your Globus installation."
    echo ""
    exit 1
fi

MPIG_GMH_CMD="${GLOBUS_LOCATION}/bin/globus-makefile-header"
if test ! -f "${MPIG_GMH_CMD}" ; then
    echo ""
    echo "ERROR: ${MPIG_GMH_CMD} does not exist."
    echo "       Globus may not be installed correctly."
    echo ""
    exit 1
fi

if test ! -x "${MPIG_GMH_CMD}" ; then
    echo ""
    echo "ERROR: ${MPIG_GMH_CMD} is not executable."
    echp "       Globus may not be installed correctly."
    echo ""
    exit 1
fi

#
# get configure options specific to the globus device
#
with_ccache=no
with_insure=no
enable_gcc_strict=no
MPIG_F77_SED=no

for arg in ${ac_configure_args} ; do
  arg=`echo ${arg} | sed -e 's/^'"'"'\(.*\)'"'"'$/\1/'`
  case ${arg} in
    --with-globus-flavor=*)
    with_globus_flavor=`echo ${arg} | sed 's/^[^=]*=//'`
    ;;
    # NOTE: doing sed replacement on f90 modules can cause problems.  we also believe that f77 programs may no longer require the
    # sed replacement mechanism, and instead can rely on library link order.  for now, we are disabling sed substition.
    # --with-f77-sed)
    # MPIG_F77_SED=yes
    # ;;
    --with-ccache)
    echo "INFO: ccache enabled"
    with_ccache=yes
    ;;
    --without-ccache)
    with_ccache=no
    ;;
    --with-insure)
    echo "INFO: building with Insure++"
    with_insure=yes
    ;;
    --without-insure)
    with_insure=no
    ;;
    --enable-gcc-strict)
    echo "INFO: compiling with super strict options"
    enable_gcc_strict=yes
    ;;
    --disable-gcc-strict)
    enable_gcc_strict=no
    ;;
  esac
done

if test -z "${with_globus_flavor}" ; then
    echo ""
    echo "ERROR: a flavor of Globus must be specified.  This is accomplished by adding the"
    echo "       --with-globus-flavor=<FLAVOR> to the configure command line."
    echo ""
    exit 1
fi

#
# if application level threads are enabled, then they must be disabled and the user warned.
#
# FIXME: eventually we should support application level threads, but this requires either a vendor MPI that supported
# MPI_THREAD_SERIALIZED or MPI_THREAD_MULTIPLE.  it would be possible to provide allow application level threads if the vendor
# MPI supported MPI_THREAD_FUNNELED; however, all vendor MPI operation would need to be routed through request and completion
# queues so that the MPI functions were called only by the main thread (the one that called MPI_Init_thread().
#
# NOTE: the standard states that if MPI_Init() is called, the it should be treated as MPI_Init_thread having been called with
# MPI_THREAD_SINGLE.  At present, MPI-G does not detect if MPI_Thread_init is available and thus always called MPI_Init().  As a
# result, MPI-G can only support MPI_THREAD_SINGLE.
#
echo "INFO: application thread level support requested: $enable_threads"
if test "$enable_threads" = "default" ; then
    echo "INFO: maximum application thread level support set to MPI_THREAD_SINGLE"
elif test "$enable_threads" != "single" ; then
    echo "WARNING: application thread support beyond MPI_THREAD_SINGLE has been"
    echo "         requested; however, MPI-G presently does not support multithreaded"
    echo "         applications.  The maximum thread level has been set to"
    echo "         MPI_THREAD_SINGLE."
fi
MPID_MAX_THREAD_LEVEL=MPI_THREAD_SINGLE

#
# the process management system is built into the device, so we must tell MPICH2 not to build a process manager or an
# implementation of the process management interface.
#
if test "${with_pmi}" != "no" -a "${with_pmi}" != "default" ; then
    echo "WARNING: the process management interface is not used by the Globus device."
    echo "         The ${with_pmi} implementation of PMI will not be built"
fi
if test "${with_pm}" != "no" -a "${with_pm}" != "default" ; then
    echo "WARNING: the process management system is built into the Globus device."
    echo "         The ${with_pm} process manager will not be built"
fi
with_pmi=no
with_pm=no

#
# add include paths needed by the Globus device
#
pathlist=""
pathlist="${pathlist} src/mpid/${device_name}"
pathlist="${pathlist} src/mpid/common/datatype"
for path in ${pathlist} ; do
    CPPFLAGS="${CPPFLAGS} -I${master_top_builddir}/${path}"
    CPPFLAGS="${CPPFLAGS} -I${master_top_srcdir}/${path}"
done

#
# create the device's build directory, if it doesn't already exist.  this is necessary for VPATH builds.
#
if test ! -d src/mpid/${device_name} ; then
    mpig_mkdir_p src/mpid/${device_name}
fi

#
# set variables to easily find the device in the source and build trees (may be the same)
#
MPIG_SOURCE_DIR=${master_top_srcdir}/src/mpid/${device_name}
MPIG_BUILD_DIR=${master_top_builddir}/src/mpid/${device_name}
export MPIG_SOURCE_DIR
export MPIG_BUILD_DIR

#
# create the makefile for extract settings from Globus
#
MPIG_GMH_PKGS="globus_xio globus_dc globus_duroc_runtime globus_rendezvous globus_usage"
MPIG_GLOBUS_HEADER_MK=${MPIG_BUILD_DIR}/.globus-header.mk
MPIG_GLOBUS_HEADER_ERR=${MPIG_BUILD_DIR}/.globus-header.mk
MPIG_GLOBUS_SETTINGS_MK_IN=${MPIG_SOURCE_DIR}/globus-settings.mk.in
MPIG_GLOBUS_SETTINGS_MK=${MPIG_BUILD_DIR}/globus-settings.mk
echo ${ECHO_N} "collecting information from Globus via globus-makefile-header... ${ECHO_C}"
${MPIG_GMH_CMD} --flavor=${with_globus_flavor} ${MPIG_GMH_PKGS} >${MPIG_GLOBUS_HEADER_MK} 2>${MPIG_GLOBUS_HEADER_ERR}
if test $? -ne 0 ; then
    echo "${ECHO_T}failed!"
    echo ""
    cat ${MPIG_GLOBUS_HEADER_ERR}
    echo ""
    if test ! -d ${GLOBUS_LOCATION}/etc/globus_core ; then
	echo "ERROR: MPI-G requires the globus_core module which is not included in the"
	echo "       binary distribution of Globus.  Please install globus_core using the"
	echo "       globus_core may need to be installed using the source package."
	echo ""
    fi
    echo ""
    rm -f ${MPIG_GLOBUS_HEADER_MK} ${MPIG_GLOBUS_HEADER_ERR}
    exit 1
fi
sed -e "/@MPIG_GLOBUS_HEADER_MK@/r ${MPIG_GLOBUS_HEADER_MK}" -e 's-@MPIG_GLOBUS_HEADER_MK@--' \
    <${MPIG_GLOBUS_SETTINGS_MK_IN} >${MPIG_GLOBUS_SETTINGS_MK}
    rm -f ${MPIG_GLOBUS_HEADER_MK} ${MPIG_GLOBUS_HEADER_ERR}
echo "${ECHO_T}done"

#
# function to extract globus settings from the previously created makefile
#
MPIG_MAKE=${MAKE:-make}
mpig_get_globus_setting()
{
    eval $1="\"`${MPIG_MAKE} -f ${MPIG_GLOBUS_SETTINGS_MK} $2 | sed -e 's/^ *//' -e 's/ *$//'`\""
    if test $? != 0 ; then
	echo ""
	echo "INTERNAL ERROR: ${MPIG_GLOBUS_SETTINGS_MK} does not contain the target \"$2\""
	echo ""
	exit 1
    fi
    #eval echo "\"$1 ($2) set to \${$1}\""
}

#
# Check MPICH2 Version
#
echo ${ECHO_N} "checking MPICH2 Version... ${ECHO_C}"
MPIG_MPICH2_VERSION=${VERSION}
echo "${ECHO_T}${MPIG_MPICH2_VERSION}"
export MPIG_MPICH2_VERSION

#
# are the required globus packages installed
#
echo ${ECHO_N} "checking if Globus XIO is installed... ${ECHO_C}"
mpig_get_globus_setting MPIG_GLOBUS_XIO_INSTALLED xio-installed
echo "${ECHO_T}${MPIG_GLOBUS_XIO_INSTALLED}"
export MPIG_GLOBUS_XIO_INSTALLED
if test "$MPIG_GLOBUS_XIO_INSTALLED" != "yes" ; then
    echo ""
    echo "ERROR: The Globus XIO module has not been installed for the specifed flavor"
    echo "       ${with_globus_flavor}.  This module is required.  Please install the"
    echo "       XIO module or select a different flavor for which the module has"
    echo "       already been installed."
    echo ""
    exit 1
fi

#
# check for the globus-xio package version 
#
echo ${ECHO_N} "checking version of Globus XIO... ${ECHO_C}"
mpig_get_globus_setting MPIG_XIO_VERSION xio-installed-version
echo "${ECHO_T}${MPIG_XIO_VERSION}"
export MPIG_XIO_VERSION
if test "$MPIG_XIO_VERSION" == "0.0" ; then
    echo ""
    echo "ERROR: The Globus XIO module version is invalid."
    echo ""
    exit 1
fi
   

echo ${ECHO_N} "checking if the Globus pre-WS job management modules are installed... ${ECHO_C}"
mpig_get_globus_setting MPIG_GLOBUS_DUROC_INSTALLED duroc-installed
echo "${ECHO_T}${MPIG_GLOBUS_DUROC_INSTALLED}"
export MPIG_GLOBUS_DUROC_INSTALLED

echo ${ECHO_N} "checking if the Globus WS job management modules are installed... ${ECHO_C}"
mpig_get_globus_setting MPIG_GLOBUS_RENDEZVOUS_INSTALLED rendezvous-installed
echo "${ECHO_T}${MPIG_GLOBUS_RENDEZVOUS_INSTALLED}"
export MPIG_GLOBUS_RENDEZVOUS_INSTALLED

if test "$MPIG_GLOBUS_DUROC_INSTALLED" != "yes" -a "$MPIG_GLOBUS_RENDEZVOUS_INSTALLED" != "yes" ; then
    echo ""
    echo "ERROR: Neither the Globus DUROC Runtime module nor the Globus Rendezvous"
    echo "       Client C bindings module have been installed for the specified flavor"
    echo "       ${with_globus_flavor}.  At least one of these modules is required."
    echo "       Please install one of these modules or select a different flavor for"
    echo "       which one of these modules has already been installed."
    echo ""
    exit 1
fi

#
# are the globus libraries multi-threaded?
#
echo ${ECHO_N} "checking if Globus is built with thread support... ${ECHO_C}"
mpig_get_globus_setting MPIG_GLOBUS_THREADED multi-threaded
echo "${ECHO_T}${MPIG_GLOBUS_THREADED}"
export MPIG_GLOBUS_THREADED

#
# are the globus libraries built with debugging enabled?  If so, enable debugging for the MPICH2 globus device.
#
echo ${ECHO_N} "checking if Globus is built with debugging enabled... ${ECHO_C}"
mpig_get_globus_setting MPIG_DEBUG debug
echo "${ECHO_T}${MPIG_DEBUG}"
if test "${MPIG_DEBUG}" = "no" ; then
    enable_fast=yes
    ac_configure_args="${ac_configure_args} --enable-fast"
    echo "INFO: debugging disabled.  adding --enable-fast option to remove error"
    echo "      checking from MPI routines and disable detailed error reporting."
fi
export MPIG_DEBUG

#
# determine whether or not we are using the vendor's MPI as one of our communication modules.  if we are, then we need to rename
# all of the publicly exposed symbols in MPICH2/MPI-G.  furthermore, we need to rename the MPI/PMPI symbols in the application
# code to match the symbols defined during the compilation of MPI-G.  for C/C++, this renaming process can be accomplished with a
# set of cpp macros in a header file included by mpi.h; however, fortran 77/90 can be more tricky.  in most cases, we can rely on
# order of the libraries supplied to the linker to insure that the fortran application links against the routines in the MPI-G
# library and not the routines supplied by the vendor MPI library.  however, while writing MPICH-G2, we discovered at least one
# system refused to link when the same symbols were defined by different two libraries.  because of this, we added a code to the
# fortran compiler scripts that ran the application code through a sed script, renaming all of the MPI/PMPI calls.  since this 
# substition process makes it harder for the application programmer to debug their code, not to mention that it causes problem
# with fortran 90 programs, it is our hope that this is no longer necessary.  we will readd the renaming of fortran symbols if
# necessary, but for now we only rename the C symbols since those are the only ones we use in the vendor MPI.
#
echo ${ECHO_N} "checking if Globus is built for use with a vendor MPI... ${ECHO_C}"
mpig_get_globus_setting MPIG_VMPI vmpi
echo "${ECHO_T}${MPIG_VMPI}"
export MPIG_VMPI

# NOTE: doing sed replacement on f90 modules can cause problems.  we also believe that f77 programs may no longer require the
# sed replacement mechanism, and instead can rely on library link order.  for now, we are disabling sed substition.
# if test ${MPIG_VMPI} = "no" ; then
#     MPIG_F77_SED=no
# fi
# if test ${MPIG_F77_SED} = "yes" ; then
#     echo "INFO: use of vendor MPI mode and F90 are incompatible.  Disabling F90 support."
#     enable_f90=no
#     ac_configure_args="${ac_configure_args} --disable-f90"
# 
#     # XXX: What is required by MPICH2 in order to rename f77/f90 symbols
#     HAVE_MPID_FORTDEFS_H=yes
#     export HAVE_MPID_FORTDEFS_H
# 
#     # XXX: where should these really be copied from and to?
#     # cp ${MPIG_SOURCE_DIR}/mpid_fortdefs.h ${builddir}/src/fortran/include
#     # cp ${MPIG_SOURCE_DIR}/mpid_fortdefs.h ${includebuild_dir}
# fi

#
# gather information about the libraries and linker flags
#
echo ${ECHO_N} "extacting library and linker flags from Globus... ${ECHO_C}"
mpig_get_globus_setting MPIG_LDFLAGS ldflags
mpig_get_globus_setting MPIG_LIBS libs
MPIG_TEST_LDFLAGS=${MPIG_LDFLAGS}
MPIG_TEST_LIBS=
echo "${ECHO_T}done"

#
# gather C compiler and linker information
#
echo ${ECHO_N} "extacting C compiler information from Globus... ${ECHO_C}"
mpig_get_globus_setting MPIG_CC cc
mpig_get_globus_setting MPIG_CFLAGS cflags
if test "${enable_gcc_strict}" = "yes" ; then
    MPIG_CC="${MPIG_CC} -ansi -D_XOPEN_SOURCE=500 -D_POSIX_C_SOURCE=200605"
fi
MPIG_BUILD_CC=${MPIG_CC}
MPIG_CLD=${MPIG_CC}
MPIG_TEST_CC=${MPIG_CC}
MPIG_TEST_CFLAGS=${MPIG_CFLAGS}
MPIG_TEST_CLD=${MPIG_CLD}
echo "${ECHO_T}done"

if test "${with_insure}" = "yes" ; then
    MPIG_CC="insure ${MPIG_CC}"
    MPIG_CLD="insure ${MPIG_CLD} -Zsl"
    MPIG_BUILD_CC="insure ${MPIG_BUILD_CC}"
fi

if test "${with_ccache}" = "yes" ; then
    MPIG_BUILD_CC="ccache ${MPIG_BUILD_CC}"
fi

if test "${enable_gcc_strict}" = "yes" ; then
    CPPFLAGS="${CPPFLAGS} -DMPIG_BUILDING_MPICH2"
    MPIG_BUILD_CFLAGS=`echo ${MPIG_CFLAGS} | sed 's/-I/-isystem /'`
    MPIG_BUILD_CFLAGS="${MPIG_BUILD_CFLAGS} -Wall -Wstrict-prototypes -Wmissing-prototypes -Wunused -Wshadow"
    MPIG_BUILD_CFLAGS="${MPIG_BUILD_CFLAGS} -Wmissing-declarations -Wcast-align -Wno-long-long -Wpointer-arith"
    MPIG_BUILD_CFLAGS="${MPIG_BUILD_CFLAGS} -Wconversion -Wsign-compare -Wwrite-strings"
fi

#
# gather C++ compiler and flags information
#
if test "${enable_cxx}" != "no" ; then
    echo ${ECHO_N} "extacting C++ compiler information from Globus... ${ECHO_C}"
    mpig_get_globus_setting MPIG_CXX cxx
    mpig_get_globus_setting MPIG_CXXFLAGS cxxflags
    MPIG_CXXLD=${MPIG_CXX}
    MPIG_TEST_CXX=${MPIG_CXX}
    MPIG_TEST_CXXFLAGS=${MPIG_CXXFLAGS}
    MPIG_TEST_CXXLD=${MPIG_CXXLD}
    MPIG_BUILD_CXX=${MPIG_CXX}
    echo "${ECHO_T}done"

    if test "${with_insure}" = "yes" ; then
	MPIG_CXX="insure ${MPIG_CXX}"
	MPIG_CXXLD="insure ${MPIG_CXXLD} -Zsl"
	MPIG_BUILD_CXX="insure ${MPIG_BUILD_CXX}"
    fi

    if test "${with_ccache}" = "yes" ; then
	MPIG_BUILD_CXX="ccache ${MPIG_BUILD_CXX}"
    fi

    if test -z "${MPIG_CXX}" ; then
	echo "INFO: C++ compiler not defined by Globus.  Disabling C++ subsystem."
	enable_cxx=no
	ac_configure_args="${ac_configure_args} --disable-cxx"
    fi
else
    echo "INFO: C++ subsystem disabled.  Skipping extraction of C++ information from Globus."
fi

#
# gather F77 compiler and flags information
#
if test "${enable_f77}" != "no" ; then
    echo ${ECHO_N} "extacting F77 compiler information from Globus... ${ECHO_C}"
    mpig_get_globus_setting MPIG_F77 f77
    mpig_get_globus_setting MPIG_F77FLAGS f77flags
    MPIG_F77LD=${MPIG_F77}
    MPIG_TEST_F77=${MPIG_F77}
    MPIG_TEST_F77FLAGS=${MPIG_F77FLAGS}
    MPIG_TEST_F77LD=${MPIG_F77LD}
    echo "${ECHO_T}done"

    if test -z "${MPIG_F77}" ; then
	echo "INFO: F77 compiler not defined by Globus.  Disabling F77 subsystem."
	enable_f77=no
	ac_configure_args="${ac_configure_args} --disable-f77"
    fi
else
    echo "INFO: F77 subsystem disabled.  Skipping extraction of F77 information from Globus."
fi

#
# gather F90 compiler and linker information
#
if test "${enable_f90}" != "no" ; then
    echo ${ECHO_N} "extacting F90 compiler information from Globus... ${ECHO_C}"
    mpig_get_globus_setting MPIG_F90 f90
    mpig_get_globus_setting MPIG_F90FLAGS f90flags
    MPIG_F90LD=${MPIG_F90}
    MPIG_TEST_F90=${MPIG_F90}
    MPIG_TEST_F90FLAGS=${MPIG_F90FLAGS}
    MPIG_TEST_F90LD=${MPIG_F90LD}
    echo "${ECHO_T}done"

    if test -z "${MPIG_F90}" ; then
	echo "INFO: F90 compiler not defined by Globus.  Disabling F90 subsystem."
	enable_f90=no
	ac_configure_args="${ac_configure_args} --disable-f90"
    fi
else
    echo "INFO: F90 subsystem disabled.  Skipping extraction of F90 information from Globus."
fi

#
# some MPI compilers, like IBM's mpcc, are effectively cross compilers.  for these compilers, we need to define things so that the
# compiler produces configuration test codes that can be executed locally.  obviously, using this technique, we are making the
# assumption that the host platform and the target platform are the same.  if they are different, then the configure code is going
# to detect the wrong features and values.  The only way to solve this problem in general is to make configure understand how to
# run on the target machine or have the user supply all of the necessary values, both of which are painful (for us and the users).
# for now, we assume that the code is being compiled on an identical platform.  someday, this script will need to be updated to
# allow the user to specify the parameters in a configuration file.
#
if test "${ARCH}" = "rs6000" -a ${MPIG_VMPI} = "yes" ; then
    if test "${globus_threads_enabled}" = "yes" ; then    
    	MPIG_TEST_CLD=xlc_r
    	MPIG_TEST_CXXLD=xlC_r
    	MPIG_TEST_F77LD=xlf_r
    	MPIG_TEST_F90LD=xlf90_r
    else
    	MPIG_TEST_CLD=xlc
    	MPIG_TEST_CXXLD=xlC
    	MPIG_TEST_F77LD=xlf
    	MPIG_TEST_F90LD=xlf90
    fi
fi

#
# when testing for architecure and operating systems features, we may need to use a different compiler options (or even a different
# compiler).  setting MPIG_CONFIGURE_ACTIVE forces the  compiler scripts to use these alternate settings.
#
MPIG_CONFIGURE_ACTIVE=1
export MPIG_CONFIGURE_ACTIVE

#
# create compiler scripts
#
sed -e "s!@GCC@!${MPIG_CC}!" \
    -e "s!@GCFLAGS@!${MPIG_CFLAGS}!" \
    -e "s!@GLD@!${MPIG_CLD}!" \
    -e "s!@GLDFLAGS@!${MPIG_LDFLAGS}!" \
    -e "s!@GLIBS@!${MPIG_LIBS}!" \
    -e "s!@TCC@!${MPIG_TEST_CC}!" \
    -e "s!@TCFLAGS@!${MPIG_TEST_CFLAGS}!" \
    -e "s!@TLD@!${MPIG_TEST_CLD}!" \
    -e "s!@TLDFLAGS@!${MPIG_TEST_LDFLAGS}!" \
    -e "s!@TLIBS@!${MPIG_TEST_LIBS}!" \
    -e "s!@BCC@!${MPIG_BUILD_CC}!" \
    -e "s!@BCFLAGS@!${MPIG_BUILD_CFLAGS}!" \
    ${MPIG_SOURCE_DIR}/mpich2-globus-cc.in >${MPIG_BUILD_DIR}/mpich2-globus-cc
chmod +x ${MPIG_BUILD_DIR}/mpich2-globus-cc

if test -n "${CC}" ; then
    echo "INFO: the Globus device provided a C compiler that differs with the one"
    echo "      specified in the CC envirnoment variable."
fi
CC=${MPIG_BUILD_DIR}/mpich2-globus-cc

if test "${enable_cxx}" != "no" ; then
    sed -e "s!@GCC@!${MPIG_CXX}!" \
    	-e "s!@GCFLAGS@!${MPIG_CXXFLAGS}!" \
    	-e "s!@GLD@!${MPIG_CXXLD}!" \
    	-e "s!@GLDFLAGS@!${MPIG_LDFLAGS}!" \
    	-e "s!@GLIBS@!${MPIG_LIBS}!" \
    	-e "s!@TCC@!${MPIG_TEST_CXX}!" \
    	-e "s!@TCFLAGS@!${MPIG_TEST_CXXFLAGS}!" \
    	-e "s!@TLD@!${MPIG_TEST_CXXLD}!" \
    	-e "s!@TLDFLAGS@!${MPIG_TEST_LDFLAGS}!" \
    	-e "s!@TLIBS@!${MPIG_TEST_LIBS}!" \
	-e "s!@BCC@!${MPIG_BUILD_CXX}!" \
	-e "s!@BCFLAGS@!${MPIG_CXXFLAGS}!" \
	${MPIG_SOURCE_DIR}/mpich2-globus-cc.in >${MPIG_BUILD_DIR}/mpich2-globus-cxx
    chmod +x ${MPIG_BUILD_DIR}/mpich2-globus-cxx

    if test -n "${CXX}" ; then
	echo "INFO: the Globus device provided a C++ compiler that differs with the one"
	echo "      specified in the CXX envirnoment variable."
    fi
    CXX=${MPIG_BUILD_DIR}/mpich2-globus-cxx
fi

if test "${enable_f77}" != "no" ; then
    sed -e "s!@GFC@!${MPIG_F77}!" \
    	-e "s!@GFFLAGS@!${MPIG_F77FLAGS}!" \
    	-e "s!@GLD@!${MPIG_F77LD}!" \
    	-e "s!@GLDFLAGS@!${MPIG_LDFLAGS}!" \
    	-e "s!@GLIBS@!${MPIG_LIBS}!" \
    	-e "s!@TFC@!${MPIG_TEST_F77}!" \
    	-e "s!@TFFLAGS@!${MPIG_TEST_F77FLAGS}!" \
    	-e "s!@TLD@!${MPIG_TEST_F77LD}!" \
    	-e "s!@TLDFLAGS@!${MPIG_TEST_LDFLAGS}!" \
    	-e "s!@TLIBS@!${MPIG_TEST_LIBS}!" \
    	-e "s!@F77_SED@!${MPIG_F77_SED}!" \
	${MPIG_SOURCE_DIR}/mpich2-globus-fc.in >${MPIG_BUILD_DIR}/mpich2-globus-f77
    chmod +x ${MPIG_BUILD_DIR}/mpich2-globus-f77

    if test -n "${F77}" ; then
	echo "INFO: the Globus device provided a F77 compiler that differs with the one"
	echo "      specified in the F77 envirnoment variable."
    fi
    F77=${MPIG_BUILD_DIR}/mpich2-globus-f77
fi

if test "${enable_f90}" != "no" ; then
    sed -e "s!@GFC@!${MPIG_F90}!" \
    	-e "s!@GFFLAGS@!${MPIG_F90FLAGS}!" \
    	-e "s!@GLD@!${MPIG_F90LD}!" \
    	-e "s!@GLDFLAGS@!${MPIG_LDFLAGS}!" \
    	-e "s!@GLIBS@!${MPIG_LIBS}!" \
    	-e "s!@TFC@!${MPIG_TEST_F90}!" \
    	-e "s!@TFFLAGS@!${MPIG_TEST_F90FLAGS}!" \
    	-e "s!@TLD@!${MPIG_TEST_F90LD}!" \
    	-e "s!@TLDFLAGS@!${MPIG_TEST_LDFLAGS}!" \
    	-e "s!@TLIBS@!${MPIG_TEST_LIBS}!" \
    	-e "s!@F77_SED@!${MPIG_F77_SED}!" \
	${MPIG_SOURCE_DIR}/mpich2-globus-fc.in >${MPIG_BUILD_DIR}/mpich2-globus-f90
    chmod +x ${MPIG_BUILD_DIR}/mpich2-globus-f90

    if test -n "${F90}" ; then
	echo "INFO: the Globus device provided a F90 compiler that differs with the one"
	echo "      specified in the F90 envirnoment variable."
    fi
    F90=${MPIG_BUILD_DIR}/mpich2-globus-f90
fi

#
# see if a type is defined
#
# usage: mpig_check_type type
#
mpig_check_type()
{
    mpig_type=$1
    if echo "${mpig_type}" | grep '^MPI_' >/dev/null 2>&1 ; then
        mpig_type_name="V${mpig_type}"
	mpig_include_mpi_h="#include <mpi.h>"
    else
        mpig_type_name="${mpig_type}"
	mpig_include_mpi_h=""
    fi
    cat >conftest.c <<EOF
#include <stdio.h>
${mpig_include_mpi_h}
int main(int argc, char ** argv)
{
    printf("%d\n", sizeof(${mpig_type}));
    return 0;
}
EOF
    # FIXME: output details to config.log
    echo ${ECHO_N} "checking for definition of ${mpig_type_name}""... ${ECHO_C}"
    mpig_var=`echo HAVE_${mpig_type_name} | sed -e 's/\*/P/' | tr "[a-z] " "[A-Z]_"`
    if ${CC} -c conftest.c >/dev/null 2>&1; then
	mpig_result=yes
	eval ${mpig_var}=yes
    else
	mpig_result=no
	eval ${mpig_var}=no
    fi
    eval export ${mpig_var}
    echo "${ECHO_T}${mpig_result}"
    rm -f conftest*
}

#
# determine the size of a type
#
# usage: mpig_get_type_size type
#
mpig_get_type_size()
{
    mpig_type=$1
    if echo "${mpig_type}" | grep '^MPI_' >/dev/null 2>&1 ; then
        mpig_type_name="V${mpig_type}"
	mpig_include_mpi_h="#include <mpi.h>"
    else
        mpig_type_name="${mpig_type}"
	mpig_include_mpi_h=""
    fi
    cat >conftest.c <<EOF
#include <stdio.h>
${mpig_include_mpi_h}
int main(int argc, char ** argv)
{
    printf("%d\n", sizeof(${mpig_type}));
    return 0;
}
EOF
    echo ${ECHO_N} "checking size of ${mpig_type_name}""... ${ECHO_C}"
    # FIXME: output details to config.log
    if ${CC} -o conftest conftest.c >/dev/null 2>&1; then
        mpig_result=`./conftest`
	echo "${ECHO_T}""${mpig_result}"
    else
	mpig_result=0
	echo "${ECHO_T}""nonexistent type"
    fi
    rm -f conftest*
    mpig_var=`echo "SIZEOF_${mpig_type_name}" | sed -e 's/\*/P/' | tr "[a-z] " "[A-Z]_"`
    eval ${mpig_var}=${mpig_result}
    eval export ${mpig_var}
}

#
# get the memory alignment for a type
#
# mpig_get_type_memalign type
#
mpig_get_type_memalign()
{
    mpig_type=$1
    if echo "${mpig_type}" | grep '^MPI_' >/dev/null 2>&1 ; then
        mpig_type_name="V${mpig_type}"
	mpig_include_mpi_h="#include <mpi.h>"
    else
        mpig_type_name="${mpig_type}"
	mpig_include_mpi_h=""
    fi
    cat >conftest.c <<EOF
#include <stdio.h>
${mpig_include_mpi_h}
int main(int argc, char ** argv)
{
    struct
    {
        char foo;
        $1 bar;
    } baz;
    printf("%d\n", ((char *) &baz.bar) - ((char *) &baz.foo));
    return 0;
}
EOF
    # FIXME: output details to config.log
    echo ${ECHO_N} "checking memory alignment for ${mpig_type_name}""... ${ECHO_C}"
    if ${CC} -o conftest conftest.c >/dev/null 2>&1; then
        mpig_result=`./conftest`
	echo "${ECHO_T}""${mpig_result}"
    else
	mpig_result=0
	echo "${ECHO_T}""nonexistent type"
    fi
    rm -f conftest*
    mpig_var=`echo "MEMALIGN_${mpig_type_name}" | sed -e 's/\*/P/' | tr "[a-z] " "[A-Z]_"`
    eval ${mpig_var}=${mpig_result}
    eval export ${mpig_var}
}

#
# determine the size of the basic C types
#
SIZEOF_UNKNOWN=0
for mpig_type in "char" "short" "int" "long" "long long" ; do
    mpig_get_type_size "$mpig_type"
    mpig_type_name=`echo "${mpig_type}" | sed -e 's/\*/P/' | tr "[a-z] " "[A-Z]_"`
    eval SIZEOF_UNSIGNED_${mpig_type_name}=\${SIZEOF_${mpig_type_name}}
    eval export SIZEOF_UNSIGNED_${mpig_type_name}
done
mpig_get_type_size "float"
mpig_get_type_size "double"
mpig_get_type_size "long double"
mpig_get_type_size "void *"

#
# determine maximum sized type for memory alignment purposes.  the alignment information is used to construct properly aligned
# buffers to prevent compiler alignment warnings and runtime faults.  it is also used below to construct the space required to 
# store the vendor MPI status in the MPICH2 MPI_Status structure.  since that structure is created in the top-level configure
# before the globus device localdefs file is run (which is generated by the globus device configure), the alighnment information
# must be gathered here rather than in configure.
#
TYPEOF_MPIG_ALIGNED_T=""
SIZEOF_MPIG_ALIGNED_T=0
# MEMALIGN_MPIG_ALIGNED_T=0
mpig_memalign_max=0
for mpig_type in "char" "short" "int" "long" "long long" "float" "double" "long double" "void *"; do
    mpig_get_type_memalign "$mpig_type"
    mpig_utype=`echo "${mpig_type}" | sed -e 's/\*/P/' | tr "[a-z] " "[A-Z]_"`
    eval mpig_memalign="\$MEMALIGN_${mpig_utype}"
    if test ${mpig_memalign} -gt ${mpig_memalign_max} ; then
        TYPEOF_MPIG_ALIGNED_T=${mpig_type}
        eval SIZEOF_MPIG_ALIGNED_T="\$SIZEOF_${mpig_utype}"
        # MEMALIGN_MPIG_ALIGNED_T=${mpig_memalign}
        mpig_memalign_max=${mpig_memalign}
    fi
done
echo "required memory alignment boundary is... ${mpig_memalign_max}"
echo "setting memory alignment type to... ${TYPEOF_MPIG_ALIGNED_T}"
# echo "setting size of memory alignment type to ${SIZEOF_MPIG_ALIGNED_T}"
export TYPEOF_MPIG_ALIGNED_T
export SIZEOF_MPIG_ALIGNED_T
# export MEMALIGN_MPIG_ALIGNED_T

#
# create a mapping from integer types to printf integer conversion length modifiers
#
MPIG_CHAR_FMT_MOD="hh"
export MPIG_CHAR_FMT_MOD
MPIG_UNSIGNED_CHAR_FMT_MOD="hh"
export MPIG_UNSIGNED_CHAR_FMT_MOD
MPIG_SHORT_FMT_MOD="h"
export MPIG_SHORT_FMT_MOD
MPIG_UNSIGNED_SHORT_FMT_MOD="h"
export MPIG_UNSIGNED_SHORT_FMT_MOD
MPIG_INT_FMT_MOD=""
export MPIG_INT_FMT_MOD
MPIG_UNSIGNED_INT_FMT_MOD=""
export MPIG_UNSIGNED_INT_FMT_MOD
MPIG_LONG_FMT_MOD="l"
export MPIG_LONG_FMT_MOD
MPIG_UNSIGNED_LONG_FMT_MOD="l"
export MPIG_UNSIGNED_LONG_FMT_MOD
MPIG_LONG_LONG_FMT_MOD="ll"
export MPIG_LONG_LONG_FMT_MOD
MPIG_UNSIGNED_LONG_LONG_FMT_MOD="ll"
export MPIG_UNSIGNED_LONG_LONG_FMT_MOD

#
# determine the integer type to which a pointer should be cast when doing a printf.  also get the corresponding printf conversion
# specifier.
#
echo ${ECHO_N} "checking for an unsigned integer type big enough to hold a pointer""... ${ECHO_C}"
for mpig_type in "unsigned char" "unsigned short" "unsigned int" "unsigned long" "unsigned long long" "unknown" ; do
    mpig_type_name=`echo "${mpig_type}" | sed -e 's/\*/P/' | tr "[a-z] " "[A-Z]_"`
    eval mpig_size="\${SIZEOF_${mpig_type_name}}"
    if test $SIZEOF_VOID_P -eq $mpig_size ; then
	break
    fi
done
echo "${ECHO_T}""$mpig_type"
if test "$mpig_type" = "unknown" ; then
    
    echo ""
    echo "ERROR: unable to find an integer type big enough to hold a pointer!"
    echo ""
    exit 1
fi
MPIG_PTR_CAST="${mpig_type}"
export MPIG_PTR_CAST

echo ${ECHO_N} "determining the printf conversion specifier for a pointer""... ${ECHO_C}"
mpig_chars=`expr ${mpig_size} \* 2`
eval MPIG_PTR_FMT="0x%0${mpig_chars}\${MPIG_${mpig_type_name}_FMT_MOD}x"
MPIG_PTR_FMT='"'"$MPIG_PTR_FMT"'"'
export MPIG_PTR_FMT
echo "${ECHO_T}""$MPIG_PTR_FMT"

#
# if the device is using a vendor implementation of MPI as one of its transport mechanisms, then we need to gather some information
# and set some options.
#
if test "${MPIG_VMPI}" = "yes" ; then
    echo "Enabling VendorMPI option"
   
    #
    # we can't use weak symbols with vendor MPI because the symbols names in the pragma directives aren't affected by the name
    # change definitions in mpiddefs.h.
    #
    echo "Disabling weak symbols (not compatible with VendorMPI option)"
    enable_weak_symbols=no
    ac_configure_args="${ac_configure_args} --disable-weak-symbols"

    mpig_get_type_size MPI_Comm
    mpig_get_type_size MPI_Datatype
    mpig_get_type_size MPI_Request
    mpig_get_type_size MPI_Op
    mpig_check_type MPI_2COMPLEX
    mpig_check_type MPI_2DOUBLE_COMPLEX
    mpig_check_type MPI_LONG_LONG
    mpig_check_type MPI_LONG_LONG_INT

    # originally I [BRT] believed that the vendor MPI_Aint and the MPICH2 MPI_Aint had to be the same length.  however, since
    # both the vendor and MPICH2 MPI_Aint must be large enough to hold void *, it should suffice to perform a type cast if the
    # sizes don't match.  this type cast is really on an issue when handling an array of MPI_Aints since an intermediate array
    # will have to be created.
    mpig_get_type_size MPI_Aint
    # MPI_SIZEOF_AINT=${SIZEOF_VMPI_AINT}

    #
    # if the vendor's MPI doesn't support MPI_LONG_LONG or MPI_LONG_LONG_INT then we need to disable long long support
    #
    # XXX: in MPICH-G2, why did we need to disable ROMIO if MPI_LONG_LONG wasn't supported?
    #
    if test "${HAVE_VMPI_LONG_LONG}" = "no" -a "${HAVE_VMPI_LONG_LONG_INT}" = "no" ; then
	echo "WARNING: The vendor MPI does not support MPI_LONG_LONG or MPI_LONG_LONG_INT."
	echo "       Support for these types in MPI-G has been disabled."
	MPID_NO_LONG_LONG=yes
	if test "$enable_romio" != "no" ; then
	    echo "WARNING: ROMIO requires MPI_LONG_LONG. ROMIO has been disabled."
	    enable_romio=no
	    ac_configure_args="${ac_configure_args} --disable-romio"
	fi
    fi

    #
    # determine extra space needed in the MPICH2 MPI_Status structure for the vendor MPI_Status structure
    #
    mpig_get_type_size MPI_Status
    mpig_num=`expr ${SIZEOF_VMPI_STATUS} + ${SIZEOF_MPIG_ALIGNED_T} - 1`
    mpig_num=`expr ${mpig_num} / ${SIZEOF_MPIG_ALIGNED_T}`
    EXTRA_STATUS_DECL="${TYPEOF_MPIG_ALIGNED_T} mpig_vmpi_status[${mpig_num}];"
fi

# store the format of the received message in the status so that the value of the count field can be evaluated int the context
# the of the source data format
EXTRA_STATUS_DECL="${EXTRA_STATUS_DECL} int mpig_dc_format;"

# force the top-level configure script to export the values of MPI_AINT and MPIU_SIZE_T to the device configure script
export MPI_AINT
export MPIU_SIZE_T

#
# FIXME: the globus data conversion library does not support long double.  we need to disable support for that type in MPICH2.
#
echo "WARNING: long double is not supported by Globus data conversion library."
echo "         Support for MPI_LONG_DOUBLE has been disabled."
MPID_NO_LONG_DOUBLE=yes

#
# the symbol renaming file, mpiddefs.h, needs to handle a special case if ROMIO is not being built, so we detect that here and
# pass the result on to configure through the MPIG_ROMIO_ENABLED environemnt variable
#
MPIG_ROMIO_ENABLED=no
if test "$enable_romio" = "yes" ; then
   if test -d $master_top_srcdir/src/mpi/romio ; then
       MPIG_ROMIO_ENABLED=yes
   fi
fi
export MPIG_ROMIO_ENABLED

#
# FIXME: add a default machines file if one does not exist
#
# if test ! -f ${binbuild_dir}/machines ; then
#     echo "Creating a default machines file in ${binbuild_dir}.  This will"
#     echo "allow testing of MPI-G, but you will need to create a new"
#     echo "file to exploit the full capabilities of MPI-G.  Please see"
#     echo "the documentation."
#     host=`uname -n 2>&1`
#     if [ -n "${host}" ] ; then
#         echo "${host}" >> ${binbuild_dir}/machines
#     fi
# fi

#
# miscellaneous settings to feedback to the top-level configure script
#
MPID_MAX_PROCESSOR_NAME=128
MPID_NO_SPAWN=yes
MPID_NO_RMA=yes
MPID_NO_PM=yes
MPID_NO_PMI=yes
# MPID_PM_NAMESERVER=device

#
# add the Globus to the list of directories in which to perform a "make install"
#
other_install_dirs="${other_install_dirs} src/mpid/globus"

#
# include mpiddefs.h in mpi.h
#
echo "INFO: adding include of device header file mpiddefs.h to mpi.h"
INCLUDE_MPIDDEFS_H='#include "mpiddefs.h"'

echo "END OF MPICH2PREREQ FOR THE GLOBUS DEVICE"
echo ""

