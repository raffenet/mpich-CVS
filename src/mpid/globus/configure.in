# 
# Globus device code:          Copyright 2005 Northern Illinois University
# Borrowed MPICH-G2 code:      Copyright 2000 Argonne National Laboratory and Northern Illinois University
# Borrowed MPICH2 device code: Copyright 2001 Argonne National Laboratory
# 
# XXX: INSERT POINTER TO OFFICIAL COPYRIGHT TEXT
# 

AC_PREREQ(2.59)

AC_INIT(configure.in)

notice_msg=`echo "start of configure for the ${device_name} device" | tr '[a-z]' '[A-Z]'`
AC_MSG_NOTICE([----------------------------------------])
AC_MSG_NOTICE([$notice_msg])

#
# set the directory that contains support scripts such as install-sh and config.guess
#
AC_CONFIG_AUX_DIR(../../../confdb)

#
# definitions will be placed in mpidconf.h file rather than in the DEFS variable
#
AC_CONFIG_HEADERS(mpidconf.h mpidconf_dynamic.h)

AH_TOP(
[/*
 * Globus device code:          Copyright 2005 Northern Illinois University
 * Borrowed MPICH-G2 code:      Copyright 2000 Argonne National Laboratory and Northern Illinois University
 * Borrowed MPICH2 device code: Copyright 2001 Argonne National Laboratory
 *
 * XXX: INSERT POINTER TO OFFICIAL COPYRIGHT TEXT
 *
 * NOTE: This file was generated by src/mpid/$device_name/configure.  Do _not_ edit.
 */

#if !defined(MPICH2_MPIDCONF_H_INCLUDED)
#define MPICH2_MPIDCONF_H_INCLUDED
])

AH_BOTTOM(
[#include "mpidconf_dynamic.h"

#endif /* !defined(MPICH2_MPIDCONF_H_INCLUDED) */
])

AC_DEFINE(HAVE_MPIDCONF_H,1,[Define so that we can test if mpidconf.h has been included])

# 
# in some cases the templates that need to be included into mpidconf.h.in aren't known until build time.  mpidconf_dynamic.h.in
# is built during the configure process (rather than by autoheader) using the LAH_DYNAMIC_TEMPLATE and LAC_OUTPUT_DYNAMIC_TEMPLATE
# macros.
#
cat >mpidconf_dynamic.h.in <<_LACEOF
/*
 * Globus device code:          Copyright 2005 Northern Illinois University
 * Borrowed MPICH-G2 code:      Copyright 2000 Argonne National Laboratory and Northern Illinois University
 * Borrowed MPICH2 device code: Copyright 2001 Argonne National Laboratory
 *
 * XXX: INSERT POINTER TO OFFICIAL COPYRIGHT TEXT
 *
 * NOTE: This file was generated by src/mpid/$device_name/configure.  Do _not_ edit.
 */

#if !defined(MPICH2_MPIDCONF_DYNAMIC_H_INCLUDED)
#define MPICH2_MPIDCONF_DYNAMIC_H_INCLUDED
_LACEOF

AC_DEFUN([LAH_DYNAMIC_TEMPLATE],[
if ! grep '^#undef $1$' mpidconf_dynamic.h.in >/dev/null 2>&1 ; then
    cat >>mpidconf_dynamic.h.in <<_LACEOF

m4_text_wrap([$2 */], [   ], [/* ])
[@%:@undef] $1
_LACEOF
fi
])

AC_DEFUN([LAH_OUTPUT_DYNAMIC_TEMPLATES],[
    cat >>mpidconf_dynamic.h.in <<_LACEOF

#endif /* !defined(MPICH2_MPIDCONF_DYNAMIC_H_INCLUDED) */
_LACEOF
])

#
# save initial values of important variables
#
MPIG_SAVE_LIBS=${LIBS}

#
# configuration options
#
AC_ARG_ENABLE(mpig-threaded,
[--enable-mpig-threaded=package - enable use of threads within the MPIg device.
The following thread packages are supported.
    globus - Globus threads [only option if using Globus middleware]
    pthreads - POSIX threads [default if not using Globus middleware]
    none - MPIg device will not use threads],,enable_mpig_threaded=default)

#
# first check that we have a clean build if we are doing a VPATH build
#
PAC_VPATH_CHECK()

#
# load cached results computed in the top-level configure tests
#
PAC_LOAD_BASE_CACHE

#
# check for standard programs needed by the Makefile
#
AC_PROG_INSTALL
PAC_PROG_CHECK_INSTALL_WORKS
PAC_PROG_MKDIR_P
PAC_PROG_MAKE

#
# miscellaneous header and function checks
#
AC_CHECK_HEADERS(unistd.h limits.h stdint.h stddef.h errno.h sched.h)
AC_CHECK_FUNCS(sched_yield yield nanosleep usleep sleep)

#
# check for optional, but common C types
#
AC_CHECK_TYPES([bool, bool_t])

#
# get sizes for intrinsic C types
#
AC_CHECK_SIZEOF(char,$CROSS_SIZEOF_CHAR)
AC_CHECK_SIZEOF(short,$CROSS_SIZEOF_SHORT)
AC_CHECK_SIZEOF(int,$CROSS_SIZEOF_INT)
AC_CHECK_SIZEOF(long,$CROSS_SIZEOF_LONG)
AC_CHECK_SIZEOF(long long,$CROSS_SIZEOF_LONG_LONG)
AC_CHECK_SIZEOF(float,$CROSS_SIZEOF_FLOAT)
AC_CHECK_SIZEOF(double,$CROSS_SIZEOF_DOUBLE)
AC_CHECK_SIZEOF(long double,$CROSS_SIZEOF_LONG_DOUBLE)
AC_CHECK_SIZEOF(void *,$CROSS_SIZEOF_VOID_P)
AC_CHECK_SIZEOF(wchar_t,$CROSS_SIZEOF_WCHAR_T)

#
# create a mapping from integer types to printf integer conversion length modifiers
#
mpig_char_fmt_mod="hh"
mpig_unsigned_char_fmt_mod="hh"
mpig_short_fmt_mod="h"
mpig_unsigned_short_fmt_mod="h"
mpig_int_fmt_mod=""
mpig_unsigned_int_fmt_mod=""
mpig_long_fmt_mod="l"
mpig_unsigned_long_fmt_mod="l"
mpig_long_long_fmt_mod="ll"
mpig_unsigned_long_long_fmt_mod="ll"

#
# determine the unsigned integer type to which a pointer should be cast when doing a printf.  also get the corresponding printf
# conversion specifier.
#
AC_MSG_CHECKING([for an unsigned integer type big enough to hold a pointer])
MPIG_PTR_CAST=""
for mpig_type in "char" "short" "int" "long" "long long" ; do
    eval mpig_size="\${ac_cv_sizeof_`echo ${mpig_type} | tr '[ *]' [_p]`}"
    if test ${ac_cv_sizeof_void_p} -eq ${mpig_size} ; then
        MPIG_PTR_CAST="unsigned ${mpig_type}"
        break
    fi
done
if test -n "${MPIG_PTR_CAST}" ; then
   AC_MSG_RESULT([${MPIG_PTR_CAST}])
else
   AC_MSG_RESULT([unknown])
   AC_MSG_ERROR([unable to find an integer type big enough to hold a pointer!])
fi

AC_MSG_CHECKING([printf conversion specifier for a pointer])
eval MPIG_PTR_FMT="\"\\\"0x%0`expr ${ac_cv_sizeof_void_p} \* 2`\${mpig_`echo ${MPIG_PTR_CAST} | tr '[ *]' [_p]`_fmt_mod}x\\\"\""
AC_MSG_RESULT([${MPIG_PTR_FMT}])
dnl AC_DEFINE_UNQUOTED(MPIG_PTR_CAST,${MPIG_PTR_CAST:?},[an unsigned integer big enough to hold a pointer])
dnl AC_DEFINE_UNQUOTED(MPIG_PTR_FMT,${MPIG_PTR_FMT:?},[printf conversion specifier for a pointer converted to a MPIG_PTR_CAST])
AC_SUBST(MPIG_PTR_CAST)
AC_SUBST(MPIG_PTR_FMT)

#
# check for functions needed to get a complete fully qualified host name
#
AC_CHECK_FUNCS(gethostname getdomainname)
if test "$ac_cv_func_gethostname" = "yes" ; then
    # do we need to declare gethostname?
    PAC_FUNC_NEEDS_DECL([#include <unistd.h>],gethostname)
fi

#
# check for uuid generation packages
#
AC_CHECK_HEADERS(uuid/uuid.h)
AC_SEARCH_LIBS(uuid_generate, uuid)
AC_CHECK_FUNCS(uuid_generate uuid_parse uuid_unparse uuid_copy)

#
# determine this machine's endianess
#
AC_CACHE_CHECK([endianess of system],
lac_cv_my_endian,[
AC_RUN_IFELSE([
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char **argv)
{
    int data;
    char * datap = (char *) &data;
    FILE *f;

    f = fopen("conftest.out", "w");
    data = 10;
    if (*datap == 10)
    {
        fprintf(f, "little\n");
    }
    else if (*(datap + sizeof(int) - 1) == 10)
    {
        fprintf(f, "big\n");
    }
    else
    {
        fprintf(f, "undetermined\n");
    }

    fclose(f);
    exit(0);
}
],lac_cv_my_endian=`cat conftest.out`,
  lac_cv_my_endian="FAILED",
  lac_cv_my_endian=${CROSS_MY_ENDIAN:-undetermined})
])

if test "$lac_cv_my_endian" = "big" ; then
    MPIG_MY_ENDIAN="MPIG_ENDIAN_BIG"
elif test "$lac_cv_my_endian" = "little" ; then
    MPIG_MY_ENDIAN="MPIG_ENDIAN_LITTLE"
else
    AC_MSG_ERROR([Unable to determine endianess of system.  If cross compiling, set CROSS_MY_ENDIAN to "big" or "little".])
fi
AC_DEFINE_UNQUOTED(MPIG_MY_ENDIAN,${MPIG_MY_ENDIAN},[endianess of the system])

#
# determine if threads are to be used internally and which threads package will be used
#
if test -z "${MPIG_THREADED}" ; then
    case ${enable_mpig_threaded} in
	posix|pthread|pthreads|yes)
	MPIG_THREADS_PKG=posix
	MPIG_THREADED=yes
	;;
	default|no|none)
	MPIG_THREADS_PKG=
	MPIG_THREADED=no
	;;
	*)
	AC_MSG_ERROR([The threads package "${enable_mpig_threaded}" is not known to the ${device_name} device.  Please select another package.])
	;;
    esac
elif test "${enable_mpig_threaded}" = "yes" -a "${MPIG_THREADED}" = "no" ; then
    AC_MSG_ERROR([The selected Grid Middleware package (${MPIG_GRID_PKG_NAME}) is not thread safe; however, the --enable-mpig-threaded option was passed to configure.  Please remove the option or select a middleware package that is thread safe.])
elif test "${enable_mpig_threaded}" = "no" -a "${MPIG_THREADED}" = "yes" ; then
    AC_MSG_ERROR([The selected Grid Middleware package (${MPIG_GRID_PKG_NAME}) requires threads; however, the --disable-mpig-threaded option was passed to configure.  Please remove the option or select a middleware package that does not require threads.])
elif test "${enable_mpig_threaded}" != "default" -a "${enable_mpig_threaded}" != "${MPIG_THREADS_PKG}" ; then
    AC_MSG_ERROR([The threads "${MPIG_THREADS_PKG} package is required by the selected Grid Middleware (${MPIG_GRID_PKG_NAME}); however, the --enable-mpig-threaded=${enable_mpig_threaded} option was passed to configure specified a different package.  Please remove the option or select a middleware package that is compatible with the specified threads package.])
fi
if test "${MPIG_THREADED}" = "yes" ; then
    AC_DEFINE(MPIG_THREADED,1,[define if MPIg is allowed to use threads internally])
fi 
if test -n "${MPIG_THREADS_PKG}" ; then
    mpig_define_name="HAVE_`echo ${MPIG_THREADS_PKG} | tr '[a-z- ]' '[A-Z__]'`_THREADS"
    LAH_DYNAMIC_TEMPLATE([${mpig_define_name}], [threads package to be used internally by MPIg])
    AC_DEFINE_UNQUOTED([${mpig_define_name}], 1)
fi

if test "${MPIG_THREADS_PKG}" = "posix" ; then
    AC_CHECK_HEADERS(pthread.h)
    AC_CHECK_FUNCS(pthread_yield)
    if test "$ac_cv_func_pthread_yield" = "yes" ; then
        PAC_FUNC_NEEDS_DECL([#include <pthread.h>],pthread_yield)
    fi
fi

#
# determine if C compiler supports function inlining
#
AC_C_INLINE
if test "$ac_cv_c_inline" != "no" ; then
    AC_DEFINE(HAVE_C_INLINE,1,[define if the C compiler supports function inlining])
fi

#
# determine the size of MPICH2's MPI_AINT, and the printf conversion specifers for MPI_Aint and MPIU_Size_t
#
AC_MSG_CHECKING([size of MPICH2 MPI_AINT])
eval SIZEOF_MPICH2_AINT="\${SIZEOF_`echo ${MPI_AINT} | tr '[a-z]' '[A-Z]'`}"
AC_MSG_RESULT([$SIZEOF_MPICH2_AINT])
AC_DEFINE_UNQUOTED(TYPEOF_MPICH2_AINT,${MPI_AINT:?},[integer type of the same size as the MPICH2 MPI_Aint type])
AC_DEFINE_UNQUOTED(SIZEOF_MPICH2_AINT,${SIZEOF_MPICH2_AINT:?},[size of the MPICH2 MPI_Aint type])

AC_MSG_NOTICE([INFO: MPI_Aint is "${MPI_AINT}"])
AC_MSG_CHECKING([printf conversion specifier for MPI_Aint])
eval MPIG_AINT_FMT="\"\\\"%\${MPIG_`echo ${MPI_AINT} | tr ' *' '_p'`_fmt_mod}d\\\"\""
dnl AC_DEFINE_UNQUOTED(MPIG_AINT_FMT,${MPIG_AINT_FMT:?},[printf conversion specifier for MPI_Aint])
AC_SUBST(MPIG_AINT_FMT)
AC_MSG_RESULT([$MPIG_AINT_FMT])

AC_MSG_NOTICE([INFO: MPIU_Size_t is "${MPIU_SIZE_T}"])
AC_MSG_CHECKING([printf conversion specifier for MPIU_Size_t])
eval MPIG_SIZE_FMT="\"\\\"%\${MPIG_`echo ${MPIU_SIZE_T} | tr ' *' '_p'`_fmt_mod}u\\\"\""
dnl AC_DEFINE_UNQUOTED(MPIG_SIZE_FMT,${MPIG_SIZE_FMT:?},[printf conversion specifier for MPIU_Size_t])
AC_SUBST(MPIG_SIZE_FMT)
AC_MSG_RESULT([$MPIG_SIZE_FMT])

#
# determine if CPP supports variadic macros
#
AC_CACHE_CHECK([whether CPP accepts C99 style variadic macros],
lac_cv_have_c99_variadic_macros,[
AC_COMPILE_IFELSE([
#include <stdio.h>
#define MY_PRINTF(rank, fmt, ...)  printf("%d: " fmt, rank, ## __VA_ARGS__)
int main(int argc, char ** argv)
{
    MY_PRINTF(0, "hello");
    MY_PRINTF(1, "world %d", 3);
    return 0;
}
], lac_cv_have_c99_variadic_macros=yes, lac_cv_have_c99_variadic_macros=no)
])
if test $lac_cv_have_c99_variadic_macros = "yes" ; then
    AC_DEFINE(HAVE_C99_VARIADIC_MACROS,,[define if CPP supports C99 style variadic macros])
fi

AC_CACHE_CHECK([whether CPP accepts GNU style variadic macros],
lac_cv_have_gnu_variadic_macros,[
AC_COMPILE_IFELSE([
#include <stdio.h>
#define MY_PRINTF(rank, fmt, args...)  printf("%d: " fmt, rank, ## args)
int main(int argc, char ** argv)
{
    MY_PRINTF(0, "hello");
    MY_PRINTF(1, "world %d", 3);
    return 0;
}
], lac_cv_have_gnu_variadic_macros=yes, lac_cv_have_gnu_variadic_macros=no)
])
if test $lac_cv_have_gnu_variadic_macros = "yes" ; then
    AC_DEFINE(HAVE_GNU_VARIADIC_MACROS,,[define if CPP supports GNU style variadic macros])
fi

#
# determine if the compiler defines a symbol containing the function name
#
AC_CACHE_CHECK([whether the compiler defines __func__],
lac_cv_have__func__,[
AC_RUN_IFELSE([
#include <string.h>
int foo(void);
int foo(void)
{
    return (strcmp(__func__, "foo") == 0);
}
int main(int argc, char ** argv)
{
    return (foo() ? 0 : 1);
}
], lac_cv_have__func__=yes, lac_cv_have__func__=no)
])
if test $lac_cv_have__func__ = "yes" ; then
    AC_DEFINE(HAVE__FUNC__,,[define if the compiler defines __func__])
fi

AC_CACHE_CHECK([whether the compiler defines __FUNC__],
lac_cv_have_cap__func__,[
AC_RUN_IFELSE([
#include <string.h>
int foo(void);
int foo(void)
{
    return (strcmp(__FUNC__, "foo") == 0);
}
int main(int argc, char ** argv)
{
    return (foo() ? 0 : 1);
}
], lac_cv_have_cap__func__=yes, lac_cv_have_cap__func__=no)
])
if test $lac_cv_have_cap__func__ = "yes" ; then
    AC_DEFINE(HAVE_CAP__FUNC__,,[define if the compiler defines __FUNC__])
fi

AC_CACHE_CHECK([whether the compiler sets __FUNCTION__],
lac_cv_have__function__,[
AC_RUN_IFELSE([
#include <string.h>
int foo(void);
int foo(void)
{
    return (strcmp(__FUNCTION__, "foo") == 0);
}
int main(int argc, char ** argv)
{
    return (foo() ? 0 : 1);
}
], lac_cv_have__function__=yes, lac_cv_have__function__=no)
])
if test $lac_cv_have__function__ = "yes" ; then
    AC_DEFINE(HAVE__FUNCTION__,,[define if the compiler defines __FUNCTION__])
fi

#
# set F77 to C mapping definitions
#
AC_DEFUN([LAC_SET_MPIG_F77_CTYPE],
[
m4_pushdef([lac_f77_type], m4_bregexp([$1], [^MPI_\(.*\)], [\1]))
m4_pushdef([lac_mpir_f77_ctype], [MPIR_F77_]lac_f77_type[_CTYPE])
m4_pushdef([lac_mpig_f77_ctype], [MPIG_F77_]lac_f77_type[_CTYPE])
if test -n "$lac_mpir_f77_ctype" ; then
    lac_mpig_f77_ctype=`echo "MPIG_CTYPE_${lac_mpir_f77_ctype}" | tr '[a-z ]' '[A-Z_]'`
else
    lac_mpig_f77_ctype="MPIG_CTYPE_INVALID"
fi
AC_DEFINE_UNQUOTED(lac_mpig_f77_ctype, ${lac_mpig_f77_ctype}, [MPIG_CTYPE for F77 $1])
m4_popdef([lac_mpig_f77_ctype])
m4_popdef([lac_mpir_f77_ctype])
m4_popdef([lac_f77_type])
])

if test ${FORTRAN_BINDING} -ne 0 ; then
    MPIR_F77_COMPLEX_CTYPE=$MPIR_F77_REAL_CTYPE
    MPIR_F77_DOUBLE_COMPLEX_CTYPE=$MPIR_F77_DOUBLE_PRECISION_CTYPE
    MPIR_F77_2INTEGER_CTYPE=$MPIR_F77_INTEGER_CTYPE
    MPIR_F77_2REAL_CTYPE=$MPIR_F77_REAL_CTYPE
    MPIR_F77_2DOUBLE_PRECISION_CTYPE=$MPIR_F77_DOUBLE_PRECISION_CTYPE
    MPIR_F77_2COMPLEX_CTYPE=$MPIR_F77_REAL_CTYPE
    MPIR_F77_2DOUBLE_COMPLEX_CTYPE=$MPIR_F77_DOUBLE_PRECISION_CTYPE
    MPIR_F77_COMPLEX8_CTYPE=$MPIR_F77_REAL4_CTYPE
    MPIR_F77_COMPLEX16_CTYPE=$MPIR_F77_REAL8_CTYPE
    MPIR_F77_COMPLEX32_CTYPE=$MPIR_F77_REAL16_CTYPE

    LAC_SET_MPIG_F77_CTYPE(MPI_CHARACTER)
    LAC_SET_MPIG_F77_CTYPE(MPI_LOGICAL)
    LAC_SET_MPIG_F77_CTYPE(MPI_INTEGER)
    LAC_SET_MPIG_F77_CTYPE(MPI_REAL)
    LAC_SET_MPIG_F77_CTYPE(MPI_DOUBLE_PRECISION)
    LAC_SET_MPIG_F77_CTYPE(MPI_COMPLEX)
    LAC_SET_MPIG_F77_CTYPE(MPI_DOUBLE_COMPLEX)
    LAC_SET_MPIG_F77_CTYPE(MPI_2INTEGER)
    LAC_SET_MPIG_F77_CTYPE(MPI_2COMPLEX)
    LAC_SET_MPIG_F77_CTYPE(MPI_2DOUBLE_COMPLEX)
    LAC_SET_MPIG_F77_CTYPE(MPI_2REAL)
    LAC_SET_MPIG_F77_CTYPE(MPI_2DOUBLE_PRECISION)
    LAC_SET_MPIG_F77_CTYPE(MPI_INTEGER1)
    LAC_SET_MPIG_F77_CTYPE(MPI_INTEGER2)
    LAC_SET_MPIG_F77_CTYPE(MPI_INTEGER4)
    LAC_SET_MPIG_F77_CTYPE(MPI_INTEGER8)
    LAC_SET_MPIG_F77_CTYPE(MPI_INTEGER16)
    LAC_SET_MPIG_F77_CTYPE(MPI_REAL4)
    LAC_SET_MPIG_F77_CTYPE(MPI_REAL8)
    LAC_SET_MPIG_F77_CTYPE(MPI_REAL16)
    LAC_SET_MPIG_F77_CTYPE(MPI_COMPLEX8)
    LAC_SET_MPIG_F77_CTYPE(MPI_COMPLEX16)
    LAC_SET_MPIG_F77_CTYPE(MPI_COMPLEX32)
fi

dnl
dnl FIXME: add C++ to C type mappings for MPI::BOOL, MPI::COMPLEX, MPI::DOUBLE_COMPLEX, and MPI::LONG_DOUBLE_COMPLEX
dnl
dnl if test ${CPP_BINDING} -ne 0 ; then
dnl     true
dnl fi

# also need to map MPI_WCHAR to an intrinsic C type
MPIG_C_WCHAR_T_CTYPE=MPIG_CTYPE_UNKNOWN
if test "$ac_cv_type_wchar_t" = "yes" ; then
    AC_MSG_CHECKING([for instrinsic C type compatible with wchar_t])
    for lac_type in char short int long long_long ; do
        eval lac_size=\${ac_cv_sizeof_${lac_type}}
        if test $ac_cv_sizeof_wchar_t = $lac_size ; then
	    MPIR_C_WCHAR_T_CTYPE=`echo "$lac_type" | tr '[_]' '[ ]'`
            break
        fi
    done
fi
if test -n "${MPIR_C_WCHAR_T_CTYPE}" ; then
    MPIG_C_WCHAR_T_CTYPE=`echo "MPIG_CTYPE_UNSIGNED_${MPIR_C_WCHAR_T_CTYPE}" | tr '[a-z ]' '[A-Z_]'`
    AC_MSG_RESULT([${MPIR_C_WCHAR_T_CTYPE}])
else
    AC_MSG_RESULT([none])
fi
AC_DEFINE_UNQUOTED(MPIG_C_WCHAR_T_CTYPE, ${MPIG_C_WCHAR_T_CTYPE}, [MPIG_CTYPE for wchar_t])

#
# m4 macros to acquire information from the vendor MPI
#
AC_DEFUN([LAC_CHECK_C_VMPI_FUNC],
[
m4_pushdef([lac_upper_varname], m4_translit([HAVE_C_V$1], [a-z], [A-Z]))
m4_pushdef([lac_lower_varname], m4_translit([lac_cv_have_c_v$1], [A-Z], [a-z]))
AC_CACHE_CHECK([for the vendor MPI function $1 (C binding)], lac_lower_varname, [
SAVE_MPIG_CONFIGURE_ACTIVE=${MPIG_CONFIGURE_ACTIVE}
MPIG_CONFIGURE_ACTIVE=""
AC_LINK_IFELSE([
void $1(float * a);
int main(int argc, char *argv[[]])
{
    void (*func)(float * a) = $1;
    float a = 1.0;
    func(&a);
    return 0;
}
], lac_lower_varname=yes, lac_lower_varname=no)
MPIG_CONFIGURE_ACTIVE=${SAVE_MPIG_CONFIGURE_ACTIVE}
])
if test ${lac_lower_varname} = "yes" ; then
    AC_DEFINE_UNQUOTED(lac_upper_varname, 1, [define if the vendor MPI provides the function $1])
fi
m4_popdef([lac_lower_varname])
m4_popdef([lac_upper_varname])
])

AC_DEFUN([LAC_CHECK_C_VMPI_CONSTANT],
[
m4_pushdef([lac_upper_varname], m4_translit([HAVE_C_V$2], [a-z], [A-Z]))
m4_pushdef([lac_lower_varname], m4_translit([lac_cv_have_c_v$2], [A-Z], [a-z]))
AC_CACHE_CHECK([for the vendor MPI constant $2 (C binding)], lac_lower_varname, [
SAVE_MPIG_CONFIGURE_ACTIVE=${MPIG_CONFIGURE_ACTIVE}
MPIG_CONFIGURE_ACTIVE=""
AC_COMPILE_IFELSE([
#include "mpi.h"
void func($1 a);
int main(int argc, char *argv[[]])
{
    $1 a = $2;
    func(a);
    return 0;
}
], lac_lower_varname=yes, lac_lower_varname=no)
MPIG_CONFIGURE_ACTIVE=${SAVE_MPIG_CONFIGURE_ACTIVE}
])
if test ${lac_lower_varname} = "yes" ; then
    AC_DEFINE_UNQUOTED(lac_upper_varname, 1, [define if the the vendor MPI provides the constant $2])
fi
m4_popdef([lac_lower_varname])
m4_popdef([lac_upper_varname])
])

AC_DEFUN([LAC_GET_VMPI_TYPE_FORMAT],
[
m4_pushdef([lac_upper_type], m4_translit([V$1], [a-z], [A-Z]))
m4_pushdef([lac_lower_varname], m4_translit([lac_cv_fmt_v$1], [A-Z], [a-z]))
AC_CACHE_CHECK([printf conversion specifier for vendor $1], lac_lower_varname, [
if test "${[TYPEOF_]lac_upper_type[_IS_BASIC]}" = "yes" ; then
    lac_fmt_mod_varname='mpig_'${[TYPEOF_]lac_upper_type}'_fmt_mod'
    eval lac_fmt_mod='${'${lac_fmt_mod_varname}'}'
    lac_lower_varname="\"0x%0`expr 2 \* ${[SIZEOF_]lac_upper_type}`${lac_fmt_mod}x\""
    unset lac_fmt_mod_varname
    unset lac_fmt_mod
else
    lac_lower_varname="not basic!"
fi
])
if test "${lac_lower_varname}" != "not basic!" ; then
    AC_DEFINE_UNQUOTED([FMT_]lac_upper_type, ${lac_lower_varname}, [printf conversion specifier for vendor $1 handle])
fi
m4_popdef([lac_lower_varname])
m4_popdef([lac_upper_type])
])

AC_DEFUN([LAC_VMPI_DTMAP],
[
AC_DEFINE_UNQUOTED(MPIG_V$1_DTMAP, $2, [datatype to use for vendor $1])
])

AC_DEFUN([LAC_CHECK_VMPI_F77_BASIC_TYPE],
[
m4_pushdef([lac_f77_type], m4_bregexp([$1], [^MPI_\(.*\)], [\1]))
m4_pushdef([lac_f77_ctype_varname], [MPIR_F77_]lac_f77_type[_CTYPE])
m4_pushdef([lac_lower_varname], m4_translit([lac_cv_have_c_v$1], [A-Z], [a-z]))
LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, $1)
if test "${lac_lower_varname}" = "yes" ; then
    LAC_VMPI_DTMAP($1, $1)
else
    AC_MSG_CHECKING([for C datatype compatible with $1])
    if test -n "${lac_f77_ctype_varname}" ; then
        dnl NOTE: the vendor MPI is assumed to be running on a homogeneous system.  therefore, we ignore the possibility of data
	dnl corruption that could occur if a F77 datatype did not map to the same C datatype on all machines participating in the
	dnl vendor MPI job.
        lac_mpi_type=`echo "MPI_${lac_f77_ctype_varname}" | tr '[a-z ]' '[A-Z_]'`
        LAC_VMPI_DTMAP($1, $lac_mpi_type)
        AC_MSG_RESULT($lac_mpi_type)
    else
        LAC_VMPI_DTMAP($1, MPI_DATATYPE_NULL)
        AC_MSG_RESULT([none])
    fi
fi
m4_popdef([lac_lower_varname])
m4_popdef([lac_f77_ctype_varname])
m4_popdef([lac_f77_type])
])

AC_DEFUN([LAC_CHECK_VMPI_F77_COMPLICATED_TYPE],
[
m4_pushdef([lac_f77_type], m4_bregexp([$1], [^MPI_\(.*\)], [\1]))
m4_pushdef([lac_f77_ctype_varname], [MPIR_F77_]lac_f77_type[_CTYPE])
m4_pushdef([lac_lower_varname], m4_translit([lac_cv_have_c_v$1], [A-Z], [a-z]))
LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, $1)
if test "${lac_lower_varname}" = "yes" ; then
    LAC_VMPI_DTMAP($1, $1)
else
    AC_MSG_CHECKING([for C datatype with which to build $1])
    if test -n "${lac_f77_ctype_varname}" ; then
        dnl NOTE: the vendor MPI is assumed to be running on a homogeneous system.  therefore, we ignore the possibility of data
	dnl corruption that could occur if a F77 datatype did not map to the same C datatype on all machines participating in the
	dnl vendor MPI job.
        lac_mpi_type=`echo "MPI_${lac_f77_ctype_varname}" | tr '[a-z ]' '[A-Z_]'`
        LAC_VMPI_DTMAP($1, $lac_mpi_type)
	AC_DEFINE(MPIG_VMPI_MUST_CONSTRUCT_$1, 1, [define if vendor $1 must be constructed])
        AC_MSG_RESULT($lac_mpi_type)
    else
        LAC_VMPI_DTMAP($1, MPI_DATATYPE_NULL)
        AC_MSG_RESULT([none])
    fi
fi
m4_popdef([lac_lower_varname])
m4_popdef([lac_f77_ctype_varname])
m4_popdef([lac_f77_type])
])

#
# vendor MPI
#
if test "${MPIG_VMPI:?}" != "no" ; then
    # vendor MPI settings from mpich2prereq
    AC_DEFINE(MPIG_VMPI,1,[define if we are building on top of a vendor MPI])

    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_COMM,${SIZEOF_VMPI_COMM:?},[size of the vendor MPI_Comm handle])
    AC_DEFINE_UNQUOTED(TYPEOF_VMPI_COMM, ${TYPEOF_VMPI_COMM:?}, [C type equivalent to a vendor MPI_Comm handle])
    if test "${TYPEOF_VMPI_COMM_IS_BASIC:?}" = yes; then
        AC_DEFINE(TYPEOF_VMPI_COMM_IS_BASIC, 1, [define if TYPEOF_VMPI_COMM is a basic C type])
    fi
    LAC_GET_VMPI_TYPE_FORMAT(MPI_Comm)

    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_DATATYPE,${SIZEOF_VMPI_DATATYPE:?},[size of the vendor MPI_Datatype handle])
    AC_DEFINE_UNQUOTED(TYPEOF_VMPI_DATATYPE, ${TYPEOF_VMPI_DATATYPE:?}, [C type equivalent to a vendor MPI_Datatype handle])
    if test "${TYPEOF_VMPI_DATATYPE_IS_BASIC:?}" = yes; then
        AC_DEFINE(TYPEOF_VMPI_DATATYPE_IS_BASIC, 1, [define if TYPEOF_VMPI_DATATYPE is a basic C type])
    fi
    LAC_GET_VMPI_TYPE_FORMAT(MPI_Datatype)

    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_OP,${SIZEOF_VMPI_OP:?},[size of the vendor MPI_Op object])
    AC_DEFINE_UNQUOTED(TYPEOF_VMPI_OP, ${TYPEOF_VMPI_OP:?}, [C type equivalent to a vendor MPI_Op handle])
    if test "${TYPEOF_VMPI_OP_IS_BASIC:?}" = yes; then
        AC_DEFINE(TYPEOF_VMPI_OP_IS_BASIC, 1, [define if TYPEOF_VMPI_OP is a basic C type])
    fi
    LAC_GET_VMPI_TYPE_FORMAT(MPI_Op)

    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_REQUEST,${SIZEOF_VMPI_REQUEST:?},[size of the vendor MPI_Request handle])
    AC_DEFINE_UNQUOTED(TYPEOF_VMPI_REQUEST, ${TYPEOF_VMPI_REQUEST:?}, [C type equivalent to a vendor MPI_Request handle])
    if test "${TYPEOF_VMPI_REQUEST_IS_BASIC:?}" = yes; then
        AC_DEFINE(TYPEOF_VMPI_REQUEST_IS_BASIC, 1, [define if TYPEOF_VMPI_REQUEST is a basic C type])
    fi
    LAC_GET_VMPI_TYPE_FORMAT(MPI_Request)

    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_STATUS,${SIZEOF_VMPI_STATUS:?},[size of the vendor MPI_Status object])
    AC_DEFINE_UNQUOTED(TYPEOF_VMPI_STATUS, ${TYPEOF_VMPI_STATUS:?}, [C type equivalent to a vendor MPI_Status handle])
    if test "${TYPEOF_VMPI_STATUS_IS_BASIC:?}" = yes; then
        AC_DEFINE(TYPEOF_VMPI_STATUS_IS_BASIC, 1, [define if TYPEOF_VMPI_STATUS is a basic C type])
    fi
    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_AINT,${SIZEOF_VMPI_AINT:?},[size of the vendor MPI_Aint type])

    # determine if the vendor MPI supports MPI-2 functionality
    LAC_CHECK_C_VMPI_FUNC(MPI_Comm_get_attr)
    LAC_CHECK_C_VMPI_FUNC(MPI_Comm_set_errhandler)
    LAC_CHECK_C_VMPI_FUNC(MPI_Init_thread)
    LAC_CHECK_C_VMPI_FUNC(MPI_Type_dup)
    LAC_CHECK_C_VMPI_FUNC(MPI_Type_create_hvector)
    LAC_CHECK_C_VMPI_FUNC(MPI_Type_create_hindexed)
    LAC_CHECK_C_VMPI_FUNC(MPI_Type_create_indexed_block)
    LAC_CHECK_C_VMPI_FUNC(MPI_Type_create_resized)
    LAC_CHECK_C_VMPI_FUNC(MPI_Type_create_struct)

    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_LONG_DOUBLE)
    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_LONG_DOUBLE_INT)
    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_LONG_LONG)
    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_LONG_LONG_INT)
    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_UNSIGNED_LONG_LONG)
    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_SIGNED_CHAR)
    LAC_CHECK_C_VMPI_CONSTANT(MPI_Datatype, MPI_WCHAR)

    if test "$lac_cv_have_c_vmpi_long_double" = "yes" ; then
        LAC_VMPI_DTMAP(MPI_LONG_DOUBLE, MPI_LONG_DOUBLE)
    else
        LAC_VMPI_DTMAP(MPI_LONG_DOUBLE, MPI_DATATYPE_NULL)
    fi

    if test "$lac_cv_have_c_vmpi_long_double_int" = "yes" ; then
        LAC_VMPI_DTMAP(MPI_LONG_DOUBLE_INT, MPI_LONG_DOUBLE_INT)
    else
        LAC_VMPI_DTMAP(MPI_LONG_DOUBLE_INT, MPI_DATATYPE_NULL)
    fi

    if test "$lac_cv_have_c_vmpi_long_long" = "yes" ; then
        LAC_VMPI_DTMAP(MPI_LONG_LONG, MPI_LONG_LONG)
    elif test "$lac_cv_have_c_vmpi_long_long_int" = "yes" ; then
        LAC_VMPI_DTMAP(MPI_LONG_LONG, MPI_LONG_LONG_INT)
    else
        LAC_VMPI_DTMAP(MPI_LONG_LONG, MPI_DATATYPE_NULL)
    fi

    if test "$lac_cv_have_c_vmpi_long_long_int" = "yes" ; then
        LAC_VMPI_DTMAP(MPI_LONG_LONG_INT, MPI_LONG_LONG_INT)
    elif test "$lac_cv_have_c_vmpi_long_long" = "yes" ; then
        LAC_VMPI_DTMAP(MPI_LONG_LONG_INT, MPI_LONG_LONG)
    else
        LAC_VMPI_DTMAP(MPI_LONG_LONG_INT, MPI_DATATYPE_NULL)
    fi

    if test "$lac_cv_have_c_vmpi_unsigned_long_long" = "yes" ; then
        LAC_VMPI_DTMAP(MPI_UNSIGNED_LONG_LONG, MPI_UNSIGNED_LONG_LONG)
    elif test "$lac_cv_have_c_vmpi_long_long" = "yes" ; then
        # NOTE: the vendor MPI is assumed to be running on a homogeneous system.  therefore, we ignore the possibility of
        # corrupting the unsigned value if sign extension were to occur from a size change.
        LAC_VMPI_DTMAP(MPI_UNSIGNED_LONG_LONG, MPI_LONG_LONG)
    elif test "$lac_cv_have_c_vmpi_long_long_int" = "yes" ; then
        # NOTE: the vendor MPI is assumed to be running on a homogeneous system.  therefore, we ignore the possibility of
        # corrupting the unsigned value if sign extension were to occur from a size change.
        LAC_VMPI_DTMAP(MPI_UNSIGNED_LONG_LONG, MPI_LONG_LONG_INT)
    else
        LAC_VMPI_DTMAP(MPI_UNSIGNED_LONG_LONG, MPI_DATATYPE_NULL)
    fi

    if test "$lac_cv_have_c_vmpi_signed_char" = "yes" ; then
        LAC_VMPI_DTMAP(MPI_SIGNED_CHAR, MPI_SIGNED_CHAR)
    else
        LAC_VMPI_DTMAP(MPI_SIGNED_CHAR, MPI_CHAR)
    fi

    if test "$lac_cv_have_c_vmpi_wchar" = "yes" ; then
        LAC_VMPI_DTMAP(MPI_WCHAR, MPI_WCHAR)
    elif test -n "$MPIR_C_WCHAR_T_CTYPE" ; then
	lac_mpi_type=`echo "MPI_${MPIR_C_WCHAR_T_CTYPE}" | tr '[a-z ]' '[A-Z_]'`
        LAC_VMPI_DTMAP(MPI_WCHAR, $lac_mpi_type)
    else
        LAC_VMPI_DTMAP(MPI_WCHAR, MPI_DATATYPE_NULL)
    fi

    # determine which, if any, of the Fortran datatype handles are defined in the C header file.  if they are not in the C header
    # file, then map then to C datatypes
    if test $FORTRAN_BINDING -ne 0 ; then
        LAC_CHECK_VMPI_F77_BASIC_TYPE(MPI_CHARACTER)
        LAC_CHECK_VMPI_F77_BASIC_TYPE(MPI_LOGICAL)
        LAC_CHECK_VMPI_F77_BASIC_TYPE(MPI_INTEGER)
        LAC_CHECK_VMPI_F77_BASIC_TYPE(MPI_REAL)
        LAC_CHECK_VMPI_F77_BASIC_TYPE(MPI_DOUBLE_PRECISION)
        LAC_CHECK_VMPI_F77_BASIC_TYPE(MPI_INTEGER1)
        LAC_CHECK_VMPI_F77_BASIC_TYPE(MPI_INTEGER2)
        LAC_CHECK_VMPI_F77_BASIC_TYPE(MPI_INTEGER4)
        LAC_CHECK_VMPI_F77_BASIC_TYPE(MPI_INTEGER8)
        LAC_CHECK_VMPI_F77_BASIC_TYPE(MPI_INTEGER16)
        LAC_CHECK_VMPI_F77_BASIC_TYPE(MPI_REAL4)
        LAC_CHECK_VMPI_F77_BASIC_TYPE(MPI_REAL8)
        LAC_CHECK_VMPI_F77_BASIC_TYPE(MPI_REAL16)

        LAC_CHECK_VMPI_F77_COMPLICATED_TYPE(MPI_COMPLEX)
        LAC_CHECK_VMPI_F77_COMPLICATED_TYPE(MPI_DOUBLE_COMPLEX)
        LAC_CHECK_VMPI_F77_COMPLICATED_TYPE(MPI_2INTEGER)
        LAC_CHECK_VMPI_F77_COMPLICATED_TYPE(MPI_2COMPLEX)
        LAC_CHECK_VMPI_F77_COMPLICATED_TYPE(MPI_2DOUBLE_COMPLEX)
        LAC_CHECK_VMPI_F77_COMPLICATED_TYPE(MPI_2REAL)
        LAC_CHECK_VMPI_F77_COMPLICATED_TYPE(MPI_2DOUBLE_PRECISION)
        LAC_CHECK_VMPI_F77_COMPLICATED_TYPE(MPI_COMPLEX8)
        LAC_CHECK_VMPI_F77_COMPLICATED_TYPE(MPI_COMPLEX16)
        LAC_CHECK_VMPI_F77_COMPLICATED_TYPE(MPI_COMPLEX32)
    fi

    dnl
    dnl FIXME: add C++ to C type mappings for MPI::BOOL, MPI::COMPLEX, MPI::DOUBLE_COMPLEX, and MPI::LONG_DOUBLE_COMPLEX
    dnl
    dnl if test $FORTRAN_BINDING -ne 0 ; then
    dnl     true
    dnl fi

    LAC_CHECK_C_VMPI_CONSTANT(MPI_Op, MPI_REPLACE)

    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_ACCESS)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_AMODE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_ASSERT)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_BAD_FILE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_BASE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_CONVERSION)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_DISP)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_DUP_DATAREP)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_FILE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_FILE_EXISTS)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_FILE_IN_USE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_INFO)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_INFO_KEY)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_INFO_NOKEY)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_INFO_VALUE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_IO)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_KEYVAL)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_LOCKTYPE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_NAME)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_NOT_SAME)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_NO_MEM)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_NO_SPACE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_NO_SUCH_FILE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_PORT)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_QUOTA)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_READ_ONLY)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_RMA_CONFLICT)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_RMA_SYNC)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_SERVICE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_SIZE)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_SPAWN)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_UNSUPPORTED_DATAREP)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_UNSUPPORTED_OPERATION)
    LAC_CHECK_C_VMPI_CONSTANT(int, MPI_ERR_WIN)

    AC_CACHE_CHECK([version of the MPI standard implemented by the vendor MPI],
    lac_cv_vmpi_version,[
        AC_RUN_IFELSE([
        #include "mpi.h"
        #include <stdio.h>
        int main(int argc, char *argv[[]])
        {
            FILE * fp = fopen("conftest.out","w");
            fprintf(fp, "%d\n", MPI_VERSION);
            close(fp);
            return 0;
        }
        ], lac_cv_vmpi_version=`cat conftest.out`, lac_cv_vmpi_version=0)
    ])

    AC_DEFINE_UNQUOTED(MPIG_VMPI_VERSION,${lac_cv_vmpi_version},
        [define with the MPI standard version implemented by the vendor MPI])

    #
    # if the vendor MPI does not implement the MPI-2 standard, then it is possible that it also does not support passing NULL in
    # place of the command line arguments.  in that case, we must provide an alternative main() that first calls MPI_Init and
    # calls the application's main().  see comments in mpig_vmpi_premain.c for additional details.
    #
    if test -z "${MPIG_VMPI_PREMAIN_LIBS_REQUIRED}" ; then
        if test ${lac_cv_vmpi_version} -lt 2 ; then
	    MPIG_VMPI_PREMAIN_LIBS_REQUIRED=yes
        else
	    MPIG_VMPI_PREMAIN_LIBS_REQUIRED=no
        fi
    fi

    if test "${MPIG_VMPI_PREMAIN_LIBS_REQUIRED}" = "yes" ; then
        AC_DEFINE(MPIG_VMPI_PREMAIN_REQUIRED,1,
		[define if MPIg must initialize the vendor MPI before the main routine of the application is called])
        for c in cc cxx ; do
	    cnu=`echo ${c} | tr '[a-z]' '[A-Z]'`
	    cf=mpich2-grid-${c}
	    premain_lib="libmpig_vmpi_premain_${c}.a"
            if test -f ${cf} ; then
                AC_MSG_NOTICE([Updating the paths in the MPIg compiler script ${cf}])
                mv ${cf} ${cf}.orig
                sed -e 's!^\(MPIG_VMPI_PREMAIN_LIB\)=.*!\1="'"${MPIG_BUILD_DIR}/${premain_lib}"'"!' ${cf}.orig >${cf}
                chmod 755 ${cf}
                rm -f ${cf}.orig
		eval MPIG_VMPI_PREMAIN_${cnu}_LIB=${premain_lib}
            fi
        done
    fi

    MPIG_VMPI_DEFINED=1

else # no vendor MPI

    MPIG_VMPI_DEFINED=0
fi

AC_SUBST(MPIG_VMPI)
AC_SUBST(MPIG_VMPI_DEFINED)
AC_SUBST(MPIG_VMPI_PREMAIN_CC_LIB)
AC_SUBST(MPIG_VMPI_PREMAIN_CXX_LIB)
# end of vendor MPI section

#
# miscellaneous settings from mpich2prereq
#
dnl AC_DEFINE_UNQUOTED(MPIG_USING_GRID_PKG,"${MPIG_USING_GRID_PKG:?}",[Grid middleware being used by MPIg])

AC_SUBST(MPIG_SOURCE_DIR)
AC_SUBST(MPIG_BUILD_DIR)

AC_DEFINE_UNQUOTED(MPIG_MPICH2_VERSION,"${MPIG_MPICH2_VERSION:?}",[MPICH2 version])

if test "${MPIG_DEBUG:?}" = "yes" ; then
    AC_DEFINE(MPIG_DEBUG,1,[define if MPIg should include debugging output and checks])
    MPIG_DEBUG_DEFINED=1
else
    MPIG_DEBUG_DEFINED=0
fi
AC_SUBST(MPIG_DEBUG_DEFINED)

dnl AC_DEFINE_UNQUOTED(TYPEOF_MPIG_ALIGNED_T,${TYPEOF_MPIG_ALIGNED_T:?},[type to use insure proper memory alignment for all types])
dnl AC_DEFINE_UNQUOTED(SIZEOF_MPIG_ALIGNED_T,${SIZEOF_MPIG_ALIGNED_T:?},[size of the type used for aligning memory accesses])
dnl AC_DEFINE_UNQUOTED(MEMALIGN_MPIG_ALIGNED_T,${MEMALIGN_MPIG_ALIGNED_T:?},[memory alignment of MPIG_ALIGNED_T])

if test "${MPIG_ROMIO_ENABLED:?}" = "yes" ; then
    ROMIO_ENABLED=1
else
    ROMIO_ENABLED=0
fi
AC_SUBST(ROMIO_ENABLED)

#
# Globus settings from mpich2prereq
#
if test "${MPIG_USING_GRID_PKG}" = "globus" ; then
    if test "${HAVE_GLOBUS_COMMON_MODULE}" = "yes" ; then
        AC_DEFINE(HAVE_GLOBUS_COMMON_MODULE,1,[define if the Globus Common module is installed])
    fi

    if test "${HAVE_GLOBUS_DC_MODULE}" = "yes" ; then
        AC_DEFINE(HAVE_GLOBUS_DC_MODULE,1,[define if the Globus Common module is installed])
    fi

    if test "${HAVE_GLOBUS_USAGE_MODULE:?}" = "yes" ; then
        AC_DEFINE(HAVE_GLOBUS_USAGE_MODULE,1,[define if Globus Usage module is installed])
        AC_DEFINE_UNQUOTED(HAVE_GLOBUS_USAGE_VERSION,"${HAVE_GLOBUS_USAGE_VERSION:?}",[Globus Usage module version])
    fi

    if test "${HAVE_GLOBUS_DUROC_MODULE}" = "yes" ; then
        AC_DEFINE(HAVE_GLOBUS_DUROC_MODULE,1,[define if the Globus DUROC Runtime module is installed])
    fi

    if test "${HAVE_GLOBUS_RENDEZVOUS_MODULE}" = "yes" ; then
        AC_DEFINE(HAVE_GLOBUS_RENDEZVOUS_MODULE,1,[define if the Globus Rendezvous Client C bindings module is installed])
    fi

    if test "${HAVE_GLOBUS_XIO_MODULE:?}" = "yes" ; then
        AC_DEFINE(HAVE_GLOBUS_XIO_MODULE,1,[define if Globus XIO module is installed])
        AC_DEFINE_UNQUOTED(HAVE_GLOBUS_XIO_VERSION,"${HAVE_GLOBUS_XIO_VERSION:?}",[Globus XIO module version])
    fi

    # since mpich2preq-globus sets MPIG_THREADS_PKG to globus, HAVE_GLOBUS_THREADS is automatically defined above in the
    # section on thread packages
    #
    # if test "${HAVE_GLOBUS_THREADS}" = "yes" ; then
    #     AC_DEFINE(HAVE_GLOBUS_THREADS,1,[define if the flavor of Globus being used is multithreaded])
    # fi
fi

#
# setup file substitutions needed to create mpiddefs.h
#
if test "${MPIG_RENAME_SYMBOLS:?}" = "yes" ; then
    MPIG_SYMBOL_MAP_PUBLIC_H=.mpig_symbol_map_public.h
    MPIG_SYMBOL_MAP_INTERNAL_H=.mpig_symbol_map_internal.h
    AC_DEFINE(MPIG_RENAME_SYMBOLS,1,[define if MPI symbols need to be renamed])
    MPIG_RENAME_SYMBOLS_DEFINED=1
else
    MPIG_SYMBOL_MAP_PUBLIC_H=/dev/null
    MPIG_SYMBOL_MAP_INTERNAL_H=/dev/null
    MPIG_RENAME_SYMBOLS_DEFINED=0
fi
AC_SUBST_FILE(MPIG_SYMBOL_MAP_PUBLIC_H)
AC_SUBST_FILE(MPIG_SYMBOL_MAP_INTERNAL_H)
AC_SUBST(MPIG_RENAME_SYMBOLS_DEFINED)

#
# settings imported from the top-level configure
# 
AC_SUBST(AR)
AC_SUBST(RANLIB)
AC_SUBST(MPILIBNAME)
AC_SUBST(PMPILIBNAME)
AC_SUBST(CC)
AC_SUBST(CFLAGS)
AC_SUBST(CPPFLAGS)
AC_SUBST(DEFS)
AC_SUBST(LDFLAGS)
AC_SUBST(LIBS)
PAC_CC_SUBDIR_SHLIBS
AC_SUBST(master_top_srcdir)
AC_SUBST(master_top_builddir)
AC_SUBST(ETAGS)
AC_SUBST(ETAGSADD)

#
# dependency handling
#
AC_SUBST(MAKE_DEPEND_C)

dnl
dnl setting to be included in localdefs.h
dnl
dnl FIXME: MPIG_SAVE_LIBS may contain special regex characters that need to be escaped
dnl
EXTRA_LIBS=`echo ${LIBS} | sed -e "s,^${MPIG_SAVE_LIBS} *,,"`
AC_SUBST(EXTRA_LIBS)

dnl
dnl create config.status, which generates the header files, Makefiles, etc.
dnl
AC_CONFIG_FILES(Makefile)
AC_CONFIG_FILES(examples/Makefile)
AC_CONFIG_FILES(mpiexec)
AC_CONFIG_FILES(mpiddefs.h.out:mpiddefs.h.in)
AC_CONFIG_FILES(localdefs)

dnl add master top source and build directory settings to the beginning of config.status
AC_CONFIG_COMMANDS([master_settings], [],
[
master_top_builddir=${master_top_builddir}
master_top_srcdir=${master_top_srcdir}
])

dnl copy the previous generated mpiexec to the top-level bin directory
AC_CONFIG_COMMANDS([copy_mpiexec],
[
AC_MSG_NOTICE([Copying mpiexec to $master_top_builddir/bin/])
if test ! -d $master_top_builddir/bin ; then
    mkdir $master_top_builddir/bin
fi
chmod 755 mpiexec
cp -pf mpiexec $master_top_builddir/bin/mpiexec
])

dnl generate the symbol renaming header files for inclusion into mpiddefs.h
AC_CONFIG_COMMANDS([symbol_renaming],
[
        AC_MSG_NOTICE([Extracting symbols from the symbol map])
],
[
MPIG_RENAME_SYMBOLS=${MPIG_RENAME_SYMBOLS}
if test "${MPIG_RENAME_SYMBOLS}" = "yes" ; then
    grep '^MPIX\?_' ${srcdir}/mpig_symbol_map.txt | sed -e 's/^/#define /' >.mpig_symbol_map_public.h
    grep '^PMPIX\?_' ${srcdir}/mpig_symbol_map.txt | sed -e 's/^/#define /' >>.mpig_symbol_map_public.h
    [grep '^\#[[:space:]]*define[[:space:]]\+P\?MPI_[[:alnum:]_]\+[[:space:]]\+MPI[RD][[:alnum:]_]\+' \
	$master_top_srcdir/src/include/mpi.h.in | sed -e 's/.*[[:space:]]\(.*\)/^\1[ ]/' >.mpig_symbol_map_public_extras.txt]
    if test -s .mpig_symbol_map_public_extras.txt ; then
        grep -f .mpig_symbol_map_public_extras.txt ${srcdir}/mpig_symbol_map.txt | \
	    sed -e 's/^/#define /' >>.mpig_symbol_map_public.h
	fi
    if test "${MPIG_VMPI_PREMAIN_LIBS_REQUIRED}" = "yes" ; then
       echo '#define main(argc_, argv_) mpig_app_main(argc_, argv_)' >>.mpig_symbol_map_public.h
    fi
    grep -v '^P\?MPI_' ${srcdir}/mpig_symbol_map.txt | grep -v -f .mpig_symbol_map_public_extras.txt \
        ${srcdir}/mpig_symbol_map.txt | sed -e 's/^/#define /' >.mpig_symbol_map_internal.h
fi
])

dnl if the mpiddefs.h file has changed, then copy it to the top-level include directory
AC_CONFIG_COMMANDS([copy_mpiddefs_h],
[
if test ! -d $master_top_builddir/src/include ; then
    mkdir $master_top_builddir/src/include
fi

mpig_copy_file=yes
if test -f $master_top_builddir/src/include/mpiddefs.h ; then
    if diff $master_top_builddir/src/include/mpiddefs.h mpiddefs.h.out >/dev/null 2>&1 ; then
       mpig_copy_file=no
    fi
fi
if test "$mpig_copy_file" = "yes" ; then 
    AC_MSG_NOTICE([Copying mpiddefs.h.out to $master_top_builddir/src/include/])
    cp -pf mpiddefs.h.out $master_top_builddir/src/include/mpiddefs.h
else
    AC_MSG_NOTICE([mpiddefs.h.out has not changed.  skipping copy to top-level include directory.])
fi    
if test "$MPIG_RENAME_SYMBOLS" = "yes" ; then
    true
    # rm -f .mpig_symbol_map_*
fi
])

LAH_OUTPUT_DYNAMIC_TEMPLATES
AC_OUTPUT

notice_msg=`echo "end of configure for the ${device_name} device" | tr '[a-z]' '[A-Z]'`
AC_MSG_NOTICE([$notice_msg])
AC_MSG_NOTICE([----------------------------------------])
