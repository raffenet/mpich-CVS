# 
# Globus device code:          Copyright 2005 Northern Illinois University
# Borrowed MPICH-G2 code:      Copyright 2000 Argonne National Laboratory and Northern Illinois University
# Borrowed MPICH2 device code: Copyright 2001 Argonne National Laboratory
# 
# XXX: INSERT POINTER TO OFFICIAL COPYRIGHT TEXT
# 

AC_PREREQ(2.59)

AC_INIT(configure.in)
dnl AC_INIT(MPI-G, 20050501, mpi@globus.org, mpig)

#
# Set the directory that contains support scripts such as install-sh and config.guess
#
AC_CONFIG_AUX_DIR(../../../confdb)

#
# Definitions will be placed in this file rather than in the DEFS variable
#
AC_CONFIG_HEADER(mpidconf.h)

echo ""
echo "START OF CONFIGURE THE FOR GLOBUS DEVICE"
echo ""

#
# First check that we have a clean build if we are doing a VPATH build
#
if test "`cd $srcdir && pwd`" != "`pwd`" && \
   test -f $srcdir/config.status ; then
    AC_MSG_ERROR([You cannot do a VPATH build if the source directory has been
    configured.  Run "make distclean" in $srcdir first.])
fi

AC_PROG_INSTALL
PAC_PROG_CHECK_INSTALL_WORKS
PAC_PROG_MKDIR_P
PAC_PROG_MAKE

AC_CHECK_HEADERS(unistd.h)

AC_CHECK_FUNCS(gethostname)
if test "$ac_cv_func_gethostname" = "yes" ; then
    # Do we need to declare gethostname?
    PAC_FUNC_NEEDS_DECL([#include <unistd.h>],gethostname)
fi

AC_CHECK_TYPES(bool_t)

#
# Determine if CPP supports variadic macros
#
AC_CACHE_CHECK([whether CPP accepts C99 style variadic macros],
lac_cv_have_c99_variadic_macros,[
AC_TRY_COMPILE([
#include <stdio.h>
#define MY_PRINTF(rank, fmt, ...)  printf("%d: " fmt, rank, ## __VA_ARGS__)
],[
MY_PRINTF(0, "hello");
MY_PRINTF(1, "world %d", 3);
], lac_cv_have_c99_variadic_macros=yes, lac_cv_have_c99_variadic_macros=no)
])
if test $lac_cv_have_c99_variadic_macros = "yes" ; then
    AC_DEFINE(HAVE_C99_VARIADIC_MACROS,,[Define if CPP supports C99 style variadic macros])
fi

AC_CACHE_CHECK([whether CPP accepts GNU style variadic macros],
lac_cv_have_gnu_variadic_macros,[
AC_TRY_COMPILE([
#include <stdio.h>
#define MY_PRINTF(rank, fmt, args...)  printf("%d: " fmt, rank, ## args)
],[
MY_PRINTF(0, "hello");
MY_PRINTF(1, "world %d", 3);
], lac_cv_have_gnu_variadic_macros=yes, lac_cv_have_gnu_variadic_macros=no)
])
if test $lac_cv_have_gnu_variadic_macros = "yes" ; then
    AC_DEFINE(HAVE_GNU_VARIADIC_MACROS,,[Define if CPP supports GNU style variadic macros])
fi

#
# Determine if the compiler defines a symbol containing the function name
#
AC_CACHE_CHECK([whether the compiler defines __func__],
lac_cv_have__func__,[
AC_TRY_RUN([
#include <string.h>
int foo(void);
int foo(void)
{
    return (strcmp(__func__, "foo") == 0);
}
int main(int argc, char ** argv)
{
    return (foo() ? 0 : 1);
}
], lac_cv_have__func__=yes, lac_cv_have__func__=no)
])
if test $lac_cv_have__func__ = "yes" ; then
    AC_DEFINE(HAVE__FUNC__,,[Define if the compiler defines __func__])
fi

AC_CACHE_CHECK([whether the compiler defines __FUNC__],
lac_cv_have_cap__func__,[
AC_TRY_RUN([
#include <string.h>
int foo(void);
int foo(void)
{
    return (strcmp(__FUNC__, "foo") == 0);
}
int main(int argc, char ** argv)
{
    return (foo() ? 0 : 1);
}
], lac_cv_have_cap__func__=yes, lac_cv_have_cap__func__=no)
])
if test $lac_cv_have_cap__func__ = "yes" ; then
    AC_DEFINE(HAVE_CAP__FUNC__,,[Define if the compiler defines __FUNC__])
fi

AC_CACHE_CHECK([whether the compiler sets __FUNCTION__],
lac_cv_have__function__,[
AC_TRY_RUN([
#include <string.h>
int foo(void);
int foo(void)
{
    return (strcmp(__FUNCTION__, "foo") == 0);
}
int main(int argc, char ** argv)
{
    return (foo() ? 0 : 1);
}
], lac_cv_have__function__=yes, lac_cv_have__function__=no)
])
if test $lac_cv_have__function__ = "yes" ; then
    AC_DEFINE(HAVE__FUNCTION__,,[Define if the compiler defines __FUNCTION__])
fi

#
# Determine this machine's endianess
#
AC_CACHE_CHECK([endianess of system],
lac_cv_my_endian,[
AC_TRY_RUN([
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char **argv)
{
    int data;
    char * datap = (char *) &data;
    FILE *f;

    f = fopen("conftest.out", "w");
    data = 10;
    if (*datap == 10)
    {
        fprintf(f, "little\n");
    }
    else if (*(datap + sizeof(int) - 1) == 10)
    {
        fprintf(f, "big\n");
    }
    else
    {
        fprintf(f, "undetermined\n");
    }

    fclose(f);
    exit(0);
}
],lac_cv_my_endian=`cat conftest.out`,
  lac_cv_my_endian="FAILED",
  lac_cv_my_endian=${CROSS_MY_ENDIAN:-undetermined})
])

if test "$lac_cv_my_endian" = "big" ; then
    MPIG_MY_ENDIAN="MPIG_ENDIAN_BIG"
elif test "$lac_cv_my_endian" = "little" ; then
    MPIG_MY_ENDIAN="MPIG_ENDIAN_LITTLE"
else
    AC_MSG_ERROR([Unable to determine endianess of system.  If cross compiling, set CROSS_MY_ENDIAN to "big" or "little".])
fi
AC_DEFINE_UNQUOTED(MPIG_MY_ENDIAN,${MPIG_MY_ENDIAN},[endianess of the system])

#
# determine the size of MPICH2's MPI_AINT
#
AC_MSG_CHECKING([size of MPICH2 MPI_AINT])
eval SIZEOF_MPICH2_AINT="\${SIZEOF_`echo ${MPI_AINT} | tr '[a-z]' '[A-Z]'`}"
AC_MSG_RESULT([$SIZEOF_MPICH2_AINT])

#
# Settings from mpich2prereq
#
AC_DEFINE_UNQUOTED(MPIG_ALIGNED_T,${MPIG_ALIGNED_T},[type to use insure proper memory alignment for all types])
AC_DEFINE_UNQUOTED(SIZEOF_MPIG_ALIGNED_T,${SIZEOF_MPIG_ALIGNED_T},[size of the type used for aligning memory accesses])
AC_DEFINE_UNQUOTED(MEMALIGN_MPIG_ALIGNED_T,${MEMALIGN_MPIG_ALIGNED_T},[memory alignment of MPIG_ALIGNED_T])
AC_DEFINE_UNQUOTED(SIZEOF_VMPI_COMM,${SIZEOF_VMPI_COMM},[size of the vendor MPI_COMM handle])
AC_DEFINE_UNQUOTED(SIZEOF_VMPI_DATATYPE,${SIZEOF_VMPI_DATATYPE},[size of the vendor MPI_DATATYPE handle])
AC_DEFINE_UNQUOTED(SIZEOF_VMPI_REQUEST,${SIZEOF_VMPI_REQUEST},[size of the vendor MPI_REQUEST handle])
AC_DEFINE_UNQUOTED(SIZEOF_VMPI_STATUS,${SIZEOF_VMPI_STATUS},[size of the vendor MPI_REQUEST object])
AC_DEFINE_UNQUOTED(TYPE_VMPI_AINT,${TYPE_VMPI_AINT},[integer type of the same size as the vendor MPI_AINT type])
AC_DEFINE_UNQUOTED(SIZEOF_VMPI_AINT,${SIZEOF_VMPI_AINT},[size of the vendor MPI_AINT type])
AC_DEFINE_UNQUOTED(TYPE_MPICH2_AINT,${MPI_AINT},[integer type of the same size as the MPICH2 MPI_AINT type])
AC_DEFINE_UNQUOTED(SIZEOF_MPICH2_AINT,${SIZEOF_MPICH2_AINT},[size of the MPICH2 MPI_AINT type])
if test "${MPIG_VMPI}" != "no" ; then
    AC_DEFINE(MPIG_VMPI,1,[define if we are building on top of a vendor MPI])
fi 
if test "${MPIG_GLOBUS_THREADED}" != "no" ; then
    AC_DEFINE(MPIG_THREADED,1,[define if Globus is configured with threads, allowing MPIG to use threads internals])
fi 
if test "${MPIG_DEBUG}" != "no" ; then
    AC_DEFINE(MPIG_DEBUG,1,[define if Globus is configured with debugging enabled])
fi
if test "${HAVE_MPI_2COMPLEX}" != "no" ; then
    AC_DEFINE(HAVE_MPI_2COMPLEX,1,[define if vendor has MPI_2COMPLEX])
fi
if test "${HAVE_VMPI_2DOUBLE_COMPLEX}" != "no" ; then
    AC_DEFINE(HAVE_VMPI_2DOUBLE_COMPLEX,1,[define if vendor has MPI_2DOUBLE_COMPLEX])
fi
if test "${HAVE_VMPI_LONG_LONG}" != "no" ; then
    AC_DEFINE(HAVE_VMPI_LONG_LONG,1,[define if vendor has MPI_LONG_LONG])
fi
if test "${HAVE_VMPI_LONG_LONG_INT}" != "no" ; then
    AC_DEFINE(HAVE_VMPI_LONG_LONG_INT,1,[define if vendor has MPI_LONG_LONG_INT])
fi
AC_SUBST(MPIG_SOURCE_DIR)
AC_SUBST(MPIG_BUILD_DIR)

#
# Settings imported from the top-level configure
# 
AC_SUBST(AR)
AC_SUBST(RANLIB)
AC_SUBST(MPILIBNAME)
AC_SUBST(PMPILIBNAME)
AC_SUBST(CC)
AC_SUBST(CFLAGS)
AC_SUBST(CPPFLAGS)
AC_SUBST(DEFS)
AC_SUBST(LDFLAGS)
PAC_CC_SUBDIR_SHLIBS
AC_SUBST(master_top_srcdir)
AC_SUBST(master_top_builddir)

#
# Dependency handling
#
AC_SUBST(MAKE_DEPEND_C)

#
# Create Makefiles, etc.
#
AC_OUTPUT(Makefile mpiexec,
[
    echo "Copying mpiexec to $master_top_builddir/bin/"
    if test ! -d $master_top_builddir/bin ; then
       mkdir $master_top_builddir/bin
    fi
    chmod 755 mpiexec
    cp -pf mpiexec $master_top_builddir/bin/mpiexec
],
[
    master_top_builddir=$master_top_builddir
])
AC_OUTPUT_COMMANDS
echo ""
echo "END OF CONFIGURE THE FOR GLOBUS DEVICE"
echo ""
