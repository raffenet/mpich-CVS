# 
# Globus device code:          Copyright 2005 Northern Illinois University
# Borrowed MPICH-G2 code:      Copyright 2000 Argonne National Laboratory and Northern Illinois University
# Borrowed MPICH2 device code: Copyright 2001 Argonne National Laboratory
# 
# XXX: INSERT POINTER TO OFFICIAL COPYRIGHT TEXT
# 

AC_PREREQ(2.59)

AC_INIT(configure.in)
dnl AC_INIT(MPI-G, 20050501, mpi@globus.org, mpig)

#
# set the directory that contains support scripts such as install-sh and config.guess
#
AC_CONFIG_AUX_DIR(../../../confdb)

#
# definitions will be placed in this file rather than in the DEFS variable
#
AC_CONFIG_HEADER(mpidconf.h)

echo ""
echo "START OF CONFIGURE THE FOR GLOBUS DEVICE"

#
# first check that we have a clean build if we are doing a VPATH build
#
if test "`cd $srcdir && pwd`" != "`pwd`" && \
   test -f $srcdir/config.status ; then
    AC_MSG_ERROR([You cannot do a VPATH build if the source directory has been
    configured.  Run "make distclean" in $srcdir first.])
fi

AC_PROG_INSTALL
PAC_PROG_CHECK_INSTALL_WORKS
PAC_PROG_MKDIR_P
PAC_PROG_MAKE

AC_CHECK_HEADERS(unistd.h)

AC_CHECK_FUNCS(gethostname)
if test "$ac_cv_func_gethostname" = "yes" ; then
    # do we need to declare gethostname?
    PAC_FUNC_NEEDS_DECL([#include <unistd.h>],gethostname)
fi

AC_CHECK_TYPES(bool_t)

#
# determine if CPP supports variadic macros
#
AC_CACHE_CHECK([whether CPP accepts C99 style variadic macros],
lac_cv_have_c99_variadic_macros,[
AC_TRY_COMPILE([
#include <stdio.h>
#define MY_PRINTF(rank, fmt, ...)  printf("%d: " fmt, rank, ## __VA_ARGS__)
],[
MY_PRINTF(0, "hello");
MY_PRINTF(1, "world %d", 3);
], lac_cv_have_c99_variadic_macros=yes, lac_cv_have_c99_variadic_macros=no)
])
if test $lac_cv_have_c99_variadic_macros = "yes" ; then
    AC_DEFINE(HAVE_C99_VARIADIC_MACROS,,[Define if CPP supports C99 style variadic macros])
fi

AC_CACHE_CHECK([whether CPP accepts GNU style variadic macros],
lac_cv_have_gnu_variadic_macros,[
AC_TRY_COMPILE([
#include <stdio.h>
#define MY_PRINTF(rank, fmt, args...)  printf("%d: " fmt, rank, ## args)
],[
MY_PRINTF(0, "hello");
MY_PRINTF(1, "world %d", 3);
], lac_cv_have_gnu_variadic_macros=yes, lac_cv_have_gnu_variadic_macros=no)
])
if test $lac_cv_have_gnu_variadic_macros = "yes" ; then
    AC_DEFINE(HAVE_GNU_VARIADIC_MACROS,,[Define if CPP supports GNU style variadic macros])
fi

#
# determine if the compiler defines a symbol containing the function name
#
AC_CACHE_CHECK([whether the compiler defines __func__],
lac_cv_have__func__,[
AC_TRY_RUN([
#include <string.h>
int foo(void);
int foo(void)
{
    return (strcmp(__func__, "foo") == 0);
}
int main(int argc, char ** argv)
{
    return (foo() ? 0 : 1);
}
], lac_cv_have__func__=yes, lac_cv_have__func__=no)
])
if test $lac_cv_have__func__ = "yes" ; then
    AC_DEFINE(HAVE__FUNC__,,[Define if the compiler defines __func__])
fi

AC_CACHE_CHECK([whether the compiler defines __FUNC__],
lac_cv_have_cap__func__,[
AC_TRY_RUN([
#include <string.h>
int foo(void);
int foo(void)
{
    return (strcmp(__FUNC__, "foo") == 0);
}
int main(int argc, char ** argv)
{
    return (foo() ? 0 : 1);
}
], lac_cv_have_cap__func__=yes, lac_cv_have_cap__func__=no)
])
if test $lac_cv_have_cap__func__ = "yes" ; then
    AC_DEFINE(HAVE_CAP__FUNC__,,[Define if the compiler defines __FUNC__])
fi

AC_CACHE_CHECK([whether the compiler sets __FUNCTION__],
lac_cv_have__function__,[
AC_TRY_RUN([
#include <string.h>
int foo(void);
int foo(void)
{
    return (strcmp(__FUNCTION__, "foo") == 0);
}
int main(int argc, char ** argv)
{
    return (foo() ? 0 : 1);
}
], lac_cv_have__function__=yes, lac_cv_have__function__=no)
])
if test $lac_cv_have__function__ = "yes" ; then
    AC_DEFINE(HAVE__FUNCTION__,,[Define if the compiler defines __FUNCTION__])
fi

#
# determine this machine's endianess
#
AC_CACHE_CHECK([endianess of system],
lac_cv_my_endian,[
AC_TRY_RUN([
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char **argv)
{
    int data;
    char * datap = (char *) &data;
    FILE *f;

    f = fopen("conftest.out", "w");
    data = 10;
    if (*datap == 10)
    {
        fprintf(f, "little\n");
    }
    else if (*(datap + sizeof(int) - 1) == 10)
    {
        fprintf(f, "big\n");
    }
    else
    {
        fprintf(f, "undetermined\n");
    }

    fclose(f);
    exit(0);
}
],lac_cv_my_endian=`cat conftest.out`,
  lac_cv_my_endian="FAILED",
  lac_cv_my_endian=${CROSS_MY_ENDIAN:-undetermined})
])

if test "$lac_cv_my_endian" = "big" ; then
    MPIG_MY_ENDIAN="MPIG_ENDIAN_BIG"
elif test "$lac_cv_my_endian" = "little" ; then
    MPIG_MY_ENDIAN="MPIG_ENDIAN_LITTLE"
else
    AC_MSG_ERROR([Unable to determine endianess of system.  If cross compiling, set CROSS_MY_ENDIAN to "big" or "little".])
fi
AC_DEFINE_UNQUOTED(MPIG_MY_ENDIAN,${MPIG_MY_ENDIAN},[endianess of the system])

#
# determine the size of MPICH2's MPI_AINT, and the printf conversion specifers for MPI_Aint and MPIU_Size_t
#
if test "${MPIG_VMPI:-no}" != "no" ; then
    AC_MSG_CHECKING([size of MPICH2 MPI_AINT])
    eval SIZEOF_MPICH2_AINT="\${SIZEOF_`echo ${MPI_AINT} | tr '[a-z]' '[A-Z]'`}"
    AC_MSG_RESULT([$SIZEOF_MPICH2_AINT])
fi

echo 'INFO: MPI_Aint is "'$MPI_AINT'"'
AC_MSG_CHECKING([printf conversion specifier for MPI_Aint])
eval MPIG_AINT_FMT='"'"%\${MPIG_`echo ${MPI_AINT} | tr '[a-z]' '[A-Z]'`_FMT_MOD}d"'"'
MPIG_AINT_FMT='"'"$MPIG_AINT_FMT"'"'
AC_DEFINE_UNQUOTED(MPIG_AINT_FMT,${MPIG_AINT_FMT:?},[printf conversion specifier for MPI_Aint])
AC_MSG_RESULT([$MPIG_AINT_FMT])

echo 'INFO: MPIU_Size_t is "'$MPIU_SIZE_T'"'
AC_MSG_CHECKING([printf conversion specifier for MPIU_Size_t])
eval MPIG_SIZE_FMT='"'"%\${MPIG_`echo ${MPIU_SIZE_T} | tr '[a-z ]' '[A-Z_]'`_FMT_MOD}u"'"'
MPIG_SIZE_FMT='"'"$MPIG_SIZE_FMT"'"'
AC_DEFINE_UNQUOTED(MPIG_SIZE_FMT,${MPIG_SIZE_FMT:?},[printf conversion specifier for MPIU_Size_t])
AC_MSG_RESULT([$MPIG_SIZE_FMT])

#
# vendor MPI settings from mpich2prereq
#
AC_SUBST(MPIG_VMPI)
AC_SUBST(MPIG_VMPI_DEFINED)
if test "${MPIG_VMPI:?}" != "no" ; then
    MPIG_VMPI_DEFINED=1
    AC_DEFINE(MPIG_VMPI,1,[define if we are building on top of a vendor MPI])

    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_COMM,${SIZEOF_VMPI_COMM:?},[size of the vendor MPI_COMM handle])
    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_DATATYPE,${SIZEOF_VMPI_DATATYPE:?},[size of the vendor MPI_DATATYPE handle])
    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_REQUEST,${SIZEOF_VMPI_REQUEST:?},[size of the vendor MPI_REQUEST handle])
    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_OP,${SIZEOF_VMPI_OP:?},[size of the vendor MPI_OP object])
    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_STATUS,${SIZEOF_VMPI_STATUS:?},[size of the vendor MPI_REQUEST object])
    AC_DEFINE_UNQUOTED(SIZEOF_VMPI_AINT,${SIZEOF_VMPI_AINT:?},[size of the vendor MPI_AINT type])
    AC_DEFINE_UNQUOTED(TYPEOF_MPICH2_AINT,${MPI_AINT:?},[integer type of the same size as the MPICH2 MPI_AINT type])
    AC_DEFINE_UNQUOTED(SIZEOF_MPICH2_AINT,${SIZEOF_MPICH2_AINT:?},[size of the MPICH2 MPI_AINT type])
    if test "${HAVE_VMPI_2COMPLEX:?}" = "yes" ; then
        AC_DEFINE(HAVE_VMPI_2COMPLEX,1,[define if vendor has MPI_2COMPLEX])
    fi
    if test "${HAVE_VMPI_2DOUBLE_COMPLEX:?}" = "yes" ; then
        AC_DEFINE(HAVE_VMPI_2DOUBLE_COMPLEX,1,[define if vendor has MPI_2DOUBLE_COMPLEX])
    fi
    if test "${HAVE_VMPI_LONG_LONG:?}" = "yes" ; then
        AC_DEFINE(HAVE_VMPI_LONG_LONG,1,[define if vendor has MPI_LONG_LONG])
    fi
    if test "${HAVE_VMPI_LONG_LONG_INT:?}" = "yes" ; then
        AC_DEFINE(HAVE_VMPI_LONG_LONG_INT,1,[define if vendor has MPI_LONG_LONG_INT])
    fi
else
    MPIG_VMPI_DEFINED=0
fi

#
# other settings from mpich2prereq
#
AC_SUBST(MPIG_SOURCE_DIR)
AC_SUBST(MPIG_BUILD_DIR)
AC_SUBST(MPIG_GLOBUS_DUROC_INSTALLED)
if test "${MPIG_GLOBUS_DUROC_INSTALLED:?}" = "yes" ; then
    AC_DEFINE(MPIG_GLOBUS_DUROC_INSTALLED,1,[define if the Globus DUROC Runtime module is installed])
fi
AC_SUBST(MPIG_GLOBUS_RENDEZVOUS_INSTALLED)
if test "${MPIG_GLOBUS_RENDEZVOUS_INSTALLED:?}" = "yes" ; then
    AC_DEFINE(MPIG_GLOBUS_RENDEZVOUS_INSTALLED,1,[define if the Globus Rendezvous Client C bindings module is installed])
fi
if test "${MPIG_GLOBUS_THREADED:?}" = "yes" ; then
    AC_DEFINE(MPIG_THREADED,1,[define if Globus is configured with threads, allowing MPIG to use threads internals])
fi 
if test "${MPIG_DEBUG:?}" = "yes" ; then
    AC_DEFINE(MPIG_DEBUG,1,[define if Globus is configured with debugging enabled])
fi
AC_DEFINE_UNQUOTED(MPIG_MPICH2_VERSION,"${MPIG_MPICH2_VERSION:?}",[MPICH2 version])
AC_DEFINE_UNQUOTED(MPIG_XIO_VERSION,"${MPIG_XIOV_ERSION:?}",[Globus XIO version])
AC_DEFINE_UNQUOTED(TYPEOF_MPIG_ALIGNED_T,${TYPEOF_MPIG_ALIGNED_T:?},[type to use insure proper memory alignment for all types])
dnl AC_DEFINE_UNQUOTED(SIZEOF_MPIG_ALIGNED_T,${SIZEOF_MPIG_ALIGNED_T:?},[size of the type used for aligning memory accesses])
dnl AC_DEFINE_UNQUOTED(MEMALIGN_MPIG_ALIGNED_T,${MEMALIGN_MPIG_ALIGNED_T:?},[memory alignment of MPIG_ALIGNED_T])
AC_DEFINE_UNQUOTED(MPIG_PTR_CAST,${MPIG_PTR_CAST:?},[an unsigned integer big enough to hold a pointer])
AC_DEFINE_UNQUOTED(MPIG_PTR_FMT,${MPIG_PTR_FMT:?},[printf conversion specifier for a pointer converted to a MPIG_PTR_CAST])
if test "${MPIG_ROMIO_ENABLED:?}" = "yes" ; then
    ROMIO_ENABLED=1
else
    ROMIO_ENABLED=0
fi
AC_SUBST(ROMIO_ENABLED)

#
# setup file substitutions needed to create mpiddefs.h
#
if test "${MPIG_VMPI:?}" != "no" ; then
    MPIG_SYMBOL_MAP_MPI_H=.mpig_symbol_map_mpi.h
    MPIG_SYMBOL_MAP_PMPI_H=.mpig_symbol_map_pmpi.h
    MPIG_SYMBOL_MAP_INTERNAL_H=.mpig_symbol_map_internal.h
else
    MPIG_SYMBOL_MAP_MPI_H=/dev/null
    MPIG_SYMBOL_MAP_PMPI_H=/dev/null
    MPIG_SYMBOL_MAP_INTERNAL_H=/dev/null
fi
AC_SUBST_FILE(MPIG_SYMBOL_MAP_MPI_H)
AC_SUBST_FILE(MPIG_SYMBOL_MAP_PMPI_H)
AC_SUBST_FILE(MPIG_SYMBOL_MAP_INTERNAL_H)

#
# settings imported from the top-level configure
# 
AC_SUBST(AR)
AC_SUBST(RANLIB)
AC_SUBST(MPILIBNAME)
AC_SUBST(PMPILIBNAME)
AC_SUBST(CC)
AC_SUBST(CFLAGS)
AC_SUBST(CPPFLAGS)
AC_SUBST(DEFS)
AC_SUBST(LDFLAGS)
PAC_CC_SUBDIR_SHLIBS
AC_SUBST(master_top_srcdir)
AC_SUBST(master_top_builddir)

#
# dependency handling
#
AC_SUBST(MAKE_DEPEND_C)

#
# create Makefile, etc.
#
AC_OUTPUT(Makefile examples/Makefile mpiexec mpiddefs.h.out:mpiddefs.h.in,
[
    echo "Copying mpiexec to $master_top_builddir/bin/"
    if test ! -d $master_top_builddir/bin ; then
        mkdir $master_top_builddir/bin
    fi
    chmod 755 mpiexec
    cp -pf mpiexec $master_top_builddir/bin/mpiexec

    if test ! -d $master_top_builddir/src/include ; then
        mkdir $master_top_builddir/src/include
    fi

    # if the mpiddefs.h file has changed, then copy it to the top-level include directory
    mpig_copy_file=yes
    if test -f $master_top_builddir/src/include/mpiddefs.h ; then
        if diff $master_top_builddir/src/include/mpiddefs.h mpiddefs.h.out >/dev/null 2>&1 ; then
	   mpig_copy_file=no
	fi
    fi
    if test "$mpig_copy_file" = "yes" ; then 
        echo "Copying mpiddefs.h.out to $master_top_builddir/src/include/"
	cp -pf mpiddefs.h.out $master_top_builddir/src/include/mpiddefs.h
    else
	echo "mpiddefs.h.out has not changed.  skipping copy to top-level include directory."
    fi    
    if test "$MPIG_VMPI" = "yes" ; then
	rm .mpig_symbol_map_mpi.h .mpig_symbol_map_pmpi.h .mpig_symbol_map_internal.h
    fi
],
[
    master_top_builddir=$master_top_builddir
    MPIG_VMPI=$MPIG_VMPI
    if test "$MPIG_VMPI" = "yes" ; then
        echo "Extracting symbols from the symbol map"
	grep '^MPI_' $srcdir/mpig_symbol_map.txt | sed -e 's/^/#define /' > .mpig_symbol_map_mpi.h
	grep '^PMPI_' $srcdir/mpig_symbol_map.txt | sed -e 's/^/#define /' > .mpig_symbol_map_pmpi.h
	grep -v '^P\?MPI_' $srcdir/mpig_symbol_map.txt | sed -e 's/^/#define /' > .mpig_symbol_map_internal.h
    fi
])
AC_OUTPUT_COMMANDS
echo "END OF CONFIGURE THE FOR GLOBUS DEVICE"
echo ""
