-------------------------------------------------------------------------------
                              Known Deficiencies
-------------------------------------------------------------------------------

- MPI_IRECV operations that are not explicitly completed before MPI_FINALIZE is
  called may fail to complete before MPI_FINALIZE returns, and thus never
  complete.  Furthermore, any matching send operations may erroneously fail.
  By explicitly completed, we mean that the request associated with the
  operation is completed by one of the MPI_TEST or MPI_WAIT routines.

- MPI_INTERCOMM_CREATE does not work correctly when the union of the local and
  remote communicators are not already part of an existing (intra or inter)
  communicator.  For example, if communicator A spawns a set of processes whose
  MPI_COMM_WORLD we will refer to as communicator B.  Likewise, communicator B
  spawns a set of processes whose MPI_COMM_WORLD we will refer to as
  communicator C.  Despite being a legal request, MPI_INTERCOMM_CREATE will
  fail to create a new intercommunicator between A and C using a commom process
  in B.

- C++ Binding:
  The following functions do not yet have C++ bindings
  Grequest::Create
  Win::Create_keyval
  Type::Create_keyval
  Comm::Join  
  
  There is an unidentified problem with the intercommunicator collective
  routines, except for Intercomm::Barrier.

  The MPI datatypes corresponding to Fortran datatypes are not available
  (e.g., no MPI::DOUBLE_PRECISION).

  The Comm class is not an Abstract Base Class (ABC).  This does not 
  affect correct MPI programs, but will allow some incorrect programs to 
  compile.  In addition, no functions are virtual; the standard requires
  most (but not all) to be declared virtual. Again, most correct programs
  will not notice this limitation.

  The C++ binding does not implement a separate profiling interface, 
  as allowed by the MPI-2 Standard (Section 10.1.10 Profiling).  

  With the exception of the profiling interface, future releases of MPICH2 
  will address these limitations of the C++ binding.

- MPI_COMM_SPAWN_MULTIPLE does not work properly when count is greater
  than one, effectively making it the same as MPI_COMM_SPAWN.

- The communicator passed to MPI_COMM_CONNECT and MPI_COMM_ACCEPT may
  not include a process for which any process in the remote
  communicator already shares an existing or previously existing
  communicator.

- For passive target RMA, there is no asynchronous agent at the target
  that will cause progress to occur. Progress occurs only when the user
  calls an MPI function at the target (which could well be MPI_Win_free).
