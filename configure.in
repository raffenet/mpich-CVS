dnl Process this file with autoconf to produce a configure script.
dnl
dnl aclocal_cache.m4, included by sowing/confdb/aclocal.m4, fixes 
dnl bugs in autoconf caching.
dnl
dnl The file name here refers to a file in the source being configured
AC_INIT(src/include/mpiimpl.h)
#
# Try to find the version
if test -s "$srcdir/maint/Version" ; then
    VERSION="`cat $srcdir/maint/Version`"
else
    VERSION="0.97-CVS"
fi
AC_SUBST(VERSION)
CONFIGURE_ARGUMENTS="$*"
AC_SUBST(CONFIGURE_ARGUMENTS)
dnl
if test -n "$*" ; then
    echo "Configuring MPICH2 version $VERSION with $@"
else 
    echo "Configuring MPICH2 version $VERSION"
fi
dnl
dnl Definitions will be placed in this file rather than in the DEFS variable
AC_CONFIG_HEADER(src/include/mpichconf.h)
dnl
dnl Set the directory that contains support scripts such as install-sh and
dnl config.guess
AC_CONFIG_AUX_DIR(confdb)
dnl
dnl Use AC_ARG_ENABLE to look for --enable-feature and AC_ARG_WITH to look for
dnl --with-capability
dnl
dnl Enable better caching control
PAC_ARG_CACHING
dnl
AC_ARG_ENABLE(echo, 
[--enable-echo  - Turn on strong echoing. The default is enable=no.] ,set -x)
dnl
AC_ARG_ENABLE(strict,[--enable-strict - Turn on strict debugging with gcc],,enable_strict=no)
dnl
AC_ARG_ENABLE(coverage,
[--enable-coverage - Turn on coverage analysis using gcc and gcov],,
enable_coverage=no)
dnl
AC_ARG_ENABLE(error-checking,
[--enable-error-checking=level - Control the amount of error checking.  
level may be 
    no        - no error checking
    runtime   - error checking controllable at runtime through environment 
                variables
    all       - error checking always enabled],,enable_error_checking=all)
dnl
AC_ARG_ENABLE(error-messages,
[--enable-error-messages=level - Control the amount of detail in error 
  messages.  Level may be
    all       - Maximum amount of information
    generic   - Only generic messages (no information about the specific
                instance)
    class     - One message per MPI error class
    none      - No messages],,enable_error_messages=all)
dnl
AC_ARG_ENABLE(timing,
[--enable-timing=level - Control the amount of timing information 
collected by the MPICH implementation.  level may be
    none    - Collect no data
    all     - Collect lots of data
    runtime - Runtime control of data collected
The default is none.],,enable_timing=none)
dnl
AC_ARG_ENABLE(threads,
[--enable-threads=level - Control the level of thread support in the 
MPICH implementation.  The following levels are supported.
    single - No threads (MPI_THREAD_SINGLE)
    funneled - Only the main thread calls MPI (MPI_THREAD_FUNNELED)
    serialized - User serializes calls to MPI (MPI_THREAD_SERIALIZED)
    multiple[:impl] - Fully multi-threaded (MPI_THREAD_MULTIPLE)
The default is funneled.  If enabled and no level is specified, the
level is set to multiple.  If disabled, the level is set to single.
When the level is set to multiple, an implementation may also be
specified.  The following implementations are supported.
    global_mutex - a single global lock guards access to all MPI functions.
    global_monitor - a single monitor guards access to all MPI functions.
The default implementation is global_mutex.],,
enable_threads=funneled)
if test "$enable_threads" = "yes" ; then 
    enable_threads=multiple
elif test "$enable_threads" = "no" ; then
    enable_threads=single
fi
dnl
AC_ARG_ENABLE(g,
[--enable-g=option - Control the level of debugging support in the MPICH
implementation.  option may be a list of common separated names including
    none   - No debugging
    handle - Trace handle operations
    dbg    - Add compiler -g flags
    all    - All of the above choices],,enable_g=none)
dnl
dnl
dnl --enable-sharedlibs=kind is set with the PAC_ARG_SHAREDLIBS macro 
dnl sharedlibs support has been withdrawn
dnl
dnl --enable-fast
AC_ARG_ENABLE(fast,
[--enable-fast - pick the appropriate options for fast execution.  This
                turns off error checking and timing collection],,
enable_fast=no)
dnl
AC_ARG_ENABLE(f77,
[--enable-f77 - Enable Fortran 77 bindings],,enable_f77=yes)
AC_ARG_ENABLE(f90,
[--enable-f90 - Enable Fortran 90 bindings],,enable_f90=no)
AC_ARG_ENABLE(cxx,
[--enable-cxx - Enable C++ bindings],,enable_cxx=yes)
dnl
AC_ARG_ENABLE(romio,
[--enable-romio - Enable ROMIO MPI I/O implementation],
,enable_romio=yes)
dnl
AC_ARG_ENABLE(nmpi-as-mpi,
[--enable-nmpi-as-mpi - Use MPI rather than PMPI routines for MPI routines,
 such as the collectives, that may be implemented in terms of other MPI 
 routines],,enable_nmpi_as_mpi=no)
dnl
dnl With options
dnl "default" is a special device that allows MPICH to choose one based on 
dnl the environment.
AC_ARG_WITH(device,
[--with-device=name - Specify the communication device for MPICH.],,
with_device=default)
dnl
AC_ARG_WITH(pmi, [--with-pmi=name - Specify the pmi interface for MPICH.],,
with_pmi=default)
dnl
AC_ARG_WITH(pm, [--with-pm=name - Specify the process manager for MPICH.
      Multiple process managers may be specified as long as they all use
      the same pmi interface by separating them with colons.  The 
      mpiexec for the first named process manager will be installed.
      Example: --with-pm=forker:mpd:remshell builds the three process 
      managers forker, mpd, and remshell; only the mpiexec from forker
      is installed into the bin directory.],,
with_pm=default)
dnl
AC_ARG_WITH(thread-package,
[--with-thread-package=package - Thread package to use.  Supported thread
packages include:
    posix or pthreads - POSIX threads
    solaris - Solaris threads (Solaris OS only)
The default package is posix.],,
with_thread_package=posix)
if test "$with_thread_package" = "yes" ; then
    AC_MSG_ERROR([a thread package must be specified with the --with-thread-package option])
elif test "$with_thread_package" = "no" ; then
    AC_MSG_ERROR([--without-thread-package is not supported])
fi
dnl
AC_ARG_WITH(logging,
[--with-logging=name - Specify the logging library for MPICH.],,
with_logging=default)
AC_ARG_WITH(mpe,
[--with-mpe - Build the MPE (MPI Parallel Environment) routines],,
with_mpe=default)
dnl
AC_ARG_ENABLE(weak-symbols,
[--enable-weak-symbols - Use weak symbols to implement PMPI routines (default)],,
enable_weak_symbols=yes)
dnl
AC_ARG_WITH(htmldir,[--with-htmldir=dir - Specify the directory for html documentation],,
with_htmldir='${prefix}/www')
AC_ARG_WITH(docdir,[--with-docdir=dir - Specify the directory for documentation],,
with_docdir='${prefix}/doc')
dnl
dnl
AC_ARG_WITH(cross,
[--with-cross=file - Specify the values of variables that configure cannot
determine in a cross-compilation environment],,with_cross=no)
dnl
dnl Flavor is used to setup separate directories for the flavor-specific
dnl code (e.g., libraries that depend on a particular thread library) from
dnl the generic files (e.g., the manual pages).
AC_ARG_WITH(flavor,
[--with-flavor=name - Set the name to associate with this flavor of MPICH],,)
dnl
dnl
dnl
AC_ARG_WITH(namepublisher,
[--with-namepublisher=name - Choose the system that will support 
                             MPI_PUBLISH_NAME and MPI_LOOKUP_NAME.  Options
                             include
                               no (no service available)
                               pmiext  (service using a pmi extension,
                                        usually only within the same MPD ring)
			       file:directory
                               ldap:ldapservername
                             Only no and file have been implemented so far.],,
with_namepublisher=file)

# First check that we have a clean build if we are doing a VPATH build
PAC_VPATH_CHECK(src/include/mpi.h src/env/mpicc src/env/mpicc.conf)
if test "`cd $srcdir && pwd`" != "`pwd`" ; then
    if test -d $srcdir/lib ; then
        AC_MSG_ERROR([You cannot do a VPATH build if the source directory has been 
    configured.  Remove the lib directory in $srcdir first.])
    fi
fi
dnl
# Set default variable values
MPILIBNAME=${MPILIBNAME:-"mpich"}
dnl Process any enable or with values
dnl We must do enable-fast first, because it changes the other enable values
if test "$enable_fast" = "yes" ; then
    enable_error_checking=no
    enable_error_messages=no
    enable_timing=no
    enable_g=no
    AC_DEFINE(NDEBUG,1,[Define to suppress assertions])
fi
dnl error-checking
case "$enable_error_checking" in 
    no)
    ;;
    all|yes|runtime)
    error_checking_kind=`echo $enable_error_checking | \
    tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
    error_checking_kind=MPID_ERROR_LEVEL_$error_checking_kind
    AC_DEFINE_UNQUOTED(HAVE_ERROR_CHECKING,$error_checking_kind,[Define to enable error checking])
    ;;
    *)
    AC_MSG_WARN([Unknown value $enable_error_checking for enable-error-checking])
    ;;
esac
dnl
dnl error-messages
case "$enable_error_messages" in 
    no|none)
        error_message_kind="MPICH_ERROR_MSG_NONE"
    ;;
    all|yes)
	error_message_kind="MPICH_ERROR_MSG_ALL"
    ;;
    generic)
	error_message_kind="MPICH_ERROR_MSG_GENERIC"
    ;;
    class)
	error_message_kind="MPICH_ERROR_MSG_CLASS"
    ;;
    *)
    AC_MSG_WARN([Unknown value $enable_error_messages for enable-error-messages])
    ;;
esac
AC_DEFINE_UNQUOTED(MPICH_ERROR_MSG_LEVEL,$error_message_kind,[define to enable error messages])
dnl
dnl enable-timing and with-logging
dnl
dnl Still to do: add subsets: e.g., class=pt2pt,class=coll.  See mpich2 doc
dnl
collect_stats=false
logging_required=false
timing_name=$enable_timing
case "$enable_timing" in
    no)
    timing_name=none
    ;;
    time)
    collect_stats=true
    ;;
    log|log_detailed)
    logging_required=true
    ;;
    yes)
    timing_name=all
    collect_stats=true
    logging_required=true
    ;;
    all|runtime)
    collect_stats=true
    logging_required=true
    ;;
    none)
    ;;
    *)
    AC_MSG_WARN([Unknown value $enable_timing for enable-timing])
    enable_timing=no
    timing_name=none
    ;; 
esac
case $with_logging in 
    yes)
    logging_name=rlog
    ;;
    no)
    logging_name=none
    ;;
    default)
    if test "$logging_required" = "true" ; then
        logging_name=rlog
    else
        logging_name=none
    fi
    ;;
    *)
    logging_name=$with_logging
    ;;
esac
logging_subsystems=
if test "$logging_name" != "none" ; then
    logdir=$srcdir/src/util/logging
    logging_subsystems="$logging_subsystems src/util/logging/$logging_name"
    logging_subdirs=$logging_name
    for dir in $logging_subdirs ; do
        if test ! -d $logdir/$dir ; then
	    AC_MSG_WARN([$logdir/$dir does not exist.  Logging library $logging_name has been diabled.])
	    logging_name=none
        fi
    done
    for dir in $logging_subsystems ; do
        if test ! -x $srcdir/$dir/configure ; then
	    AC_MSG_WARN([$logdir/$dir has no configure.  Logging library $logging_name has been disabled.])
	    logging_name=none
        fi
    done
fi
if test "$logging_name" != "none" ; then
    if test "$enable_timing" != "no" ; then
	if test "$enable_timing" = "none" ; then
	    enable_timing=log
	    timing_name=log
    	fi
	logging_dir=logging
	subsystems="$subsystems $logging_subsystems"
    else
	AC_MSG_WARN([Timing was disabled.  Logging has been disabled as well.])
	with_logging=no
	logging_name=none
        logging_dir=
        logging_subdirs=
    fi
else
    if test "$logging_required" = "true" ; then
	AC_MSG_WARN([Timing was enabled with log option but no logging library is available.  Timing has been disabled.])
	enable_timing=no
	timing_name=none
    fi
    logging_dir=
    logging_subdirs=
fi
if test "$timing_name" != "none" ; then
    timing_kind=`echo $timing_name | \
       tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
    timing_kind=MPID_TIMING_KIND_$timing_kind
    AC_DEFINE_UNQUOTED(HAVE_TIMING,$timing_kind,[define to enable timing collection])
    if test "$collect_stats" = "true" ; then
        AC_DEFINE(COLLECT_STATS,1,[define to enable collection of statistics])
    fi
fi
AC_SUBST(logging_dir)
AC_SUBST(logging_name)
AC_SUBST(logging_subdirs)
use_logging_variable="MPID_LOGGING_`echo $logging_name | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`"
AC_DEFINE_UNQUOTED(USE_LOGGING,$use_logging_variable,[define to choose logging library])
dnl
dnl threads
dnl
case "$enable_threads" in 
    single|funneled)
    thread_pkg_required=no
    thread_impl=none
    ;;
    serialized)
    AC_MSG_ERROR([MPI_THREAD_SERIALIZED not implemented])
    thread_pkg_required=yes
    thread_impl=none
    ;;
    multiple)
    AC_MSG_ERROR([MPI_THREAD_MULTIPLE not implemented])
    thread_pkg_required=yes
    thread_impl=global_mutex
    ;;
    multiple:*)
    AC_MSG_ERROR([MPI_THREAD_MULTIPLE not implemented])
    thread_pkg_required=yes
    thread_impl="`echo $enable_threads | sed -e 's/.*://'`"
    case "$thread_impl" in 
	global_mutex)
	;;
	global_monitor)
	;;
	*)
	AC_MSG_ERROR(["$thread_impl" is not a valid multi-thread implementation for MPICH2])     
	;;
    esac
    ;;
    *)
    AC_MSG_ERROR(["$enable_threads" is not a valid value for --enable-threads])     
    ;;
esac
AC_DEFINE(MPICH_SINGLE_THREADED,1,[FIXME: for now always defined regardless of thread support])
mpich_thread_level="MPI_THREAD_`echo $enable_threads | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`"
AC_DEFINE_UNQUOTED(MPICH_THREAD_LEVEL,$mpich_thread_level,[Level of thread support selected at compile time])
mpich_thread_impl="MPICH_THREAD_IMPL_`echo $thread_impl | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`"
AC_DEFINE_UNQUOTED(USE_THREAD_IMPL,$mpich_thread_impl,[Multi-threaded implementation selected at compile time])
dnl
dnl	case "$enable_threads" in
dnl	    no|single)
dnl	    AC_DEFINE(MPICH_SINGLE_THREADED,1,[define to for single threaded])
dnl	    ;;
dnl	    runtime=*|multiple=*)
dnl	    thread_type=`echo $enable_threads | sed -e 's/^.*=//'g`
dnl	    ;;
dnl	    all|yes|multiple|runtime)
dnl	    thread_type=pthread
dnl	    ;;
dnl	    *)
dnl	    AC_MSG_WARN([Unknown value $enable_threads for enable-threads])
dnl	    ;; 
dnl	esac
dnl
dnl enable-g
# strip off multiple options, separated by commas
save_IFS="$IFS"
IFS=","
for option in $enable_g ; do
    case "$option" in 
        debug|dbg)
	CFLAGS="$CFLAGS -g"
	;;
        no|none)
	;;
	handle)
	AC_DEFINE(MPICH_DEBUG_HANDLES,1,[Define to enable handle checking])
	;;
	all|yes)
	AC_DEFINE(MPICH_DEBUG_INTERNAL,1,[Define to compile in optional debugging tests and output])
	AC_DEFINE(MPICH_DEBUG_NESTING,1,[Define to check nesting level on exit])
	CFLAGS="$CFLAGS -g"
	;;
	*)
	AC_MSG_WARN([Unknown value $enable_g for enable-g])
	;;
    esac
done
IFS="$save_IFS"

AC_SUBST(debugger_dir)
pac_cross_compiling=no
if test "$with_cross" != "no" ; then
    if test -s "$with_cross" ; then
        AC_MSG_RESULT([Reading values from cross-compilation file $with_cross])
        . $with_cross
	# Autoconf 2.52 no longer sets cross_compiling except with the
	# awkward "targethost" options.
	pac_cross_compiling=yes
	cross_compiling=yes
	ac_cv_prog_cc_cross=yes
	ac_cv_prog_f77_cross=yes
dnl 	ac_cv_prog_f90_cross=yes
        ac_cv_prog_cxx_cross=yes
        export cross_compiling
	# Export all cross variables.  Any subsidiary configure should also
        # export CROSS_xxx
	rm -f confcross
	(set) 2>&1 | grep CROSS_ | \
	      sed -e 's/^/export /g' -e 's/=.*//g' > confcross
	. confcross
	rm -f confcross      
    fi
fi

if test "$enable_nmpi_as_mpi" = yes ; then
   AC_DEFINE(USE_MPI_FOR_NMPI,1,[Define if the NMPI names should use MPI instead of PMPI])
fi
#
# Set the defaults for directories that are not included in configure's
# repetoire
if test -n "$with_htmldir" ; then 
    htmldir=$with_htmldir
else
    htmldir='${prefix}/www'
fi
AC_SUBST(htmldir)

if test -n "$with_docdir" ; then 
    docdir=$with_docdir
else
    docdir='${prefix}/doc'
fi
AC_SUBST(docdir)

dnl with-device
if test "$with_device" = "default" ; then
    # Pick the device.  For now, always choose ch3
    with_device=ch3
fi
dnl Extract the device name from any options
device_name=`echo $with_device | sed -e 's/:.*$//'`
changequote(<<,>>)
device_args=`echo $with_device | sed -e 's/^[^:]*//' -e 's/^://'`
changequote([,])
export device_name
export device_args
dnl
dnl This test is complicated by the fact that top_srcdir is not set until
dnl the very end of configure.  Instead, we get it ourselves
if test -z "$top_srcdir" ; then
   use_top_srcdir=$srcdir   
else
   use_top_srcdir=$top_srcdir
fi
if test -z "$master_top_srcdir" ; then 
    # This needs to be an absolute pathname
    case "$use_top_srcdir" in
    /) ;;
    *)
        use_top_srcdir=`(cd $use_top_srcdir ; pwd)`
	;;	
    esac
    master_top_srcdir=$use_top_srcdir
fi
# Get the directory that we're running in...
if test -z "$master_top_builddir" ; then
   master_top_builddir=`pwd`
fi
export master_top_builddir
AC_SUBST(master_top_builddir)
AC_SUBST(master_top_srcdir)
export master_top_srcdir
master_top_builddir="`pwd`"
AC_SUBST(master_top_builddir)
export master_top_builddir
dnl
dnl This goes here because we need the top_srcdir
FROM_MPICH2=yes
export FROM_MPICH2
if test "$enable_romio" = "yes" ; then
   if test -d $use_top_srcdir/src/mpi/romio ; then
       subsystems="$subsystems src/mpi/romio"
       AC_DEFINE(HAVE_ROMIO,1,[Define if ROMIO is enabled])
       # Set environment variables that the romio configure expects
       romio_dir=romio
       AC_SUBST(romio_dir)
       export use_top_srcdir
       top_build_dir=`pwd`
       export top_build_dir
       # if there is no $top_build_dir/lib, romio puts lib in wrong place
       dnl This test used -e under Linux, but not all test programs understand
       dnl -e
       if test ! -d lib ; then mkdir lib ; fi
       # tell mpi.h to include mpio.h
       PAC_HAVE_ROMIO
   else
       AC_MSG_WARN([ROMIO src directory is not available])
       # Check for local developers
       if test -d /home/MPI/cvsMaster/romio -o -d /homes/MPI/cvsMaster/romio ; then
           AC_MSG_WARN([You need to check ROMIO out with 
          cd $use_top_srcdir/src/mpi
          cvs -d /home/MPI/cvsMaster checkout romio
	  followed by
	  cd ../.. && maint/updatefiles
          ])
       fi
   fi
fi
dnl
#
if test "$enable_f77" = "yes" ; then
   # We must add the include directories.  We have to wait until here
   # so that the paths will be defined.
   # FIXME: We should not need this
   CPPFLAGS="$CPPFLAGS -I${master_top_srcdir}/src/binding/f77 -I`pwd`/src/binding/f77"
fi
#
if test ! -d $use_top_srcdir/src/mpid/$device_name ; then
dnl     WAIT UNTIL WE INCLUDE A DEVICE
dnl     AC_MSG_ERROR([Device $device_name is unknown)]
    AC_MSG_WARN([Device $device_name is unknown])
elif test ! -x $use_top_srcdir/src/mpid/$device_name/configure ; then
    AC_MSG_WARN([Device $device_name has no configure])
    device_name=""
else 
    # Add the device to the configure list
    devsubsystems="$devsubsystems src/mpid/$device_name"
    dnl Make device_name available to subdirs
fi
AC_SUBST(device_name)
dnl with-pmi
if test "$with_pmi" = "default" -o "$with_pmi" = "yes" ; then
    with_pmi=simple
fi
pmi_name=$with_pmi
dnl
dnl FIXME: Details like this should not be in the top-level configure
if test "$with_pmi" = "smpd" ; then
    AC_DEFINE(USE_HUMAN_READABLE_TOKENS,1,[Define to use ='s and spaces in the string utilities.])
fi
dnl
if test ! -d $use_top_srcdir/src/pmi/$pmi_name ; then
    AC_MSG_WARN([$use_top_srcdir/src/pmi/$pmi_name does not exist. PMI is unknown])
elif test ! -x $use_top_srcdir/src/pmi/$pmi_name/configure ; then
    AC_MSG_WARN([pmi $pmi_name has no configure or Makefile])
    pmi_name=""
else
    subsystems="$subsystems src/pmi/$pmi_name"
fi
AC_SUBST(pmi_name)
dnl with-pm
if test "$with_pmi" = "uni" -a "$with_pm" = "default" ; then
    with_pm=""
fi
if test "$with_pm" = "default" -o "$with_pm" = "yes" ; then
    with_pm=mpd
fi
pm_name=$with_pm
dnl
dnl Eventually, we should allow multiple pm names, separated by :
dnl Set the value MANY_PM to yes in this case
dnl
MANY_PM=no
AC_SUBST(MANY_PM)
for pm_name in `echo $with_pm | sed -e 's/:/ /g'` ; do
    if test -z "$first_pm_name" ; then
       first_pm_name=$pm_name
    else 
       other_pm_names="$other_pm_names $pm_name"
    fi
    if test ! -d $use_top_srcdir/src/pm/$pm_name ; then
        AC_MSG_WARN([$use_top_srcdir/src/pm/$pm_name does not exist. PM is unknown])
    elif test ! -x $use_top_srcdir/src/pm/$pm_name/configure ; then
        AC_MSG_WARN([pm $pm_name has no configure])
        pm_name=""
    else
        subsystems="$subsystems src/pm/$pm_name"
        if test -f $use_top_srcdir/src/pm/$pm_name/setup_pm ; then 
	    echo sourcing $use_top_srcdir/src/pm/$pm_name/setup_pm
	    . $use_top_srcdir/src/pm/$pm_name/setup_pm
	fi
    fi
done
dnl pm_name is the *primary* pm
pm_name=$first_pm_name
AC_SUBST(pm_name)
AC_SUBST(other_pm_names)

if test $with_mpe != no ; then
    if test ! -d $use_top_srcdir/src/mpe2 ; then
        if test $with_mpe = yes ; then
	    # No warning message on the default
            AC_MSG_WARN([No MPE directory available])
        fi
    elif test ! -x $use_top_srcdir/src/mpe2/configure ; then
        if test $with_mpe = yes ; then
	    # No warning message on the default
            AC_MSG_WARN([No configure available for MPE])
        fi
    else
        subsystems="$subsystems src/mpe2"
	other_install_dirs="$other_install_dirs src/mpe2"
	mpe_dir=mpe2
	# Make sure that MPE knows that we're building from MPICH
        # (similar to ROMIO)
        FROM_MPICH2=yes
        export FROM_MPICH2
	# Temporarily replace the default NONE value for exec_prefix
	# and prefix with the actual, default values.
	savePrefix=$prefix
	saveExecprefix=$exec_prefix
	test "x$prefix" = xNONE && prefix=$ac_default_prefix
	test "x$exec_prefix" = xNONE && exec_prefix=$prefix
	eval actualbindir=$bindir
	# MPI_CC and MPIF77 must use the local (build) bin dir, not
	# the installatoin bin dir
	#MPI_CC=$actualbindir/mpicc
	#MPI_F77=$actualbindir/mpif77
	#eval actuallibdir=$libdir
	#MPI_LIBS="-L$actuallibdir -lmpich -lpmpich"
	buildbindir=`pwd`/bin
	MPI_CC=$buildbindir/mpicc
	MPI_F77=$buildbindir/mpif77
	prefix=$savePrefix
	exec_prefix=$saveExecprefix
	# NOTE: You must append LIBS to MPI_LIBS before invoking the mpe
	# configure
	export MPI_CC
	export MPI_F77
	#export MPI_LIBS
        export use_top_srcdir
        top_build_dir=`pwd`
        export top_build_dir
    fi
fi
AC_SUBST(mpe_dir)
AC_SUBST(other_install_dirs)
#

# The bindings must be the *last* subsystems configured, since they may
# need to inherit libraries and/or options required by the other subsystems
# (e.g., extra libraries required for ROMIO)
if test "$enable_f77" = "yes" ; then
   bindingsubsystems="$bindingsubsystems src/binding/f77"
   bindings="$bindings f77"
   bindings_dirs="$bindings_dirs src/binding/f77"
   AC_DEFINE(HAVE_FORTRAN_BINDING,1,[Define if Fortran is supported])
fi

if test "$enable_f90" = "yes" ; then
   if test "$enable_f77" != "yes" ; then
       AC_MSG_WARN([Fortran 90 requires Fortran 77])
       enable_f90=no
   else 
       bindingsubsystems="$bindingsubsystems src/binding/f90"
       bindings="$bindings f90"
       bindings_dirs="$bindings_dirs src/binding/f90"
   fi
fi

if test "$enable_cxx" = "yes" ; then
   bindingsubsystems="$bindingsubsystems src/binding/cxx"
   bindings="$bindings cxx"
   bindings_dirs="$bindings_dirs src/binding/cxx"
   AC_DEFINE(HAVE_CXX_BINDING,1,[Define if C++ is supported])
fi

AC_SUBST(bindings)
# Bindings dirs is used for the installation target
AC_SUBST(bindings_dirs)
#
# A few final exports
# Some users use FC, others F77 for the Fortran compiler.  The following
# tests makes us consistent
if test -z "$FC" -a -n "$F77" ; then FC="$F77" ; export FC ; fi
if test -z "$F77" -a -n "$FC" ; then F77="$FC" ; export F77 ; fi
#
# ----------------------------------------------------------------------------
# Done with the basic argument processing and decisions about which 
# subsystems to build
# ----------------------------------------------------------------------------
dnl
dnl The recommended order for items in a configure.in file is
dnl     check for programs
dnl     check for libraries
dnl     check for header files
dnl     check for typedefs
dnl     check for structures
dnl     check for compiler characteristics
dnl     check for library functions
dnl     check for system services
dnl Here are some sample tests
dnl
dnl Find a C compiler (choose gcc first).
dnl Autoconf 2.13 has the feature that you cannot override the test for
dnl cross-compilation made in [AC_PROG_CC].  
AC_PROG_CC
# Bug in autoconf.  Restore cross settings
if test "$pac_cross_compiling" = "yes" -a "$ac_cv_prog_cc_cross" = "no" ; then
    AC_MSG_RESULT([Resetting cross compilation to yes])
    cross_compiling=yes
    ac_cv_prog_cc_cross=yes
    ac_cv_prog_f77_cross=yes
    ac_cv_prog_f90_cross=yes
    ac_cv_prog_cxx_cross=yes
fi
AC_CHECK_PROGS(AR,ar)
# Note that we set RANLIB to true if we don't find it (some systems neither
# need it nor provide it)
AC_CHECK_PROGS(RANLIB,ranlib,true)

dnl Set CFLAGS for enable strict if necessary
PAC_CC_STRICT
# Check for broken handling of common symbols.  There are two fixes:
# Force ranlib to handle correctly (ranlib -c on some BSD and MAC OS platforms)
# or force gcc to not generate common symbols if using gcc (-fno-common).
# This autoconf macro checks for this.
PAC_PROG_C_BROKEN_COMMON
#
AC_PROG_INSTALL
#
# On Mac OS/X, install breaks libraries unless used with the -p switch
PAC_PROG_INSTALL_BREAKS_LIBS
# We also need mkdir -p.
PAC_PROG_MKDIR_P

# Don't setup the shared libraries until we know which compiler we will be
# using
dnl We do not support shared libraries.  
dnl PAC_ARG_SHAREDLIBS
AC_ARG_ENABLE(sharedlibs,
[--enable-sharedlibs - This switch is obsolete and is not supported],
AC_MSG_ERROR([--enable-sharedlibs is not available]),,)
dnl ENABLE_SHLIB=$enable_sharedlibs
if test -z "$ENABLE_SHLIB" -o "$ENABLE_SHLIB" = "no" ; then
    ENABLE_SHLIB=none
fi
AC_SUBST(ENABLE_SHLIB)
AC_SUBST(C_LINKPATH_SHL)

# 
# Add the steps for debugger support
BUILD_TVDLL=no
AC_SUBST(BUILD_TVDLL)
AC_SUBST(CC_SHL_DBG)
AC_SUBST(C_LINK_SHL_DBG)


# We need the full path to perl since we'll use it as the interpreter for
# a shell script.
AC_PATH_PROG(PERL5,perl)

nameserv_name=""
AC_SUBST(nameserv_name)
if test "$with_namepublisher" != no -a "$with_namepublisher" != "none" ; then
    case "$with_namepublisher" in 
    none|no) ;;
    ldap*)
        subsystems="$subsystems src/nameserv/ldap"
	# The configure in the nameserv/ldap directory will look for 
	# the ldap files.
	AC_DEFINE(USE_LDAP_FOR_NAMEPUB,1,[Define if ldap should be used for name publishing])
	nameserv_name="ldap"
    ;;

    pmiext)
    # This name publisher should simply use the PMI support as
    # part of the selected PMI interface implmentation.  If that
    # interface does not support pmiext, then the appropriate
    # configure should signal an error.
    AC_MSG_WARN([No pmiext name publisher supported])
dnl    AC_DEFINE(USE_PMIEXT_FOR_NAMEPUB,1,[Define if pmiext should be used for name publishing])
    #nameserv_name="pmiext"
    ;;

    file*)
    # Note that we always build the Makefile for the file version because
    # this name publisher is really too simple to require a 
    # separate configure, and we might as well include a basic
    # name publisher with any MPICH2 distribution
    # We DO need to extract the directory name that is used for writing 
    # the files, with the User's home directory as the default
    nameserv_name="file"
    basedir=`echo $with_namepublisher | sed -e 's/file://'`
    if test "$basedir" = "$with_namepublisher" ; then
        # Reset since no directory was set.
	basedir='"."';
    fi
    # We would like to use strerror in the file namepublisher
    AC_CHECK_FUNCS(strerror)
    AC_DEFINE_UNQUOTED(FILE_NAMEPUB_BASEDIR,$basedir,[Directory to use in namepub])
    AC_DEFINE(USE_FILE_FOR_NAMEPUB,1,[Define if file should be used for name publisher])
    ;;

    *)
    AC_MSG_WARN([Unknown name publisher $with_namepublisher])
    ;;
    esac    
fi
if test -n "$nameserv_name" ; then
   AC_DEFINE(HAVE_NAMEPUB_SERVICE,1,[Define if a name publishing service is available])
fi

dnl
dnl Now that CC is defined, get these values 
dnl eval C_LINK_SHL=$C_LINK_SHL
dnl eval CC_SHL=$CC_SHL
dnl Ensure that all subdir configures get this
export CC_SHL
export C_LINK_SHL
export ENABLE_SHLIB
export LIBTOOL
dnl
dnl Find SSH.  If SSH is defined, use that instead
dnl AC_PATH_PROG(SSH,ssh)
dnl
dnl AC_PROG_MAKE_SET
PAC_PROG_MAKE
dnl
dnl     check for compiler characteristics
dnl Check for support for weak symbols.  If not found, set NO_WEAK_SYM
dnl to the Make target name understood by simplemake.
# Set NEEDSPLIB to yes if link commands need both -l$MPILIBNAME
# and -lp$MPILIBNAME.
NO_WEAK_SYM_TARGET=build_proflib
if test $enable_weak_symbols = yes ; then
    # Turn off weak symbols if they aren't available
    PAC_PROG_C_WEAK_SYMBOLS(,enable_weak_symbols=no)
fi
if test $enable_weak_symbols = "yes" ; then
    AC_DEFINE(USE_WEAK_SYMBOLS,1,[Define if weak symbols should be used])
    NEEDSPLIB=no
else
    NO_WEAK_SYM=build_proflib
    PROFILE_DEF_MPI="-DMPICH_PROFILE_MPI -DMPICH_MPI_FROM_PMPI"
    NEEDSPLIB=yes
fi
export NEEDSPLIB
export NO_WEAK_SYM
export NO_WEAK_SYM_TARGET
export PROFILE_DEF_MPI
AC_SUBST(NEEDSPLIB)
AC_SUBST(NO_WEAK_SYM)
AC_SUBST(NO_WEAK_SYM_TARGET)
AC_SUBST(PROFILE_DEF_MPI)
AC_C_CONST
PAC_C_VOLATILE
PAC_C_RESTRICT
AC_C_INLINE
PAC_C_GNU_ATTRIBUTE

# Set a default for MAKE_DEPEND_C
MAKE_DEPEND_C=true
AC_SUBST(MAKE_DEPEND_C)
AC_ARG_ENABLE(dependencies,[
--enable-dependencies - Generate dependencies for sourcefiles.  This
            requires that the Makefile.in files are also created
            to support dependencies (see maint/updatefiles)],,
enable_dependencies=no)
if test "$enable_dependencies" != "no" ; then
    if test "$enable_dependencies" = "yes" -o -z "$enable_dependencies" ; then
        MAKE_DEPEND_C="gcc -MM"
    else
        AC_MSG_RESULT([Using $enable_dependencies for MAKE_DEPEND_C])
        MAKE_DEPEND_C="$enable_dependencies"
    fi
fi
export MAKE_DEPEND_C

# Check on support for long double and long long types.  Do this before the
# structure alignment test because it will test for including those
# types as well
AC_CACHE_CHECK([whether long double is supported],
pac_cv_have_long_double,[
AC_TRY_COMPILE(,[long double a;],
pac_cv_have_long_double=yes,pac_cv_have_long_double=no)])
if test "$pac_cv_have_long_double" = "yes" ; then
    AC_DEFINE(HAVE_LONG_DOUBLE,1,[Define if long double is supported])
fi
AC_CACHE_CHECK([whether long long is supported],
pac_cv_have_long_long,[
AC_TRY_COMPILE(,[long double a;],
pac_cv_have_long_long=yes,pac_cv_have_long_long=no)])
if test "$pac_cv_have_long_long" = "yes" ; then
    AC_DEFINE(HAVE_LONG_LONG_INT,1,[Define if long long is supported])
fi
# Get default structure alignment
dnl PAC_C_STRUCT_ALIGNMENT places the default alignment into
dnl pac_cv_c_struct_align, with possible values including
dnl packed (byte), largest, two, four, eight (or other failure message).
PAC_C_STRUCT_ALIGNMENT

if test "$pac_cv_c_struct_align" = "packed" ; then
    pac_cv_c_struct_align_nr=1
elif test "$pac_cv_c_struct_align" = "two" ; then
    pac_cv_c_struct_align_nr=2
elif test "$pac_cv_c_struct_align" = "four" ; then
    pac_cv_c_struct_align_nr=4
elif test "$pac_cv_c_struct_align" = "eight" ; then
    pac_cv_c_struct_align_nr=8
elif test "$pac_cv_c_struct_align" = "largest" ; then
    AC_DEFINE(HAVE_LARGEST_STRUCT_ALIGNMENT,1,[Define when alignment of structures is based on largest component])
fi

if test -n "$pac_cv_c_struct_align_nr" ; then
    AC_DEFINE_UNQUOTED(HAVE_MAX_STRUCT_ALIGNMENT,$pac_cv_c_struct_align_nr,[Controls byte alignment of structures])
fi

dnl Test whether pointers can be aligned on a int boundary or require
dnl a pointer boundary.
AC_MSG_CHECKING([for alignment restrictions on pointers])
AC_TRY_RUN(
changequote(<<,>>)
struct foo { int a; void *b; };
int main() {
    int buf[10];
    struct foo *p1;
    p1=(struct foo*)&buf[0];
    p1->b = (void *)0;
    p1=(struct foo*)&buf[1];
    p1->b = (void *)0;
    return 0;
changequote([,])
},pac_cv_pointers_have_int_alignment=yes,pac_cv_pointers_have_int_alignment=no,pac_cv_pointers_have_int_alignment=unknown)

if test "$pac_cv_pointers_have_int_alignment" != "yes" ; then
   AC_DEFINE(NEEDS_POINTER_ALIGNMENT_ADJUST,1,[define if pointers must be aligned on pointer boundaries])
   AC_MSG_RESULT([pointer])
else
   AC_MSG_RESULT([int or better])
fi

dnl
dnl Get the size of the C types for encoding in the basic datatypes and for
dnl the specific-sized integers
AC_CHECK_SIZEOF(char,$CROSS_SIZEOF_CHAR)
AC_CHECK_SIZEOF(short,$CROSS_SIZEOF_SHORT)
AC_CHECK_SIZEOF(int,$CROSS_SIZEOF_INT)
AC_CHECK_SIZEOF(long,$CROSS_SIZEOF_LONG)
AC_CHECK_SIZEOF(long long,$CROSS_SIZEOF_LONG_LONG)
AC_CHECK_SIZEOF(float,$CROSS_SIZEOF_FLOAT)
AC_CHECK_SIZEOF(double,$CROSS_SIZEOF_DOUBLE)
AC_CHECK_SIZEOF(long double,$CROSS_SIZEOF_LONG_DOUBLE)
AC_CHECK_SIZEOF(wchar_t,$CROSS_SIZEOF_WCHAR_T)
# wchar_t is sometimes defined in stddef.h.  If we got a zero for its
# size, and we have stddef.h, try again with an explicit test
if test "$ac_cv_sizeof_wchar_t" = 0 -a "$ac_cv_header_stddef_h" = yes ; then
    AC_CACHE_CHECK([for sizeof wchar_t],ac_cv_sizeof_wchar_t,[
    rm -f conftestval 
    AC_TRY_RUN([#include <stdio.h>
#include <stddef.h>
main()
{
  wchar_t a;
  FILE *f=fopen("conftestval", "w");
  if (!f) exit(1);
  fprintf(f, "%d\n", sizeof(a));
  exit(0);
}],ac_cv_sizeof_wchar_t=`cat conftestval`,ac_cv_sizeof_wchar_t=0,ac_cv_sizeof_wchar_t=$CROSS_SIZEOF_WCHAR_T)])
  rm -f conftestval
fi
AC_CHECK_SIZEOF(void *,$CROSS_SIZEOF_VOID_P)
PAC_CHECK_SIZEOF_DERIVED(float int,[struct { float a; int b; }],$CROSS_SIZEOF_FLOAT_INT)
PAC_CHECK_SIZEOF_DERIVED(double int,[struct { double a; int b; }],$CROSS_SIZEOF_DOUBLE_INT)
PAC_CHECK_SIZEOF_DERIVED(long int,[struct { long a; int b; }],$CROSS_SIZEOF_LONG_INT)
PAC_CHECK_SIZEOF_DERIVED(short int,[struct { short a; int b; }],$CROSS_SIZEOF_SHORT_INT)
PAC_CHECK_SIZEOF_DERIVED(2 int,[struct { int a; int b; }],$CROSS_SIZEOF_2_INT)
PAC_CHECK_SIZEOF_DERIVED(long double int,[struct { long double a; int b; }],$CROSS_SIZEOF_LONG_DOUBLE_INT)
dnl
# sys/bitypes.h defines the int16_t etc. on some systems (e.g., OSF1).
# Include it when testing for these types
AC_CHECK_HEADER(sys/bitypes.h,[use_bitypes="#include <sys/bitypes.h>"
AC_DEFINE(HAVE_SYS_BITYPES_H,1,[Define if sys/bitypes.h exists])])
AC_CACHE_CHECK([for int16_t],pac_cv_int16_t,[
AC_TRY_COMPILE([#include <sys/types.h>
$use_bitypes
],[int16_t a=0;],
pac_cv_int16_t=yes,pac_cv_int16_t=no)])
dnl
dnl If there is not int16_t, try to define one
if test "$pac_cv_int16_t" = "no" ; then
    if test -z "$CROSS_SIZEOF_SHORT" ; then CROSS_SIZEOF_SHORT=2 ; fi
    AC_CHECK_SIZEOF(short,$CROSS_SIZEOF_SHORT)
    if test "$ac_cv_sizeof_short" = 2 ; then 
        INT16_T=short
    else
        # No good option
        INT16_T=int
    fi
    AC_SUBST(INT16_T)
    AC_DEFINE_UNQUOTED(MPIU_INT16_T,$INT16_T,[Define for the 16 bit integer type])
else
    AC_DEFINE(HAVE_INT16_T,1,[Define if int16_t is supported by the C compiler])
fi
AC_CACHE_CHECK([for int32_t],pac_cv_int32_t,[
AC_TRY_COMPILE([#include <sys/types.h>
$use_bitypes
],[int32_t a=0;],
pac_cv_int32_t=yes,pac_cv_int32_t=no)])
dnl
dnl If there is not int32_t, try to define one
if test "$pac_cv_int32_t" = "no" ; then
    if test -z "$CROSS_SIZEOF_INT" ; then CROSS_SIZEOF_INT=4 ; fi
    AC_CHECK_SIZEOF(int,$CROSS_SIZEOF_INT)
    if test "$ac_cv_sizeof_int" = 4 ; then 
        INT32_T=int
    else
        # No good alternative
        INT32_T=int
    fi
    AC_SUBST(INT32_T)
    AC_DEFINE_UNQUOTED(MPIU_INT32_T,$INT32_T,[Define for the 32 bit integer type])
else
    AC_DEFINE(HAVE_INT32_T,1,[Define if int32_t is supported by the C compiler])
fi
AC_CACHE_CHECK([for int64_t],pac_cv_int64_t,[
AC_TRY_COMPILE([#include <sys/types.h>
$use_bitypes
],[int64_t a=0;],
pac_cv_int64_t=yes,pac_cv_int64_t=no)])
dnl
dnl If there is not int64_t, try to define one
if test "$pac_cv_int64_t" = "no" ; then
    if test -z "$CROSS_SIZEOF_LONG_LONG" ; then CROSS_SIZEOF_LONG_LONG=8 ; fi
    AC_CHECK_SIZEOF(long,$CROSS_SIZEOF_LONG)
    if test "$ac_cv_sizeof_long" = 8 ; then 
        INT64_T="long"
    else
        AC_CHECK_SIZEOF(long long,$CROSS_SIZEOF_LONG_LONG)
        if test "$ac_cv_sizeof_long_long" = 8 ; then 
            INT64_T="long long"
        else
            # No good alternative
            INT64_T="long long"
        fi
    fi
    AC_SUBST(INT64_T)
    AC_DEFINE_UNQUOTED(MPIU_INT64_T,$INT64_T,[Define for the 64 bit integer type])
else
    AC_DEFINE(HAVE_INT64_T,1,[Define if int64_t is supported by the C compiler])
fi
dnl
dnl Generate a hex version of the size of each type
for type in short int long long_long float double long_double wchar_t \
    float_int double_int long_int short_int 2_int long_double_int ; do
    eval len=\$ac_cv_sizeof_$type
    if test -z "$len" ; then 
       len=0
       # Check for sizes from the CHECK_SIZEOF_DERIVED macro
       eval pclen=\$pac_cv_sizeof_$type
       if test -n "$pclen" ; then
           len=$pclen
       else
           # check for a non-optional type
	   if test $type != long_long -a $type != long_double -a \
	           $type != long_double_int ; then 
               AC_MSG_ERROR([Configure was unable to determine the size of $type ; if cross compiling,
use the environment variables CROSS_SIZEOF_typename, e.g., CROSS_SIZEOF_SHORT,
or use the --with-cross=file configure option to specify a file containing
Bourne (sh) shell assignments to CROSS_SIZEOF_typename for all datatype 
types.  The program maint/getcross.c can be compiled and run on the target
system; this program outputs an appropriate file for the --with-cross option])
	   fi
       fi
    fi
    #
    # Take len and turn it into two hex digits (there are 8 bits available
    # in the built-in datatype handle for the length; see
    # src/mpid/common/datatype/mpid_datatype.h)
    if test "$len" -gt 255 ; then
         AC_MSG_ERROR([Type sizes greater than 255 bytes not supported (type $type is $len bytes)]) 
    fi
    tmplen=$len
    hexlen=""
    while test $tmplen -gt 0 ; do
        lowdigit=`expr $tmplen - 16 \* \( $tmplen / 16 \)`
	case $lowdigit in 
         10) char=a ;;
	 11) char=b ;;
	 12) char=c ;;
	 13) char=d ;;
	 14) char=e ;;
	 15) char=f ;;
	  *) char=$lowdigit ;;
	esac
	hexlen="$char$hexlen"
	tmplen=`expr $tmplen / 16`
    done
    if test $len -lt 16 ; then
        hexlen="0$hexlen"
    fi
    eval len_$type=$hexlen
done
# By definition, sizeof char is 1
MPI_CHAR="0x4c000101"
MPI_UNSIGNED_CHAR="0x4c000102"
MPI_SHORT="0x4c00${len_short}03"
MPI_UNSIGNED_SHORT="0x4c00${len_short}04"
MPI_INT="0x4c00${len_int}05"
MPI_UNSIGNED_INT="0x4c00${len_int}06"
MPI_LONG="0x4c00${len_long}07"
MPI_UNSIGNED_LONG="0x4c00${len_long}08"
MPI_LONG_LONG="0x4c00${len_long_long}09"
MPI_FLOAT="0x4c00${len_float}0a"
MPI_DOUBLE="0x4c00${len_double}0b"
MPI_LONG_DOUBLE="0x4c00${len_long_double}0c"
# If you change MPI_BYTE, you must change it in src/binding/f77/buildiface
MPI_BYTE="0x4c00010d"
MPI_WCHAR="0x4c00${len_wchar_t}0e"
MPI_PACKED="0x4c00010f"
MPI_LB="0x4c000010"
MPI_UB="0x4c000011"
#
# These should define the mixed types *only* for contiguous data.
# For example, MPI_SHORT_INT may have a gap; it will need to be defined
# as a derived type instead.  For IA32, this only affects short_int.
MPI_FLOAT_INT="0x4c00${len_float_int}12"
MPI_DOUBLE_INT="0x4c00${len_double_int}13"
MPI_LONG_INT="0x4c00${len_long_int}14"
MPI_SHORT_INT="0x4c00${len_short_int}15"
MPI_2INT="0x4c00${len_2_int}16"
MPI_LONG_DOUBLE_INT="0x4c00${len_long_double_int}17"

# 2 additional predefined types named in MPI-2
MPI_SIGNED_CHAR="0x4c000118"
MPI_UNSIGNED_LONG_LONG="0x4c00${len_long_long}19"

AC_SUBST(MPI_CHAR)
AC_SUBST(MPI_UNSIGNED_CHAR)
AC_SUBST(MPI_SHORT)
AC_SUBST(MPI_UNSIGNED_SHORT)
AC_SUBST(MPI_INT)
AC_SUBST(MPI_UNSIGNED_INT)
AC_SUBST(MPI_LONG)
AC_SUBST(MPI_UNSIGNED_LONG)
AC_SUBST(MPI_LONG_LONG)
AC_SUBST(MPI_FLOAT)
AC_SUBST(MPI_DOUBLE)
AC_SUBST(MPI_LONG_DOUBLE)
AC_SUBST(MPI_BYTE)
AC_SUBST(MPI_WCHAR)
AC_SUBST(MPI_PACKED)
AC_SUBST(MPI_LB)
AC_SUBST(MPI_UB)
AC_SUBST(MPI_FLOAT_INT)
AC_SUBST(MPI_DOUBLE_INT)
AC_SUBST(MPI_LONG_INT)
AC_SUBST(MPI_SHORT_INT)
AC_SUBST(MPI_2INT)
AC_SUBST(MPI_LONG_DOUBLE_INT)
AC_SUBST(MPI_SIGNED_CHAR)
AC_SUBST(MPI_UNSIGNED_LONG_LONG)
#
# Export the basic C types so that the Fortran system can use them
export MPI_CHAR
export MPI_SHORT
export MPI_INT
export MPI_LONG
export MPI_LONG_LONG
export MPI_FLOAT
export MPI_DOUBLE
export MPI_LONG_DOUBLE
dnl
#
# Size-specific types.  Initialize as NULL
MPI_REAL4=MPI_DATATYPE_NULL
MPI_REAL8=MPI_DATATYPE_NULL
MPI_REAL16=MPI_DATATYPE_NULL
MPI_COMPLEX8=MPI_DATATYPE_NULL
MPI_COMPLEX16=MPI_DATATYPE_NULL
MPI_COMPLEX32=MPI_DATATYPE_NULL
MPI_INTEGER1=MPI_DATATYPE_NULL
MPI_INTEGER2=MPI_DATATYPE_NULL
MPI_INTEGER4=MPI_DATATYPE_NULL
MPI_INTEGER8=MPI_DATATYPE_NULL
MPI_INTEGER16=MPI_DATATYPE_NULL
AC_SUBST(MPI_REAL4)
AC_SUBST(MPI_REAL8)
AC_SUBST(MPI_REAL16)
AC_SUBST(MPI_COMPLEX8)
AC_SUBST(MPI_COMPLEX16)
AC_SUBST(MPI_COMPLEX32)
AC_SUBST(MPI_INTEGER1)
AC_SUBST(MPI_INTEGER2)
AC_SUBST(MPI_INTEGER4)
AC_SUBST(MPI_INTEGER8)
AC_SUBST(MPI_INTEGER16)
export MPI_REAL4
export MPI_REAL8
export MPI_REAL16
export MPI_COMPLEX8
export MPI_COMPLEX16
export MPI_COMPLEX32
export MPI_INTEGER1
export MPI_INTEGER2
export MPI_INTEGER4
export MPI_INTEGER8
export MPI_INTEGER16
#
# Try to find corresponding types for the size-specific types.
#
# Assume that the float/double/long double are simply spaced
# Datatypes used up through 26 in Fortran
# 27,28,29,2a,2b,2c
if test "$ac_cv_sizeof_float" = "4" ; then
    MPI_REAL4="0x4c000427"
    MPI_COMPLEX8="0x4c000828"
    MPIR_REAL4_CTYPE=float
fi
if test "$ac_cv_sizeof_double" = "8" ; then
    MPI_REAL8="0x4c000829"
    MPI_COMPLEX16="0x4c00102a"
    MPIR_REAL8_CTYPE=double
fi
if test "$ac_cv_sizeof_long_double" = "16" ; then
    MPI_REAL16="0x4c00102b"
    MPI_COMPLEX32="0x4c00202c"
    MPIR_REAL16_TYPE="long double"
fi
if test -n "$MPIR_REAL4_CTYPE" ; then
    AC_DEFINE_UNQUOTED(MPIR_REAL4_CTYPE,$MPIR_REAL4_CTYPE,[C type to use for MPI_REAL4])
fi
if test -n "$MPIR_REAL8_CTYPE" ; then
    AC_DEFINE_UNQUOTED(MPIR_REAL8_CTYPE,$MPIR_REAL8_CTYPE,[C type to use for MPI_REAL8])
fi
if test -n "$MPIR_REAL16_CTYPE" ; then
    AC_DEFINE_UNQUOTED(MPIR_REAL16_CTYPE,$MPIR_REAL16_CTYPE,[C type to use for MPI_REAL16])
fi
# For complex 8/16/32, we assume that these are 2 consequetive real4/8/16
#
# Search for the integer types
for type in char short int long long_long ; do
    # ctype is a valid C type which we can use to declare a C version of 
    # this item
    ctype=`echo $type | sed 's/_/ /'`
    eval len=\$ac_cv_sizeof_$type
    if test -n "$len" ; then 
    case $len in 
    1) if test "$MPI_INTEGER1" = "MPI_DATATYPE_NULL" ; then
           MPI_INTEGER1="0x4c00012d"
	   MPIR_INTEGER1_CTYPE="$ctype"
       fi
       ;;
    2) if test "$MPI_INTEGER2" = "MPI_DATATYPE_NULL" ; then
           MPI_INTEGER2="0x4c00022f"
	   MPIR_INTEGER2_CTYPE="$ctype"
       fi
       ;;
    4) if test "$MPI_INTEGER4" = "MPI_DATATYPE_NULL" ; then
           MPI_INTEGER4="0x4c000430"
	   MPIR_INTEGER4_CTYPE="$ctype"
       fi
       ;;
    8) if test "$MPI_INTEGER8" = "MPI_DATATYPE_NULL" ; then
           MPI_INTEGER8="0x4c000831"
	   MPIR_INTEGER8_CTYPE="$ctype"
       fi
       ;;
    16) if test "$MPI_INTEGER16" = "MPI_DATATYPE_NULL" ; then
           MPI_INTEGER16="0x4c001032"
	   MPIR_INTEGER16_CTYPE="$ctype"
       fi
       ;;
    *)
    ;;
    esac
    fi
done
#
# Add the definitions of these types
if test -n "$MPIR_INTEGER1_CTYPE" ; then
    AC_DEFINE_UNQUOTED(MPIR_INTEGER1_CTYPE,$MPIR_INTEGER1_CTYPE,[C type to use for MPI_INTEGER1])
fi
if test -n "$MPIR_INTEGER2_CTYPE" ; then
   AC_DEFINE_UNQUOTED(MPIR_INTEGER2_CTYPE,$MPIR_INTEGER2_CTYPE,[C type to use for MPI_INTEGER2])
fi
if test -n "$MPIR_INTEGER4_CTYPE" ; then
   AC_DEFINE_UNQUOTED(MPIR_INTEGER4_CTYPE,$MPIR_INTEGER4_CTYPE,[C type to use for MPI_INTEGER4])
fi
if test -n "$MPIR_INTEGER8_CTYPE" ; then
   AC_DEFINE_UNQUOTED(MPIR_INTEGER8_CTYPE,$MPIR_INTEGER8_CTYPE,[C type to use for MPI_INTEGER8])
fi
if test -n "$MPIR_INTEGER16_CTYPE" ; then
   AC_DEFINE_UNQUOTED(MPIR_INTEGER16_CTYPE,$MPIR_INTEGER16_CTYPE,[C type to use for MPI_INTEGER16])
fi

dnl
dnl Is char * the byte address?
AC_CACHE_CHECK([if char * pointers use give byte addresses],
pac_cv_c_char_p_is_byte,[
AC_TRY_RUN([
int main(int argc, char **argv ){
char *a, buf;
a = &buf;
if ((long)(a-(char*)0) == (long)(a)) return 0; return 1;
}],pac_cv_c_char_p_is_byte=yes,pac_cv_char_p_is_byte=no,
pac_cv_char_p_is_byte=unknown)])
if test "$pac_cv_char_p_is_byte" = "yes" ; then
    AC_DEFINE(CHAR_PTR_IS_BYTE,1,[define if char * is byte pointer])
fi
dnl
dnl Get the size for the bsendoverhead
rm -f conftestval
dnl FIXME This should really use code from bsendutil.c.  Types
dnl defined in the mpiimpl.h file or in mpi.h have been replaced here. 
dnl The sizeof(void*)-1 allows us to force the first byte of the 
dnl buffer to be aligned.
AC_CACHE_CHECK([for size of MPI_BSEND_OVERHEAD],pac_cv_mpi_bsend_overhead,[
AC_TRY_RUN([
#include <stdio.h>
/* BsendData describes a bsend request */
typedef struct BsendData {
    int              size;             /* size that is available for data */
    int              total_size;       /* total size of this segment */
    struct BsendData *next, *prev;
    int          kind;
    void         *request;
    struct {
    void         *msgbuf;
    int          count;
    int          dtype;
    int          tag;
    void         *comm_ptr;
    int          dest;
    double       alignpad;
    } msg;
} BsendData_t;
int main( int argc, char *argv[] ){
  FILE *f=fopen("conftestval", "w");
  if (!f) exit(1);
  fprintf(f, "%d\n", sizeof(BsendData_t)+sizeof(void*)-1);
  exit(0);
}
],pac_cv_mpi_bsend_overhead=`cat conftestval`,pac_cv_mpi_bsend_overhead=256,pac_cv_mpi_bsend_overhead=256)
])
BSEND_OVERHEAD=$pac_cv_mpi_bsend_overhead
AC_SUBST(BSEND_OVERHEAD)
#
# The size of MPI_Status is needed for the Fortran interface. 
# This is not quite right unless the device setup script, executed above,
# sets the EXTRA_STATUS_DECL that will be used in defining a status.
# The default size assumes that there are 5 ints
default_status_size=`expr 5 \* $ac_cv_sizeof_int`
AC_CACHE_CHECK([for size of MPI_Status],pac_cv_sizeof_mpi_status,[
AC_TRY_RUN([
#include <stdio.h>
typedef struct { 
    int count;
    int cancelled;
    int MPI_SOURCE;
    int MPI_TAG;
    int MPI_ERROR;
    $EXTRA_STATUS_DECL
} MPI_Status;
int main( int argc, char *argv[] ){
  FILE *f=fopen("conftestval", "w");
  if (!f) exit(1);
  fprintf(f, "%d\n", sizeof(MPI_Status));
  exit(0);
}
],pac_cv_sizeof_mpi_status=`cat conftestval`,pac_cv_sizeof_mpi_status=$default_status_size,pac_cv_sizeof_mpi_status=$default_status_size)
])
SIZEOF_MPI_STATUS=$pac_cv_sizeof_mpi_status
export SIZEOF_MPI_STATUS
AC_SUBST(SIZEOF_MPI_STATUS)

dnl
dnl check for library functions
if test "$thread_pkg_required" = "yes" ; then
    case $with_thread_package in 
        posix|pthreads)
	with_thread_package=posix
	AC_CHECK_HEADERS(pthread.h)
	# OSF1 has __pthread_create but not pthread_create (because of 
	# inconsistencies in the pthread spec).  Thus, we look for pthread_key_create
	AC_SEARCH_LIBS(pthread_key_create,pthread,found=yes,found=no)
	if test "$found" != "yes" ; then
	   AC_MSG_ERROR([unable to find pthreads library])
	fi
	;;
	solaris)
	AC_CHECK_HEADERS(thread.h)
	AC_SEARCH_LIBS(thr_create,thread,found=yes,found=no)
	if test "$found" != "yes" ; then
	   AC_MSG_ERROR([unable to find Solaris threads library])
	fi
	# FIXME: need to add -mt if using solaris compilers
	;;
	*)
	AC_MSG_ERROR([The specified thread package, $with_thread_package, is not supported.]) 
	;;
    esac

    AC_CHECK_FUNCS(thr_yield sched_yield yield)

    AC_DEFINE(_REENTRANT,,[Must be defined for thread support on Linux systems])
    AC_DEFINE(_THREAD_SAFE,,[Must be defined for thread OS support on some systems])

    use_thread_pkg="MPICH_THREAD_PKG_`echo $with_thread_package | \
      tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`"
else
    use_thread_pkg="MPICH_THREAD_PKG_NONE"
fi
AC_DEFINE_UNQUOTED(USE_THREAD_PKG,$use_thread_pkg,[Thread package selected at configure time])
dnl
dnl Check for special compile characteristics
# If we are either gcc or icc, see if we can use __asm__
# We test on prog_gcc to allow gcc by any name; if we are using
# icc, the value of CC must be icc for this test to pass
if test "$ac_cv_prog_gcc" = "yes" -o "$ac_cv_prog_CC" = "icc" ; then
AC_MSG_CHECKING([for gcc __asm__ and pentium cmpxchgl instruction])
AC_TRY_RUN([
int main(int argc, char *argv[])
{
long int compval = 10;
volatile long int *p = &compval;
long int oldval = 10;
long int newval = 20;
char ret;
long int readval;
__asm__ __volatile__ ("lock; cmpxchgl %3, %1; sete %0"
	: "=q" (ret), "=m" (*p), "=a" (readval)
	: "r" (newval), "m" (*p), "a" (oldval) : "memory");
return (compval == 20) ? 0 : -1;
}
], AC_MSG_RESULT(yes)
   AC_DEFINE(HAVE_GCC_AND_PENTIUM_ASM, 1,[Define if using gcc on a system with an Intel Pentium class chip])
   lac_cv_use_atomic_updates="yes", 
AC_MSG_RESULT(no), AC_MSG_RESULT(not checking when cross compiling))
fi
if test "$lac_cv_use_atomic_updates" = "yes" ; then
    AC_DEFINE(USE_ATOMIC_UPDATES,, [Define if assembly language atomic update macros should be used (if available)])
fi
dnl
dnl check for x86_64
dnl 
if test "$ac_cv_prog_gcc" = "yes" ; then
AC_MSG_CHECKING([for gcc __asm__ and AMD x86_64 cmpxchgq instruction])
AC_TRY_RUN([
int main(int argc, char *argv[])
{
long int compval = 10;
volatile long int *p = &compval;
long int oldval = 10;
long int newval = 20;
char ret;
long int readval;
__asm__ __volatile__ ("lock; cmpxchgq %3, %1; sete %0"
	: "=q" (ret), "=m" (*p), "=a" (readval)
	: "r" (newval), "m" (*p), "a" (oldval) : "memory");
return (compval == 20) ? 0 : -1;
}
], AC_MSG_RESULT(yes)
   AC_DEFINE(HAVE_GCC_AND_X86_64_ASM, 1,[Define if using gcc on a system with an AMD x86_64 class chip]), 
AC_MSG_RESULT(no), AC_MSG_RESULT(not checking when cross compiling))
fi
dnl
dnl check for asm() format
dnl 
dnl AC_MSG_CHECKING([for asm() and pentium cmpxchgl instruction])
dnl AC_TRY_RUN([
dnl int main(int argc, char *argv[])
dnl {
dnl long int compval = 10;
dnl volatile long int *p = &compval;
dnl long int oldval = 10;
dnl long int newval = 20;
dnl char ret;
dnl long int readval;
dnl asm("lock; cmpxchgl %3, %1; sete %0"
dnl 	: "=q" (ret), "=m" (*p), "=a" (readval)
dnl 	: "r" (newval), "m" (*p), "a" (oldval) : "memory");
dnl return (compval == 20) ? 0 : -1;
dnl }
dnl ], AC_MSG_RESULT(yes)
dnl    AC_DEFINE(HAVE_PENTIUM_ASM, 1,[Define if using asm() on a system with an Intel Pentium class chip]),
dnl AC_MSG_RESULT(no), AC_MSG_RESULT(not checking when cross compiling))
dnl
dnl
dnl check for IA64
dnl 
if test "$ac_cv_prog_gcc" = "yes" ; then
AC_MSG_CHECKING([for gcc __asm__ and IA64 xchg4 instruction])
AC_TRY_RUN([
unsigned long _InterlockedExchange(volatile void *ptr, unsigned long x)
{
   unsigned long result;
   __asm__ __volatile ("xchg4 %0=[%1],%2" : "=r" (result)
       : "r" (ptr), "r" (x) : "memory");
   return result;
}
int main(int argc, char *argv[])
{
long val = 1;
volatile long *p = &val;
long oldval = _InterlockedExchange(p, (unsigned long)2);
return (oldval == 1 && val == 2) ? 0 : -1;
}
], AC_MSG_RESULT(yes)
   AC_DEFINE(HAVE_GCC_AND_IA64_ASM, 1,[Define if using gcc on a system with an IA64 class chip]), 
AC_MSG_RESULT(no), AC_MSG_RESULT(not checking when cross compiling))
fi
dnl
dnl Check for support of enable-coverage.  Put this near the end of the tests
dnl because the coverage options may affect the other tests.
if test "$enable_coverage" = "yes" ; then
    if test "$ac_cv_prog_gcc" = "yes" ; then
        CFLAGS="$CFLAGS -fprofile-arcs -ftest-coverage"
    else
        AC_MSG_WARN([--enable-coverage only supported for GCC])
    fi
    # Test for the routines that we need to use to ensure that the
    # data files are (usually) written out
    AC_CHECK_FUNCS(usleep)
    AC_DEFINE(USE_COVERAGE,1,[Define if performing coverage tests])
fi
dnl Is there libnsl needed for gethostbyname?
dnl AC_SEARCH_LIBS(gethostbyname,nsl)
dnl
dnl Look for Standard headers
AC_HEADER_STDC
# Check for a specific header
# Grrr.  OS/X fails the test for sys/uio.h because uio *requires* sys/types.h
# to compile.  Thus, we'll make that a separate test
# stddef.h is sometimes needed for types like wchar_t
AC_CHECK_HEADERS(stdarg.h sys/types.h inttypes.h limits.h stddef.h)
AC_CACHE_CHECK([for sys/uio.h],ac_cv_header_sys_uio_h,[
AC_TRY_COMPILE([
#include <sys/types.h>
#include <sys/uio.h>
],[int a;],ac_cv_header_sys_uio_h=yes,ac_cv_header_sys_uio_h=no)])
if test "$ac_cv_header_sys_uio_h" = yes ; then
    AC_DEFINE(HAVE_SYS_UIO_H,1,[Define if you have the <sys/uio.h> header file.])
fi
dnl
dnl Check for functions.  This invokes another test if the function is 
dnl found.  The braces around the second test are essential. 
dnl AC_CHECK_FUNC(setpgrp,[AC_FUNC_SETPGRP])
dnl
dnl These are used to support timeouts
AC_CHECK_FUNCS(setitimer alarm)
dnl
dnl These are used for error reporting
AC_CHECK_FUNCS(vsnprintf vsprintf)
dnl Use snprintf if possible when creating messages
AC_CHECK_FUNCS(snprintf)
if test "$ac_cv_func_snprintf" = "yes" ; then
    PAC_FUNC_NEEDS_DECL([#include <stdio.h>],snprintf)
fi
dnl
# if we are using stdarg, we may need va_copy .  Test to see if we have it
# Since it may be a built-in instead of a function, we must try to 
# compile and link a program that uses it.
AC_CACHE_CHECK([for va_copy],pac_cv_func_va_copy,[
AC_TRY_LINK([
#include <stdarg.h>
void foo1( char *fmt, ... ) {
    va_list ap, list;
    va_start(ap,fmt);
    va_copy(list,ap);
    va_end(list);
    va_end(ap);
}
],[foo1("a test %d", 3);],pac_cv_func_va_copy=yes,pac_cv_func_va_copy=no)])
if test "$pac_cv_func_va_copy" = "yes" ; then
    AC_DEFINE(HAVE_VA_COPY,1,[Define if we have va_copy])
fi
# We might have __va_copy...
if test "$pac_cv_func_va_copy" != "yes" ; then 
    AC_CACHE_CHECK([for __va_copy],pac_cv_func___va_copy,[
    AC_TRY_LINK([
#include <stdarg.h>
void foo1( char *fmt, ... ) {
    va_list ap, list;
    va_start(ap,fmt);
    __va_copy(list,ap);
    va_end(list);
    va_end(ap);
}
],[foo1("a test %d", 3);],pac_cv_func___va_copy=yes,pac_cv_func___va_copy=no)])
    if test "$pac_cv_func___va_copy" = "yes" ; then
    AC_DEFINE(HAVE___VA_COPY,1,[Define if we have __va_copy])
    fi
fi
dnl
AC_CHECK_FUNCS(strdup)
if test "$ac_cv_func_strdup" = "yes" ; then
    # Do we need to declare strdup?
    PAC_FUNC_NEEDS_DECL([#include <string.h>],strdup)
fi
dnl
dnl Specific checks that a function works correctly
dnl AC_FUNC_VFORK
dnl
dnl Check for support for long file names
dnl AC_SYS_LONG_FILE_NAMES
dnl
dnl
dnl Setup other replaceable values
AC_SUBST(MPILIBNAME)
MPI_AINT=int
for type in int long long_long short ; do
    eval len=\$ac_cv_sizeof_$type
    if test "$len" = "$ac_cv_sizeof_void_p" ; then
        MPI_AINT=`echo $type | sed -e 's/_/ /'`
        break
    fi
done
AC_SUBST(MPI_AINT)
dnl
dnl If sizeof(mpi_aint) = sizeof(int), set this value
if test "$ac_cv_sizeof_int" = "$ac_cv_sizeof_void_p" ; then
    AC_DEFINE(SIZEOF_INT_IS_AINT,1,[define if sizeof(int) = sizeof(void*)])
fi
dnl
dnl define MPIU_Size_t - used to express the size of objects
dnl
dnl FIXME: this should really be in a util configure file, but we don't
dnl have one at the moment
dnl
MPIU_SIZE_T="unsigned $MPI_AINT"
AC_DEFINE_UNQUOTED(MPIU_SIZE_T,$MPIU_SIZE_T,[Set to a type that can express the size of the entire address space]) 
dnl
#
# If it is necessary for the device to update some of the variables,
# this step allows that to happen.  Possible variables to update are
#   LIBS - Add libraries needed for linking
#   LDFLAGS - Add other LD flags (e.g., search paths for libraries)
#   CPPFLAGS - Add C preprocessor flags, including -Idir
#   DEFS  - Add C preprocessor definitions, e.g., -Dfoo
# These must be updated, not replaced, so the setup_device script should
# do, e.g., 
#   LIBS="$LIBS -lmywierdlib",
# not
#   LIBS="-lmywierdlib"
# In some cases (particularly for LIBS), we want to perform this update
# *after* the configure step.  This is done by including the file
# localdefs if it exists.  Note that the use of a file *after* the configure
# of subdirectories means that the subdir configures will not get the 
# value.  This is normally ok for libraries but not for include paths,
# which is why there is a pre and post step
if test -f $use_top_srcdir/src/mpid/$device_name/setup_device ; then
    echo sourcing $use_top_srcdir/src/mpid/$device_name/setup_device
    . $use_top_srcdir/src/mpid/$device_name/setup_device
fi
dnl Configure any subdirectories.  Note that config.status will *not* 
dnl reexecute these!
dnl Export any important variables first:
dnl 
dnl Gastly problem.  CONFIG_SUBDIRS only adds the directories to the
dnl list of directories to be configured.  It does NOT control the
dnl timing of the configuration.  For that, we must do something different.
dnl Our solution is to use a separate macro that does cause 
dnl immediate configure
export AR
export RANLIB
export MPILIBNAME
export CC
PAC_SUBDIR_CACHE
# Build the device first.  This way, any libraries or variables that it needs
# can be extracted before building the other subsystems (this is particularly
# important for the bindings, which may need to know the libraries in order
# to create the compilation scripts)
PAC_CONFIG_SUBDIRS_IMMEDIATE(src/mpi/timer $devsubsystems)
# Check for any localdefs files.  These may be created, so we look in
# the local directory first.
if test -f src/mpid/$device_name/localdefs ; then
    . src/mpid/$device_name/localdefs
elif test -f $use_top_srcdir/src/mpid/$device_name/localdefs ; then
    . $use_top_srcdir/src/mpid/$device_name/localdefs
fi

## The MPE configure requires MPI_LIBS, and that requires all of the LIBS
#MPI_LIBS="$MPI_LIBS $LIBS"
PAC_CONFIG_SUBDIRS_IMMEDIATE($subsystems)
#
# Get any localdefs that the subsystems created. Use a guard in case
# the list is empty
for dir in $subsystems /dev/null ; do 
    if test -f $dir/localdefs ; then
        . $dir/localdefs
    fi
done
#
# The language bindings must be done *last* because they may need to 
# know values from the localdefs of the previous configures
PAC_CONFIG_SUBDIRS_IMMEDIATE($bindingsubsystems)
#
# Get any localdefs that the subsystems created. Use a guard in case
# the list is empty
for dir in $bindingsubsystems /dev/null ; do 
    if test -f $dir/localdefs ; then
        . $dir/localdefs
    fi
done
# Make subsystems available to makefiles.
subsystems="$devsubsystems $subsystems $bindingsubsystems"
AC_SUBST(subsystems)
#
dnl
dnl Once the subsystems are configured, we can inquire about what
dnl they have been found.  For example, we need the values for the
dnl Fortran datatypes from the Fortran system, if they are defined.
if test "$enable_f77" = "yes" -a -s src/binding/f77/mpif77.conf ; then
    # Load the values from the generated configuration file
    # These set the datatypes and the other Fortran types
    . ./src/binding/f77/mpif77.conf
    case "$F77_NAME_MANGLE"X in
    F77_NAME_LOWERX|F77_NAME_MIXEDX) 
    AC_DEFINE(F77_NAME_LOWER,1,[Define if Fortran names are lowercase]) 
	;;
    F77_NAME_LOWER_USCOREX|F77_NAME_MIXED_USCOREX)
    AC_DEFINE(F77_NAME_LOWER_USCORE,1,[Define if Fortran names are lowercase with a trailing underscore])
	 ;;
    F77_NAME_LOWER_2USCOREX)
    AC_DEFINE(F77_NAME_LOWER_2USCORE,1,[Define if Fortran names containing an underscore have two trailing underscores])
	 ;;
    F77_NAME_UPPERX)
    AC_DEFINE(F77_NAME_UPPER,1,[Define if Fortran names are uppercase]) 
	;;
    esac
else
    # These are Fortran datatypes ONLY.  Set to null if no Fortran compiler.
    for name in CHARACTER INTEGER REAL LOGICAL COMPLEX DOUBLE_PRECISION \
	2INTEGER 2REAL DOUBLE_COMPLEX 2COMPLEX 2DOUBLE_PRECISION \
	2DOUBLE_COMPLEX ; do
	fullname="MPI_$name"
	eval $fullname=MPI_DATATYPE_NULL
    done
    AC_MSG_WARN([Could not define Fortran MPI datatypes for C])
    AC_DEFINE(HAVE_NO_FORTRAN_MPI_TYPES_IN_C,1,[Define if the Fortran types are not available in C])
    # Temporary values for MPI_Fint (need help from the Fortran subsystem)
    MPI_FINT=int
fi
AC_SUBST(MPI_CHARACTER)
AC_SUBST(MPI_INTEGER)
AC_SUBST(MPI_REAL)
AC_SUBST(MPI_LOGICAL)
AC_SUBST(MPI_COMPLEX)
AC_SUBST(MPI_DOUBLE_PRECISION)
AC_SUBST(MPI_2INTEGER)
AC_SUBST(MPI_2REAL)
AC_SUBST(MPI_DOUBLE_COMPLEX)
AC_SUBST(MPI_2DOUBLE_PRECISION)
AC_SUBST(MPI_2COMPLEX)
AC_SUBST(MPI_2DOUBLE_COMPLEX)
AC_SUBST(MPI_FINT)

# Temporary values for MPI_Offset (need help from IO subsystem)
if test -n "$MPI_OFFSET_TYPE" ; then
   # We got the value from the ROMIO configure
   MPI_OFFSET="$MPI_OFFSET_TYPE"
else
    # Make a guess at the appropriate definition for offset.  Try to 
    # find a 64bit type.
    if test "$ac_cv_sizeof_long_long" = 8 ; then
        MPI_OFFSET="long long"
    else
        MPI_OFFSET=long
    fi
fi
MPI_OFFSET_TYPEDEF="typedef $MPI_OFFSET MPI_Offset;"
AC_SUBST(MPI_OFFSET)
AC_SUBST(MPI_OFFSET_TYPEDEF)
dnl
dnl Temporary value for extra status information, from device subsystem
AC_SUBST(EXTRA_STATUS_DECL)
dnl
dnl Get the value of MPI_MAX_PROCESSOR_NAME
if test -s src/mpid/$device_name/Makefile ; then
    #
    # The dependency handling will look for a file in a .deps directory.
    # Make sure that the directory and file exists before running Make.
    if test ! -d src/mpid/$device_name/.deps ; then 
        mkdir src/mpid/$device_name/.deps
    fi
    if  test ! -f src/mpid/$device_name/.deps/alldeps ; then
        touch src/mpid/$device_name/.deps/alldeps
    fi
    maxproc="`(cd src/mpid/$device_name ; ${MAKE} echomaxprocname) | tail -1`"
    # Note: if this is more than one line, there will be problems with
    # the final step.  That may happen if MAKE is acting in some wierd
    # way, such as echoing all directory changes (even if the only
    # directory change is a result of the -f command !).  To avoid that,
    # we just run make in the device directory
    #
    # Check that this is a number
    # expr is supposed to set the return code to 1 if the result is 0
    val=`expr $maxproc - $maxproc 2>/dev/null`
    if test $? != 1 -o "$val" != "0" ; then
        AC_MSG_WARN([Could not determine size of MPI_MAX_PROCESSOR_NAME, using 128])
        maxproc=128
    fi
fi
if test -z "$maxproc" ; then
    maxproc=128
fi
# We should check that the maxproc value is a valid integer
MPI_MAX_PROCESSOR_NAME="$maxproc"
AC_SUBST(MPI_MAX_PROCESSOR_NAME)
dnl
dnl
dnl Set the libraries to use in building programs
if test "$NEEDSPLIB" = "yes" ; then
   # Ugh.  We don't have the dependencies between the libraries right 
    # yet.  We *should* only need -lmpich -lpmpich .  
    EXAMPLE_LIBS="-l$MPILIBNAME -lp$MPILIBNAME -l$MPILIBNAME -lp$MPILIBNAME $LIBS"
else
    EXAMPLE_LIBS="-l$MPILIBNAME $LIBS"
fi
AC_SUBST(EXAMPLE_LIBS)
dnl default settings for compiler and linker flags 
MPI_CFLAGS="$MPI_CFLAGS $CFLAGS"
MPI_LDFLAGS="$MPI_LDFLAGS $LDFLAGS"
AC_SUBST(MPI_CFLAGS)
AC_SUBST(MPI_LDFLAGS)

# Get and save the MPIVERSION 
AC_SUBST(MPIVERSION)
# Get the locatin of the CVS repository, if present
    # We can use this test (for CVS/Root) for creating maintainer targets
    # as well, and tests for maintainer-required software, such as 
    # doctext
if test -s CVS/Root ; then
    MPICVSHOME=`cat CVS/Root`
elif test -s "$srcdir/CVS/Root" ; then
    MPICVSHOME=`cat $srcdir/CVS/Root`
fi
AC_SUBST(MPICVSHOME)
# In case the documentation targets are used, find doctext and attempt to 
# find the source for the doctext LaTeX style files
AC_PATH_PROG(DOCTEXT,doctext)
if test -n "$DOCTEXT" ; then
    if test -z "$DOCTEXTSYTLE" ; then
        AC_MSG_CHECKING([for location of doctext style files])
        dpath=`doctext -debug_paths 2>&1 | grep 'default path' | \
	      sed -e 's%.*default path\(.*\),%\1:%g'`
        saveIFS="$IFS"
        IFS=": "
	for dir in $dpath ; do
	    if test -s $dir/refman.sty ; then
	       DOCTEXTSTYLE=$dir
	       break
	    fi
	done
        IFS="$saveIFS"
	if test -n "$DOCTEXTSTYLE" ; then
	    AC_MSG_RESULT($DOCTEXTSTYLE)
        else
	    AC_MSG_RESULT([unavailable])
        fi
    fi
fi
AC_SUBST(DOCTEXT)
AC_SUBST(DOCTEXTSTYLE)

dnl We can configure the test directory after the rest of the configure 
dnl steps because it does not depend on them.
AC_CONFIG_SUBDIRS(test/mpi)
dnl
dnl Generate the Makefiles from Makefile.in
dnl Also generate mpi.h from mpi.h.in so that we can eliminate all ifdefs
dnl from the file.

AC_OUTPUT_COMMANDS([chmod a+x test/runtests])
if test -z "$includebuild_dir" ; then
    includebuild_dir=`pwd`/src/include
fi
if test -z "$libbuild_dir" ; then
    libbuild_dir=`pwd`/lib
fi
#export includebuild_dir
#export libbuild_dir
AC_OUTPUT_COMMANDS([chmod a+x src/env/mpicc ;
   if test ! -d bin  ; then mkdir bin ; fi 
   sed -e 's%includedir=.*%includedir='$includebuild_dir% \
       -e 's%libdir=.*%libdir='$libbuild_dir% src/env/mpicc > bin/mpicc ;
   chmod a+x bin/mpicc ],includebuild_dir=$includebuild_dir
libbuild_dir=$libbuild_dir)

# Move the mpio.h file into the build directories for testing
#export top_srcdir
#export enable_romio
AC_OUTPUT_COMMANDS([if test "$enable_romio" = "yes" ; then
  /bin/rm -f src/include/mpio.h "${top_srcdir}/include/mpio.h"
  cp src/mpi/romio/include/mpio.h src/include ; fi],enable_romio=$enable_romio
top_srcdir=$top_srcdir)

#
# If dependencies are enabled in the updatefiles/simplemake step, then
# we must generate the dependency directories.  We do this by detecting 
# the dependencies target.  Note that this refers to the Makefile,
# in case we are building with VPATH
# Grr. Finds differ on how they handle {} in a string.  We could use
# xargs, but that may not be standard enough.  Instead we fall back on 
# the old standby of using find with -print, then sed to
# construct the line, which is fed to sh
#    find . -type d -exec sh -c '(cd {} && grep MAKE_DEPEND_C Makefile >/dev/null 2>&1 && ( test -d .deps || mkdir .deps ) && touch .deps/alldeps )' \;
AC_OUTPUT_COMMANDS([if grep 'dependencies:' Makefile >/dev/null 2>&1 ; then
    find . -type d -print | sed -e 's%\(.*\)%(cd \1 \&\& grep MAKE_DEPEND_C Makefile >/dev/null 2>\&1 \&\& ( test -d .deps || mkdir .deps) \&\& touch .deps/alldeps)%g' | sh
fi],enable_dependencies=$enable_dependencies)

AC_OUTPUT_COMMANDS([chmod +x doc/mansrc/createhtmlindex])

AC_OUTPUT(Makefile src/Makefile \
          src/binding/Makefile \
          src/env/mpicc \
	  src/env/mpicc.conf \
	  src/env/Makefile\
          src/mpi/Makefile \
          src/mpi/attr/Makefile \
	  src/mpi/coll/Makefile \
          src/mpi/comm/Makefile \
	  src/mpi/datatype/Makefile \
	  src/mpi/debugger/Makefile \
          src/mpi/errhan/Makefile \
          src/mpi/group/Makefile \
          src/mpi/init/Makefile \
          src/mpi/io/Makefile \
          src/mpi/misc/Makefile \
          src/mpi/pt2pt/Makefile \
          src/mpi/rma/Makefile \
          src/mpi/spawn/Makefile \
          src/mpi/topo/Makefile \
          src/mpid/Makefile \
          src/mpid/common/Makefile \
          $TOPLEVEL_OUTPUT_FILES \
          src/mpid/common/datatype/Makefile \
          src/mpid/common/locks/Makefile \
          src/pm/Makefile \
          src/pmi/Makefile \
	  src/nameserv/Makefile \
	  src/nameserv/file/Makefile \
	  src/util/Makefile \
	  src/util/info/Makefile \
	  src/util/instrm/Makefile \
	  src/util/mem/Makefile \
	  src/util/msgs/Makefile \
	  src/util/thread/Makefile \
          src/util/dbg/Makefile \
          src/include/mpi.h \
	  test/Makefile test/runtests test/util/Makefile \
	  test/mpid/Makefile \
	  test/mpid/ch3/Makefile \
	  examples/Makefile \
	  examples/f77/Makefile \
	  examples/f90/Makefile \
	  examples/cxx/Makefile \
          examples/mpiexec/Makefile \
          src/util/logging/Makefile \
          src/util/logging/common/Makefile \
          src/util/timing/Makefile \
	  doc/Makefile doc/mansrc/Makefile \
	  doc/mansrc/createhtmlindex \
	  doc/refman/Makefile \
	  doc/adi3/Makefile \
	  doc/installguide/Makefile \
	  doc/userguide/Makefile )

dnl The following files should be created by the appropriate configure within
dnl the device.
dnl          src/mpid/mm/Makefile 


PAC_SUBDIR_CACHE_CLEANUP
echo 'Configuration completed.'
