#! @PERL@
#
# Set some defaults
$includedir = ".";
$makefilebase = "Makefile.base";
$ranliblib    = 1;
$useinclude = 0;
$include_list = "";
$vpath_config = 0;   # set to 1 for @VPATH@
$nocomments = 0;     # set to 1 to exclude comments from the source file
$commonmake = "";    # Common entries for each generated Makefile
$maint_targets = 1;  # set to 0 for distribution versions
$verbose = 0;        # set to 1 to get more information
$am_a = "";          # set to _a for automake style input
$smdir = "";         # directory containing simplemake
$do_dependencies = 1;# set to 1 to attempt to generate dependency information
$autoconf_args = ""; # Extra arguments for autoconf
$do_sharedlibs  = 0; # set to 1 the generate targets for shared libraries
$root_tags = 1;
$local_tags = 0;
$create_configure_input = 1;  # Changes file.sm to file.in .  Set to 0
                              # for file.sm to file .
%libdir = ();
#
# Not yet good enough.  These are ext->o *ONLY*.
%extrules = ( 'c' => '$(C_COMPILE) -c $<', 
	      'f' => '$(F77_COMPILE) -c $<',
	     'cxx' => '$(CXX_COMPILE) -c $<' 
	     );
# Similarly, but for shared-library versions
%extrules_sh = ( 'c' => '$(C_COMPILE_SHL) -c $<', 
	      'f' => '$(F77_COMPILE_SHL) -c $<',
	     'cxx' => '$(CXX_COMPILE_SHL) -c $<' 
	     );
# Definitions for each extension (these are the defs needed for each ext->o
# extension)
%extdef = ( 'c'   => 'CC          = @CC@
CFLAGS      = @CFLAGS@
C_COMPILE   = $(CC) $(DEFS) $(INCLUDES) $(CFLAGS)',
	    'f'   => 'FC          = @FC@
FFLAGS      = @FFLAGS@
F77_COMPILE = $(FC) $(FFLAGS)',
	    'cxx' => 'CXX         = @CXX@
CXXFLAGS    = @CXXFLAGS@
CXX_COMPILE = $(CXX) $(DEFS) $(INCLUDES) $(CXXFLAGS)'
	   );
# Similarly, but for shared-library versions
%extdef_sh = ( 'c'   => 'CC_SHL      = @CC_SHL@
C_COMPILE_SHL   = $(CC_SHL) $(DEFS) $(INCLUDES) $(CFLAGS)',
	    'f'   => 'FC_SHL      = @FC_SHL@
F77_COMPILE_SHL = $(FC_SHL) $(FFLAGS)',
	    'cxx' => 'CXX_SHL     = @CXX_SHL@
CXX_COMPILE_SHL = $(CXX_SHL) $(DEFS) $(INCLUDES) $(CXXFLAGS)'
	   );
#
# Rules to build programs (.o:)
%progrules = ( 'c' => '$(C_LINK)',
	       'cxx' => '$(CXX_LINK)',
	       'f'   => '$(F77_LINK)'
	      );
%progdefs = ( 'c' =>   'C_LINK      = $(CC)',
	      'cxx' => 'CXX_LINK    = $(CXX)',
	      'f'   => 'F77_LINK    = $(FC)'
	     );
# Rules to build shared libraries (these are like programs
# Question: Do we want a common rule or separate rules for each language?
%shlibdefs = ( 'c' =>   'C_LINK_SHL  = @C_LINK_SHL@',
	       'cxx' => 'CXX_LINK_SHL= @CXX_LINK_SHL@',
	       'f'   => 'F77_LINK_SHL= @F77_LINK_SHL@'
	     );
%shlibrules = ( 'c' => '$(C_LINK_SHL)',
	       'cxx' => '$(CXX_LINK_SHL)',
	       'f'   => '$(F77_LINK_SHL)'
	      );
#
# Directories needed.  These are the prefix etc.  Many are needed only
# at the top level, particularly for installation.  srcdir is needed only for
# VPATH builds
# We must build the srcdir and top_srcdir specially because autoconf
# insists on replacing this text.
$srcdir_name =               'srcdir      =@' . "srcdir" . '@';
$topsrcdir_name =            'top_srcdir  =@' . "top_srcdir" . '@';
%dirdefs = ( 'srcdir'     => $srcdir_name,
	     'top_srcdir' => $topsrcdir_name,
	     'prefix'     => 'prefix      = @prefix@',
	     'exec_prefix'=> 'exec_prefix = @exec_prefix@',
	     'bindir'     => 'bindir      = @bindir@',
	     'sbindir'    => 'sbindir     = @sbindir@',
	     'libdir'     => 'libdir      = @libdir@',
	     'includedir' => 'includedir  = @includedir@',
	    );
# etc.
#
# Rules
# (need a way to quote the rule here and unquote it when used)
#
# Need a way to substitute for additional or replacement default rules

@subdirs = ();
foreach $_ (@ARGV) {
    if (/-nocomments/) { $nocomments = 1; }
    elsif (/-v/) { $verbose = 1; }
    elsif (/-am/) { $am_a = "_a"; }
    elsif (/-libdir=([^=]*)=(.*)$/) {
	print "libdir{$1} = $2\n";
	$libdir{$1}  = "$2/";
    }
    elsif (/-common=(.*)$/) {
	open( CD,"<$1" ) || die "Could not open $1\n";
	while (<CD>) {
	    $commonmake .= $_;
	}
	close(CD);
    }
    elsif (/-autoconf=(.*)$/) {
	$autoconf_args = $1;
    }
    elsif (/-include=(.*)$/) {
	$include_list = $1;
    }
    elsif (/-distrib/) {
	# Turn off the maintenance targets in the distribution version
	$maint_targets = 0;
    }
    elsif (/-shared/) {
	$do_sharedlibs = 1;
    }
    elsif (/-vpath=?(.*)/) {
	$val = $1;
	if ($val eq "no") { $vpath_config = 0; } 
	else { $vpath_config = 1; }
    }
    elsif (/-depend/) {
	$do_dependencies = 1;
    }
    elsif (/-nodepend/) {
	$do_dependencies = 0;
    }
    elsif (/-help/) {
	&printHelp;
	exit 0;
    }
    else {
	&ProcessFile ( $_ );
    }
}

# Check that gcc is available if we need it
if ($do_dependencies) {
    if (open (TFD, "gcc --version | 2>&1" )) {
	close TFD;
    }
    else {
	$do_dependencies = 0;
    }
}

# Routines
# Strip \n or \r\n from the end of a string
#sub strip (\@@);
sub strip {
#    my $aref = @_;
#    foreach (@$aref) { s/[\r,\n]*$//; }
    for(@_)
    {
        s/\W*$//;
    }
}

# Read Makefile.sm
sub ReadMfile {
    $Mfile = $_[0];
    open (MFILE,"<$Mfile" ) || die "Could not open $Mfile\n";
    &ClearVars;
    while (<MFILE>) {
	$origline = $_;
        # Handle continuation lines
        #chomp;
        s/[\r\n]*$//; # David added
		#strip;
        while (s/\\$//) {  # Match and remove a trailing \
	    $nextline = <MFILE>;
	    $origline .= $nextline;
	    #chomp $nextline;
	    $nextline =~ s/[\r\n]*$//; # David added
		#strip $nextline;
            $_ .= $nextline;
        }

        # Look for reserved forms:
        #lib(\w*)_SOURCES = names
        #lib(\w*)_DIR = name
        #SUBDIRS = names
	# Also keep track of Makefile usages:
	#target: ...
	#variable = value
	#.SUFFIXES:value
	# Using the _a_ in the library lines is necessary to distinguish
	# between libraries and programs that start with lib...
        if (/^lib([@\${}\(\)\w-]*)_a_SOURCES\s*=\s*(.*)$/) {
            $libname = "$1";
            $libsource = $2;
            $libraries{ $libname } = $libsource;
	    # Add to targets
	    $libloc = &GetLibLoc( $libname );
	    $alltargets[$#alltargets+1] = "${libloc}lib$libname.a";
	    if ($do_sharedlibs) {
		$alltargets[$#alltargets+1] = "${libloc}lib$libname.so";
	    }
	    # Keep track of source types
	    &FindSrcTypes( $libsource );
	    # Keep track of source files
	    &SaveSrcNames( $libsource );
        }
        elsif (/^lib([@\${}\(\)\w-]*)_a_DIR\s*=\s*(.*)\s*$/) {
	    # This is an extension over automake.  It makes it easy
	    # to modify a library in a different directory
	    # Add a trailing / because this way we can unconditionally
	    # specify the library directory
	    print "Setting libdir{$1} to $2/\n";
            $libdir{$1}  = "$2/";
        }
	elsif (/^doc_(\w*)_SOURCES\s*=\s*(.*)\s*$/) {
	    $docsrc{$1} = $2;
	}
	elsif (/^doc_(\w*)_DIR\s*=\s*(.*)\s*$/) {
	    $docdir{$1} = $2;
	}
        elsif (/^SUBDIRS\s*=\s*(.*)\s*\r?$/) {
	    # The \r is used to remove any \r in DOS-style files
            @subdirs = split(/ /,$1);
	    $subdirs_has_autoconf = 0;
        }
        elsif (/^EXTRA_PROGRAMS\s*=\s*(.*)\s*$/) {
	    $extra_programs{$1} = 1;
	}
	elsif ($nocomments && /^\s*#/) {
	       ;
	   }
	elsif (/^noinst/) {
	    # Automake target to identify some programs/libraries as
	    # not to be installed.
	    # Skip for now
	    ;
	}
	elsif (/^(\w*)_SOURCES\s*=\s*(.*)\s*$/) {
	    # programs
	    $pgm = $1;
	    $pgmsrc = $2;
	    $programs{$pgm} = $pgmsrc;
	    # Add to targets
	    $alltargets[$#alltargets+1] = $pgm;
	    # Keep track of source types
	    &FindSrcTypes( $pgmsrc );
	    # Keep track of source files
	    &SaveSrcNames( $pgmsrc );
	    # Find program source type
	    $pgmsrctype{$pgm} = &FindPgmSrcType( $pgm, $pgmsrc );
	}
	elsif (/^(\w*)_LDADD\s*=\s*(.*)\s*$/) {
	    $pgm_ldadd{$1} = $2;
	}
	elsif (/^(\w*)\s*=\s*(.*)\s*$/) {
	    $other_vars .= "$origline";
	    # Save all variable names
	    $makevars{$1} = $2;
	    # Look for special autoconf directory names
	    &LookForAutoconfDirs( $_ );
	}
	elsif (/^([^:\s]*)\s*:(.*)$/) {
	    # Remember user-defined targets.
	    $usertargets{$1} = $_;
	    $other_text .= "$origline";
	    # We could copy lines until we saw a blank line
	    if ($1 eq ".SUFFIXES") { $ExplicitSuffixes .= $2; }
	    # Look for special autoconf directory names
	    &LookForAutoconfDirs( $_ );
	    &LookForSuffixes( $_ );
	}
	else {
	    $other_text .= "$origline";
	    # Look for special autoconf directory names
	    &LookForAutoconfDirs( $_ );
	}
    $origline = "";
    }
}

#foreach $dir (split(/\s\s*/,$subdirs)) {
#    ReadMfile( "$dir/m.s" );
#}
#
sub WriteMfile {
    $maxline = 80;
    $output_filename = $_[0];
    # Write out the generated Makefile
    open( FD, ">$output_filename" ) || die "Could not open $output_filename\n";

    print FD "# This $output_filename created by simplemake.  Do not edit\n\n";
    # Ensure that the default target takes us to "all"
    print FD "all: all-redirect\n\n";
    if ($useinclude) {
        print FD "SHELL = \@SHELL\@\n";
        print FD "include $includedir/$makefilebase\n";
    }
    else {
	# We may want to break DefaultRules into a pre and post version
        &DefaultRules;
    }

    # Print out variables before generated targets
    print FD $other_vars;
    print FD "\n";

    # Generate the all-redirect: target (libraries, programs, and 
    # anything specified by all-local)
    &TargetAll;

    # Output the generated targets.  First, the libraries
    &TargetLibraries;
    if ($do_sharedlibs) {
	&TargetSharedLibraries;
    }

    # Next, the programs
    &TargetPrograms;

    # Documentation
    if ($maint_targets) {
	&TargetDocs;
    }

    if ($do_dependencies) {
	&TargetDependencies;
    }

    # Tags
    &TargetTags;

    # Unrecognized lines go here
    print FD $other_text;
    close FD;
}

#
# ===========================================================================
# Output files may contain either a set of default rules, written by this
# routine, or an include of a set of base rules.
#
sub DefaultRules {
    print FD "shell       = \@SHELL\@\n";

    # Library definitions
    if (scalar(%libraries)) {
	# Add ar, ranlib definitions if there are any library targets.
        print FD "AR          = \@AR\@\nRANLIB      = \@RANLIB\@\n";
	if ($do_sharedlibs) {
	    foreach $ext (keys(%ext_seen)) {
		if (defined($shlibdefs{$ext})) {
		    print FD "$shlibdefs{$ext}\n";
		}
	    }
	}
    }

    # Directory definitions
    foreach $dir (keys(%dirs_seen)) {
	print FD "$dirdefs{$dir}\n";
    }

    # Miscellaneous.  This needs to be improved.  This is really needed
    # only for some targets
    # The definition of DEFS is the same as for Automake
    if (defined($ext_seen{"c"}) || defined($ext_seen{"cxx"})) {
	print FD "DEFS        = \@DEFS\@ -I. -I\${srcdir}\n";
	# What to do about includes?  If they were set explicitly,
	# don't use the default.
	if (!defined($makevars{"INCLUDES"})) {
	    print FD "INCLUDES    = $include_list\n";
        }
    }
    # Add the LIBS if there are any programs to build
    if (scalar(%pgmlinktypes)) {
	print FD "LIBS        = \@LIBS\@\n";
    }

    # If there are subdirs, we need make
    if ($#subdirs >= 0 && ! defined($makevars{"MAKE"})) {
	print FD "MAKE        = \@MAKE\@\n";
    }

    # Add any standard definitions
    if ($commonmake ne "") {
	print FD "$commonmake\n";
    }

    # Definitions for each possible program type seen
    foreach $ext (keys(%ext_seen)) {
	print FD "$extdef{$ext}\n";
	if (defined($pgmlinktypes{$ext})) {
	    print FD "$progdefs{$ext}\n";
	}
	if ($do_sharedlibs) { 
	    print FD "$extdef_sh{$ext}\n";
	}
    }
    print FD "\n";
#    foreach $ext (keys(%pgmlinktypes)) {
#    }

    if ($vpath_config) {
        print FD '@VPATH@'; print FD "\n";
    }
    else {
        print FD 'VPATH = .:${srcdir}'; print FD "\n";
    }

    # Add the compilation rules.  Include only those needed for the
    # given files.  Remove all default suffix rules
    if (scalar(%ext_seen)) {
	$suffixes = ".o";
	if ($do_sharedlibs) { 
	    $suffixes .= " .lo";
	}
    }
    foreach $ext (keys(%ext_seen)) {
	$suffixes .= " .$ext";
    }
    print FD ".SUFFIXES:\n";
    if ("$suffixes $ExplicitSuffixes" ne " ") {
	print FD ".SUFFIXES: $suffixes $ExplicitSuffixes\n";
    }

    foreach $ext (keys(%ext_seen)) {
	print FD ".$ext.o:\n";
	print FD "\t$extrules{$ext}\n";
	if ($do_sharedlibs) {
	    print FD ".$ext.lo:\n";
	    print FD "\t$extrules_sh{$ext}\n";
	}
    }

    # Configure update targets
    if ( -s "configure.in" && $maint_targets ) {
	# Convert ROOTDIR as necessary
	$aargs = $autoconf_args;
	if ($rootdirpath eq "") {
	    $aargs =~ s/ROOTDIR/\./;
	}
	else {
	    #chomp( $rootdir =  $rootdirpath );
	    ( $rootdir =  $rootdirpath ) =~ s/[\r\n]*$//; # David added
		#strip( $rootdir = $rootdirpath );
	    $aargs =~ s/ROOTDIR/$rootdir/;
	}
	$aargs =~ s/\/\//\//;
	$autoconf_deps="";
	# If there is a -l dir in the autoconf_args, then add that to the
	# dependencies
	if ($aargs =~ /-l\s*([\.\/\w]*)/) {
	    $macroloc = $1;
	    $autoconf_deps .= "$macroloc/aclocal.m4";
	    $linelen = length($autoconf_deps) + 24;
	    # Extract includes from aclocal.m4
	    open (AFD, "<$macroloc/aclocal.m4" );
	    while (<AFD>) {
		if (/^\s*builtin\(include,(\w*\.m4)\)\s*$/) {
		    $filename = "$macroloc/$1";
		    if ($linelen + length(" $filename" ) + 2 > $maxline ) { 
			$autoconf_deps .= " \\\n        ";
			$linelen = 8;
		    }
		    $autoconf_deps .= " $filename";
		    $linelen += length($filename) + 1;
		}
	    }
	    close (AFD);
	}
	print FD "\nconfigure: configure.in $autoconf_deps\n";
	print FD "\tautoheader $aargs\n\tautoconf $aargs\n";
    }
    if ($maint_targets && "$smdir" ne "") {
	print FD "\nMakefile.in: Makefile.sm\n\t$smdir/simplemake Makefile.sm\n";
    }
    # Clean targets
    &TargetClean;
}

#
# ===========================================================================
#
# Look at a list of source files and determine the source types
#
# Eventually, make this $ext_seen{$extension} = 1, 
# then generate code by using keys(%ext_seen).  Allows general
# extensions and simpler handling of rules (like adding .F and .f90 )
sub FindSrcTypes {
    $source = $_[0];
    foreach $file (split(/\s\s*/,$source)) {
	($name,$ext) = split('\.',$file);
	$ext_seen{$ext} = 1;
    }
}

# Save all conventional sources
# This is only approximate.
# We want to allow source files to be specified through other 
# variables (e.g., ${Foo_sources}).
sub SaveSrcNames {
    $source = $_[0];
    foreach $file (split(/\s\s*/,$source)) {
	($name,$ext) = split( '\.',$file);
	if (defined($extrules{$ext})) {
	    $regular_sources .= " $file";
	}
	elsif ($ext eq "h") {
	    $regular_headers .= " $file";
	}
    }
}

#
# Find the name of the source file that matches the program.
# If none found, use c as the type
sub FindPgmSrcType {
    $pgm = $_[0];
    $pgmsrc = $_[1];
    foreach $file (split(/\s\s*/,$pgmsrc)) {
	($name,$ext) = split('\.',$file);
	if ($name eq $pgm) {
	    $pgmlinktypes{$ext} = 1;
	    return $ext;
	}
    }
    return "c";
}

sub ClearVars {
    # Extensions seen is a property of the makefile
    %ext_seen = ();
    %dirs_seen = ( "srcdir" );
    $other_vars = "";
    $other_text = "";
    $regular_sources = "";
    $header_sources = "";
    # Targets
    @alltargets = ();   # implicit targets 
    %usertargets = ();  # explicit, user-defined targets
    %extra_programs = ();
    %libraries = ();
    %programs = ();
    %pgm_ldadd = ();
    # Variables
    %makevars = ();
    # Information about program targets
    %pgmlinktypes = ();
    # Other directories
    @subdirs = ();
    $subdirs_has_autoconf = 0;
    # Suffix definitions
    $ExplicitSuffixes = "";
    # Document sources and directories
    %docdir = ();
    %docsrc = ();
}	

#
# Expand all of the make variables in an expression.  This
# lets users use targets like
# libmpich_SOURCE = ${MPI_SOURCES}
sub ExpandMakeVars {
    # look for ${\w*} and replace with the value of $makevars{$1}
    $_ = $_[0];
    print "Looking at $_\n" if $debug;
    while (/\${(\w*)}/) {
	print "replacing $1\n" if $debug;
	$mvar = $1;
	s/\${$mvar}/$makevars{$mvar}/g;
    }
    print "expanded to $_\n" if $debug;
    $_;
}

#
# ===========================================================================
sub ProcessFile {
    $file = $_[0];
    print "Processing $curdir$file\n";
    if (-s "configure.in") {
	&ReadAutoconf;
    }
    &ReadMfile( $file );
    $output_name = $file;
    if ($create_configure_input) {
	$output_name =~ s/\.sm$/.in/;
    }
    &WriteMfile( $output_name );

    my @dirs = @subdirs;
    # First, check for names that are replaced by autoconf (e.g., @name@)
    my @actdirs = ();
    foreach my $dir (@dirs) {
	$sdir = $dir;
	#print "Checking $sdir\n";
	if ($sdir =~ /@([^@]*)@/) {
	    $subst_name = $1;
	    $subdirs_has_autoconf = 1;
	    #print "Found $subst_name\n";
	    # Look up the special name
	    $var_name = "SUBDIRS_$subst_name";
	    #print "varname is $var_name\n";
	    if (defined( $makevars{$var_name} )) {
		# Concatenate the value of the variable name to the list
		# of directories
		@actdirs = ( @actdirs, split( / /, $makevars{$var_name} ) );
	    }
	}
	else {
            $actdirs[$#actdirs+1] = $dir;
        }
    }
    M: foreach my $dir (@actdirs) {
	if ($dir eq ".") { next M; }
	if (! -d $dir) { print "Directory $curdir$dir does not exist\n"; next M; }
	if (! -s "$dir/$file") { print "File $curdir$dir/$file does not exist\n"; next M; }
	chdir $dir;
	$curdir .= "$dir/";
	$rootdirpath .= "../";
	#print "rootdir = $rootdirpath\n";
	#print "curdir = $curdir\n";
	&ProcessFile( $file );
	$rootdirpath =~ s/\.\.\/$//;
	chdir "..";
	$curdir =~ s/[^\/]*\/$//;
    }
}

sub ListTargets {
  T: foreach $target (@alltargets) {
      # Skip the extra programs
      if (defined($extra_programs{$target})) { next T; }
      print FD " $target";
  }
}			       

#
# Add to a target the designate operation in all subdirs (except for .)
#     &RecursiveOp( "target" );
sub RecursiveOp {
    $target = $_[0];
    print "n subdirs = $#subdirs\n" if $debug;
    if ($#subdirs == 0 && $subdirs[0] eq ".") { return; }
    if ($#subdirs >= 0) { 
        print FD "\tfor dir in";
        foreach $dir (@subdirs) {
	    if ($dir ne ".") { print FD " $dir"; }
	    if ($dir =~ /@[^@]*@/) {
		$subdirs_has_autoconf = 1;
	    }	    
        }
	if ($subdirs_has_autoconf) {
	    # Add a - incase there is a problem
          print FD " - ; do \\\n";
	  print FD "\t\tif [ \"\$\$dir\" = \"-\" ] ; then break ; fi ;\\\n";
	  print FD "\t\t(cd \$\$dir ; \${MAKE} $target ; ) ; done\n";
        }	
	else {
          print FD " ; do \\\n\t\t(cd \$\$dir ; \${MAKE} $target ; ) ; done\n";
        }
    }
}

#
# Return the directory in which the named library should be in
sub GetLibLoc {
    $libname = $_[0];
    
    $libloc = $libdir{$libname};
    #chomp( $rootdir =  $rootdirpath );
    ( $rootdir =  $rootdirpath ) =~ s/[\r\n]*$//; # David added
	#strip ( $rootdir =  $rootdirpath );
    $libloc =~ s/ROOTDIR/$rootdir/;
    # Remove duplicated //
    $libloc =~ s/\/\//\//;

    $libloc;
}


#
# Look for autoconf directory variables that are used 
sub LookForAutoconfDirs {
    $line = $_[0];
    print "Looking at $line\n" if $debug;
    # Look for \$\{\w*\} and \$\(\w*\) 
    while ($line =~ /^[^\$]*\$[\{\(](\w*)[\}\)](.*)$/) {
	$varname = $1;
	$line = $2;
	print "Found $varname in line\n" if $debug;
	# Look for varname in the known names; add to dirs_seen
	if (defined($dirdefs{$varname})) {
	    $dirs_seen{$varname} = $varname;
	}
    }
}

sub LookForSuffixes {
    $line = $_[0]; 
    while ($line =~ /^[^\.]*\.(\w*)\s*(.*)$/) {
	$suffix = $1;
	$line   = $2;
	if (defined($extdef{$suffix})) {
	    $ext_seen{$suffix} = 1;
	}
    }
}

#
# ===========================================================================
# The "all" target.
#
# Output the target list.  If there are extra_programs, note that.
# FIXME: there needs to be way to specify other local targets
# beyond the implicitly determined ones.  This needs to allow
# for both pre and post implicit target values
#
sub TargetAll {
    print FD "all-redirect:";
    if ($#subdirs > -1) {
	print FD "\n";
	$has_dot = 0;
	foreach $dir (@subdirs) {
	    if ($dir eq ".") {
		if (scalar(@alltargets) || 
		    defined($usertargets{"all-local"})) {
		    $has_dot = 1;
		    print FD "\t\${MAKE} all-local\n";
		}
	    }
	    elsif ($dir =~ /@([^@]*)@/) {
		# May be a replaced variable
		print FD "\tfor dir in $dir - ; do\\\n";
		print FD "\t\tif [ \"\$\$dir\" = \"-\" ] ; then break ; fi ; \\\n";
		print FD "\t\t(cd \$\$dir ; \${MAKE} all ) ;\\\n";
		print FD "\tdone\n";
	    }
	    else {
		print FD "\t(cd $dir ; \${MAKE} all )\n";
	    }
	    # If subdirs has no dot but there are local targets, add an 
	    # implicit dot to the end.
	    if (!$has_dot && $#alltargets > -1) {
		$has_dot = 1;
		print FD "\t\${MAKE} all-local\n";
	    }
	}
	if ($has_dot && !defined($usertargets{"all-local"})) {
	    print FD "all-local:";
	    &ListTargets;
	}
    }
    else {
	if (defined($usertargets{"all-local"})) {
	    # Add all-local as a target
	    print FD " all-local ";
	}
	&ListTargets;
    }
    print FD "\n";
}

#
# ===========================================================================
# The "clean" target
# 
# Produces clean: and distclean: .
# If clean-local or distclean-local were defined, they are included in
# the dependency lists
sub TargetClean {
    $programnames = join( ' ', keys(%programs));
    print FD "clean:";
    if (defined($usertargets{"clean-local"})) { print FD " clean-local"; }
    print FD "\n\t-rm -f *.o \${srcdir}/*.o *~ $programnames\n";
    &RecursiveOp( "clean" );
    print FD "distclean: clean";
    if (defined($usertargets{"distclean-local"})) { 
	print FD " distclean-local";
    }
    print FD "\n";
    &RecursiveOp( "distclean" );
    # Remove any local files last (in case this file is one of them)
    $rmfile = "";
    $lcurdir = "$curdir";
    $lcurdir =~ s/\/$//;
    #print "|$lcurdir|\n";
    if (defined($autoconf_files_by_dir{$lcurdir})) {
	$rmfile = $autoconf_files_by_dir{$lcurdir};
	print FD "\t-rm -f $rmfile\n";
    }
    if ($maint_targets) {
	print FD "maintainerclean:";
	if (defined($usertargets{"maintainerclean-local"})) {
	    print FD " maintainerclean-local";
	}
	print FD "\n";
	&RecursiveOp( "maintainerclean" );
	# Remove The file that simplemake creates
	print FD "\t-rm -f $output_name\n";
	# eventually, this should also invoke distclean, but it must
	# do that only once (not recursively) and only after all other
	# uses of the Makefile, since distclean removes the Makefile
	# Directories containing autoconf should include an rm of configure
    }
}

#
# ===========================================================================
# Libraries
sub TargetLibraries {
    foreach $lib (keys(%libraries)) {
	$libloc = &GetLibLoc( $lib );
        print FD "${libloc}lib$lib.a: ";
        $linelen = length("${libloc}$lib.a: ");
        foreach $sourcefile (split(/\s\s*/,&ExpandMakeVars($libraries{$lib}))) {
            $obj = $sourcefile;
            # Convert to object file
	    $ext = $sourcefile;
	    $ext =~ s/^.*\.//g;
	    if (defined($extrules{$ext})) {
		$obj =~ s/\.$ext/\.o/g;
	    }
	    else {
		print "Unknown extension $ext for $sourcefile\n";
	    }
	    
            if (length($obj) + $linelen + 2 >= $maxline) {
	        print FD "\\\n\t";
                $linelen = 8;
            }
            print FD "$obj ";
            $linelen += length($obj) + 1;
        }
        print FD "\n";
        print FD "\t\${AR} cr ${libloc}lib$lib.a \$?\n";
        if ($ranliblib) { 
	    print FD "\t\${RANLIB} ${libloc}lib$lib.a\n"; 
	}

#        if ($doprofilelib) {
#            print FD "$libdir{P$lib}P$lib.a:";
#        }
    }
}

sub TargetSharedLibraries {
    foreach $lib (keys(%libraries)) {
	$libloc = &GetLibLoc( $lib );
        print FD "${libloc}lib$lib.so: ";
        $linelen = length("${libloc}$lib.so: ");
        foreach $sourcefile (split(/\s\s*/,&ExpandMakeVars($libraries{$lib}))) {
            $obj = $sourcefile;
            # Convert to object file
	    $ext = $sourcefile;
	    $ext =~ s/^.*\.//g;
	    if (defined($extrules{$ext})) {
		$obj =~ s/\.$ext/\.lo/g;
	    }
	    else {
		print "Unknown extension $ext for $sourcefile\n";
	    }
	    
            if (length($obj) + $linelen + 2 >= $maxline) {
	        print FD "\\\n\t";
                $linelen = 8;
            }
            print FD "$obj ";
            $linelen += length($obj) + 1;
        }
        print FD "\n";
        print FD "\t\${C_LINK_SHL} -o ${libloc}lib$lib.so \$?\n";
    }
}

#
# ===========================================================================
sub TargetPrograms {
    foreach $pgm (keys(%programs)) {
	print FD "$pgm: ";
	$linelen = length( $pgm ) + 2;
	$pgmobjs = "";
	foreach $sourcefile (split(/\s\s*/,$programs{$pgm})) {
            $obj = $sourcefile;
            # Convert to object file
	    $ext = $sourcefile;
	    $ext =~ s/^.*\.//g;
	    if (defined($extrules{$ext})) {
		$obj =~ s/\.$ext/\.o/g;
	    }
	    else {
		print "Unknown extension $ext for $sourcefile\n";
	    }
            if (length($obj) + $linelen + 2 >= $maxline) {
	        print FD "\\\n\t";
                $linelen = 8;
            }
            print FD "$obj ";
	    $pgmobjs .= "$obj ";
            $linelen += length($obj) + 1;
        }
	# Add dependencies on libraries if requested
	if (1) {
	    # convert -L dir -lname into dir/libname.a
	    $libdep=$pgm_ldadd{$pgm};
	    $libdep =~ s/-L\s*([\w\.\/]*)\s*-l(\w*)//;
	    print FD " $1/lib$2.a";
	}
	# Use the link rule appropriate for this program type
	$pgmtype = $pgmsrctype{$pgm};
	print FD "\n\t$progrules{$pgmsrctype{$pgm}} -o $pgm $pgmobjs $pgmlibs{$pgm} $pgm_ldadd{$pgm} \${LIBS}\n";
    }

}

#
# ===========================================================================
sub TargetTags {
    if (!$local_tags && !$root_tags) { return; }
    
    # Generate a listing of header and source files
    $has_sources = 0;
    $has_headers = 0;
    if ($regular_sources ne "") {
	print FD "SOURCES = $regular_sources\n";
	$has_sources = 1;
    }
    if ($regular_headers ne "") {
	print FD "HEADERS = $regular_headers\n";
	$has_headers = 1;
    }
    print FD "TAGS:";
    # Only generate a local etags call if there are local sources
    # This target is designed for VPATH builds to build a TAGS file in
    # a vpath location.
    if ($has_headers || $has_sources) {
        if ($local_tags) {
	    print FD '${HEADERS} ${SOURCES}
	here=`pwd`;\
	(cd ${srcdir} && etags -o $$here/TAGS --append ${HEADERS} ${SOURCES};)
';
        }
        elsif ($root_tags) {
	    print FD "\${HEADERS} \${SOURCES}\n";
	    $rpath = $rootdirpath;
	    $rpath =~ s/\/$//;
	    print FD "\tetags -o $rpath/TAGS --append \${HEADERS} \${SOURCES}\n";
        }
        else {
	    print FD "\n";
        }
    }
    else {
	print FD "\n";
    }
    &RecursiveOp( "TAGS" );
}

sub TargetDocs {
    foreach $kind (keys(%docsrc)) {
	print FD "$kind:\n";
	if (defined($docdir{$kind})) { 
	    $loc = "-mpath $docdir{$kind}";
	}
	else {
	    $loc = "";
	}
	print FD "\tdoctext -$kind $loc -heading MPI -quotefmt \\\n\t";
	# Eventually need to add default files (e.g., fortnotes, errnotes)
	# Web version needs indexdir, defn, mapref, ...
	$linelen = 8;
	foreach $sourcefile (split(/\s\s*/,$docsrc{$kind})) {
            if (length($sourcefile) + $linelen + 2 >= $maxline) {
	        print FD "\\\n\t";
                $linelen = 8;
            }
            print FD "sourcefile ";
	    $pgmobjs .= "$sourcefile ";
            $linelen += length($sourcefile) + 1;
        }
    }
}

#
# ===========================================================================
# Other targets and stuff to be added:
#   Support for .s -> .o (AS)
#   CPP
#   Including common headers (e.g., all file.sm's get a common header of
#       variables defined by configure.  This is cleaner than the automake 
#       approach of including *every* AC_SUBST value).
#   Support for shared libraries.  Unlike automake, we will not require
#       separate rules (automake uses lib_LTLIBRARIES and la extensions)
#       for shared library support.
#   Dependencies on the file.sm's (e.g., rerun simplemake when source
#   Makefile.sm's change, including updating the Makefile from the
#       Makefile.in) 
#   Handling files to be installed (e.g., automake's sbin_PROGRAMS = ...)
#      (automake understands <dir>_PROGRAMS and <dir>_LIBRARIES)
#   LDADD (automake has target_LDADD; we want a general LD_ADD as well)
#       Partially done - Remaining question is where to insert LDADD value
#       (e.g., before or after LIBS?)
#   target_LDFLAGS and general LDFLAGS
#   INCLUDES (automake variable that we've adopted) needs better control.
#   Support for .F and .F90 extensions
#   FLIBS
#   Linker choice.  simplemake uses the file type of the *first* source file.
#       automake has a matrix that depends on the source files referred to.
#   SCRIPTS (as in bin_SCRIPTS) targets
#   HEADERS variables (as in prog_HEADERS).  In many cases, this should
#       be determined automatically.  Note that it is needed for correct TAGS
#       generation.

# Miscellaneous Routines
sub printHelp {
    print STDERR "\
simplemake [ -nocomments ] [ -am ] [ -libdir=NAME=DIR ] [ -include=LIST ]\
           files \
    -nocomments      - Exclude Makefile comments from generated file\
    -libdir=NAME=DIR - library NAME is located in directory DIR\
    -am              - Automake style target names\
    -include=LIST    - CPP style list of include directories (e.g., -Ia -Ib)\
                       These define INCLUDES unless a Makefile.sm defines\
                       that value\n";
    print STDERR "\
    Recognized target forms\
    libname_a_SOURCES = source files for library \"name\"\
    libname_a_DIR     = location of directory into which lib \"name\" goes\
    SUBDIRS = blank separated list of subdirectories to process.  Use \".\"\
              to control the order in which the current directory is processed\
    EXTRA_PROGRAMS = names of programs to define rules for but not to build\
                     by default\
    name_SOURCES = source files for program \"name\"\
    name_LDADD   = extra linker flags for building program \"name\"\
\
    simplemake also allows all usual Makefile commands, including variable\
    assignment and targets.\n";
}

#
# Generate dependency information when possible.  This version simply 
# uses gcc -MM; if that doesn't work, does nothing.  
#
# Automake strives to generate the dependencies.  This is a better approach,
# but it is very difficult to implement in practice, particularly where the
# development environment is not GNU.  
sub AddDependency {
    $target = $_[0];
    if (defined($makevars{"INCLUDES"})) {
	$include = $makevars{"INCLUDES"};
    }
    else {
	$include = $include_list;
    }
    print "Trying gcc -MM $include $target\n" if $debug;
    open( DEPFD, "gcc -MM $include $target |" ) || return;
    while (<DEPFD>) {
	print FD $_;
    }
    close( DEPFD );
}
sub TargetDependencies {
    print FD "# Dependencies\n";
    # Libraries first
    foreach $lib (keys(%libraries)) {
        foreach $sourcefile (split(/\s\s*/,&ExpandMakeVars($libraries{$lib}))) {
            $obj = $sourcefile;
            # Get extension
	    $ext = $sourcefile;
	    $ext =~ s/^.*\.//g;
	    # We only know about C for now.
	    if ($ext eq "c") {
		&AddDependency( $sourcefile );
	    }
        }
    }
    # Programs
    foreach $pgm (keys(%programs)) {
	foreach $sourcefile (split(/\s\s*/,$programs{$pgm})) {
            $obj = $sourcefile;
	    $ext = $sourcefile;
	    $ext =~ s/^.*\.//g;
	    # We only know about C for now.
	    if ($ext eq "c") {
		&AddDependency( $sourcefile );
	    }
	}
    }
}


# Extract derived files from autoconf
sub ReadAutoconf {
    open FDCONF, "configure.in" || die "Could not open configure.in file";
    while (<FDCONF>) {
	#if (/^\s*#/) { next; }
	if (/^\s*AC_OUTPUT\(/) {
	    # First, read past all continued lines
	    $line = "";
	    while (/\\\s*$/) {
		#chomp;    # remove trailing EOL (\n on Unix, \r\n on DOS)
		s/[\r\n]*$//; # David added
		#strip;
		chop($_); # remove the backslash
		$line .= $_;
		$_ = <FDCONF>;
	    }
	    $line .= $_; 
	    #chomp( $line );
	    $line =~ s/[\r\n]*$//; # David added
		#strip ( $line );
	    #print $line;
	    $line =~ /^\s*AC_OUTPUT\((.*)\)\s*$/;
	    $files = $1;
	    @autoconf_files = split(/\s\s*/,$files);
	    # Create a hash by directory
	    $lcurdir = $curdir;
	    $lcurdir =~ s/\/$//;
	    foreach $file (@autoconf_files) {
		if ($file =~ /^(.*)\/([^\/]*)$/) {
		    $autoconf_files_by_dir{"$curdir$1"} .= " $2";
		    #print "{$curdir$1} .= $2\n";
		    # Also add files that are in directories with no simplemake
		    # input (e.g., in include directories with no makefile)
		    if (! -s "$curdir$1/Makefile.sm") {
			$autoconf_files_by_dir{$lcurdir} .= " $file";
		    }
		}
		elsif ($file =~ /^.*$/) {
		    $autoconf_files_by_dir{"$lcurdir"} .= " $file";
		    #print "{$lcurdir} .= $file\n";
		}
	    }
	    # Add files that configure generates in the current directory
	    $autoconf_files_by_dir{$lcurdir} .= " config.status config.log config.cache config.system";
	    #print "$files\n";
	    last;
	}
    }
    close FDCONF;
}
# Eventually we will use this to generate the profiling targets.
sub ProfileTargets {
    print FD "\
# Instead, we define the PMPI_OBJECTS as having suffix pf:\
PMPI_OBJECTS = \${OBJECTS:.o=.pf}\
# Convert foo.pf to _foo.o, then archive all at once\
${libbuild_dir}/lib\@PMPILIBNAME\@.a: \${PMPI_OBJECTS}\
        \@echo \"Rename xxx.pf to _xxx.o for profiling interface.\"\
        \@if [ ! -d .tmp ] ; then mkdir .tmp ; else rm -f .tmp/*.o ; fi\
        \@for file in $? ; do \\\
            bname=`basename $$file .pf`; \\\
            cp $$file .tmp/_$${bname}.o ; \\\
        done\
        \@cd .tmp && ${AR} cr $\@ *.o && rm -f *.o\
        -\@rmdir .tmp\
# Note that the Solaris SunPro cc (4.0 98/12/15) does not allow the file\
# named with -o to have any suffix other than .o !\
.c.pf:\
        \${C_COMPILE} -c -DMPICH_MPI_FROM_PMPI \$< -o \$*.o\
        \@mv -f \$*.o \$*.pf\
.f.pf:\
        \${F77_COMPILE} -c \$<\
        \@mv -f \$*.o \$*.pf\
";
}
