#! /usr/bin/perl
#use Crypt::DSA;
#
# Check that coding standards have been followed.  This checks for common
# and easy to overlook errors, such as the use of non-portable system routines
#
# ToDo:
# Add support for
# /* style: allow:routine-name:count sig:value */
# where routine-name is the name of a routine that is on the warning list
# and value is a digital signature computed from the filename and routine-name
# by the lead programmer.
#
# Add line-length check.  Optionally warn of >80 character lines.

require "maint/parse.sub";

$debug = 0;
$showfiles = 0;

# Check for special args
@files = ();
foreach $arg (@ARGV) {
    if ($arg =~ /^-showfiles/) { $showfiles = 1; }
    elsif( $arg =~ /-debug/) { $debug = 1; }
    else {
	print "Adding $arg to files\n" if $debug;
	$files[$#files+1] = $arg;
    }
}

# Call once for each file
sub ProcessFile {
    $filename = $_[0];
    %AllowedRoutines = ();
    $cxx_comments_found = 0;
    &ClearPreamble;
    %warningmsgs = ();
    &ClearMismatchedStates;
    open( FD, "<$filename" ) || die "Could not open $filename";
    while (<FD>) {
#	if (/\/\*-ALLOW-PRINTF-\*\//) {
#	    
#	}
	$errsrc = " in $filename";
	# Check for special comments
	if (/\/\* style: *allow:(\w*):(\d*) *sig:(\d*)/) {
	    # Found a style comment.  Add the routine name to this 
	    # list of allowed routines.  Eventually, this may require
	    # a signed key
	    # Compute as (using the Crypt module)
            # $public = new Crypt::RSA::Key::Public(Filename => $keyfile, );
            # $rsa->verify( Message => "$1:$2:$filename", 
	    # Signature => $3, Key => $public ) && $AllowedRoutines{$1}=$2;
            # But for now, we do:
	    $AllowedRoutines{$1} = $2;
	}
	# The preamble is within a comment
	&CheckForPreamble( $_ );
	$_ = StripComments( FD, $_ );
	if ($comment_line ne "") { &CheckForPreamble( $comment_line ); }
	# Check for C++ style comments
	if (/\/\//) {
	    $cxx_comments_found ++;
	    if ($cxx_comments_found == 1) {
		print "C++ comment found in $filename:\n";
		my $line = $_;
		if (/(.*)\n/) {
		    $line = "$1\n";
		}
		else {
		    $line = $_;
		}
		print $line;
	    }
	    s/\/\/.*//;
	}
	&CheckForBadSubs( $_, $filename );
        &CheckForBadDefines( FD, $_, $filename );
	&CheckForMismatchedStates ( FD, $_, $filename );
    }
    # Output summary messages
    foreach $key (keys(%warningmsgs)) {
	print "$key ($warningmsgs{$key} times)\n";
    }
    if ($cxx_comments_found > 1) {
	print "$cxx_comments_found C++ comments found in $filename\n";
    }
    &ReportOnPreamble( $filename );
}

#
# Subroutines that we want to avoid
@avoidsubs = ( "fprintf", "fputs", "puts", "printf", 
               "malloc", "calloc", "free", "strdup", "realloc" );
@guardedsubs = ( "alloca", "closedir", "fnmatch", "getloadavg", 
		 "getmntent", "getpgrp", "memcmp", "mmap", 
		 "setpgrp", "setvbuf", "strcoll", "strftime",
		 "utime", "vfork", "vprintf", "wait3" );
%bettersubs = ( "strcpy" => "strncpy",
		"strcmp" => "strncmp",
		"strcat" => "strncat",
		"sprintf" => "snprintf" );

sub CheckForBadSubs {
    my $curline = $_[0];
    my $filename = $_[1];
    foreach $subname (@avoidsubs) {
	if (/(?<!\w)$subname\s*\(/ && !defined($AllowedRoutines{$subname})) {
	    $msg = "Warning: found $subname in $filename";
	    if (defined($warningmsgs{$msg})) { 
		$warningmsgs{$msg} = $warningmsgs{$msg} + 1;
	    }
	    else {
		$warningmsgs{$msg} = 1;
	    }
	}
    }
    # The guarded subs are ones that GNU autoconf is worried about.
    # This code should look for some sort of configure-style CPP value
    # and allow the ones that are properly guarded.
    foreach $subname (@guardedsubs) {
	if (/$subname\s*\(/) {
	    print "Caution: found reference to routine $subname in $filename\n";
	}
    }
    foreach $subname (@guardsubs) {
        if (/(?<!\w)$subname\s*\(/ && !defined($AllowedRoutines{$subname})) {
            $msg = "Caution: found $subname in $filename";
            if (defined($warningmsgs{$msg})) {
                $warningmsgs{$msg} = $warningmsgs{$msg} + 1;
            }
            else {
                $warningmsgs{$msg} = 1;
            }
        }
    }
#    foreach $subname (keys %bettersubs) {
#	if (/$subname\s*\(/) {
#	    print "Caution: found reference to routine $subname in $filename\n";
#	    print "Consider using $bettersubs{$subname} instead\n";
#	}
#    }

    foreach $subname (keys %bettersubs) {
        if (/(?<!\w)$subname\s*\(/ && !defined($AllowedRoutines{$subname})) {
            $msg = "Caution: found $subname in $filename, consider $bettersubs{$subname}";
            if (defined($warningmsgs{$msg})) {
                $warningmsgs{$msg} = $warningmsgs{$msg} + 1;
            }
            else {
                $warningmsgs{$msg} = 1;
            }
        }
    }
}

@GoodNames = ( 'HAVE_[A-Za-z0-9_]*', 'USE_[A-Za-z0-9_]*',
	       'MPICH_SINGLE_THREADED', 'CHAR_PTR_IS_ADDRESS', 'FOO',
	       'STDC_HEADERS', '__cplusplus', 'IOV_MAX',
	       'MPID_[A-Za-z0-9_]*',
	       'MPIDI_[A-Za-z0-9_]*',   # Internal MPID names
	       'MPICH_[A-Za-z0-9_]*', 
	       'DBG_[A-Z0-9_]*',
	       'WITH_[A-Z0-9_]*',
	       'MPI_BUILD_PROFILING' );
@BadNames = ( 'rs6000', 'solaris', 'hpux', 'linux', 'HPUX', 'IRIX' );
sub CheckName {
    my $name = $_[0];
    foreach $good (@GoodNames) {
	if ($name =~ /$good/) { return 0; }
    }
    foreach $bad (@BadNames) {
	if ($name =~ /$bad/) { return 1; }
    }
    return 1;
}
sub CheckForBadDefines {
    my $FD = $_[0];
    my $curline = $_[1];
    my $filename = $_[2];
    if ($curline =~ /^\s*#if/) {
	while ($curline =~ /\/$/) {
	    $curline .= <$FD>;
	}
	# Search for either ifdef or defined(...)
	if ($curline =~ /^\s*#ifdef\s*(.*)\s*/) {
	    $defname = $1;
	    $defname =~ s/\r*\n*//g;
	    print "$defname\n" if $debug;
	    if (&CheckName( $defname ) ) {
		print "Warning: ifdef name $defname used in $filename is nonstandard\n"
	    }
	}
	elsif ($curline =~ /^\s*#if\s/ || $curline =~ /^\s*#elif\s/) {
	       while ($curline =~ /defined\(([^\)]*)\)/) {
		   $defname = $1;
		   print "$defname\n" if $debug;
		   if (&CheckName( $defname ) ) {
		       print "Warning: ifdef name $defname used in $filename is nonstandard\n"
		       }
		   $curline =~ s/defined\($defname\)//g;
	       }
	}
    }
}

foreach $file (@files) {
    print "$file\n" if $showfiles;
    &ProcessFile( $file );
}

#
# Look for mismatched names in the state definitions 
# MPID_MPI_FUNC_EXIT, MPID_MPI_FUNC_ENTER
$statename = "";
$funcname  = "";
sub ClearMismatchedStates {
    $statename = "";
    $funcname  = "";
}
sub CheckForMismatchedStates {
    my $FD = $_[0];
    my $curline = $_[1];
    my $filename = $_[2];
    if ($curline =~ /#define\s\s*FUNCNAME\s\s*(.*)\s*$/) {
        $funcname = $1;
        $funcname =~ s/\r//;
	$funcname =~ tr/a-z/A-Z/;
    }
    elsif ($curline =~ /\s*#define/) { return; }
    elsif ($curline =~ /MPID_MPI_FUNC_ENTER\(\s*(.*)\s*\)/) {
	$statename = $1;
	$funcstatename = "MPID_STATE_".$funcname;
	if ($funcname ne "" && $statename ne $funcstatename) {
	    print "Warning: State name \"$statename\" does not match function name \"$funcname\"\n";
	}
    }
    elsif ($curline =~ /MPID_MPI_FUNC_EXIT\(\s*(.*)\s*\)/) {
	$endname = $1;
	if ($statename ne $endname && $endname ne "stateid") {
	    print "Warning: State $statename ended with $endname in $filename\n";
	}
    }
}

#
# Check for proper preamble.  Record during file reading and check at end
$saw_c_style = 0;
$saw_copyright = 0;

sub ClearPreamble {
    $saw_c_style = 0;
    $saw_copyright = 0;
}    
sub CheckForPreamble {
    my $curline = $_[0];
    if ($curline =~ /-\*-\s*Mode:\s*C;\s*c-basic-offset:4/) {
	$saw_c_style = 1;
    }
    elsif ($curline =~ /See COPYRIGHT/) {
	$saw_copyright = 1;
    }
}
sub ReportOnPreamble {
    my $filename = $_[0];

    # Is this a derived file?
    if (-s "$filename.in") { return 0; }
    if (! $saw_c_style) {
	print "C style header (c-basic-offset:4) missing in $filename\n";
    }
    if (! $saw_copyright) {
	print "Copyright statement missing from $filename\n";
    }
}
