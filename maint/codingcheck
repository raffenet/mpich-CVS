#! /usr/bin/perl
#
# Check that coding standards have been followed.  This checks for common
# and easy to overlook errors, such as the use of non-portable system routines
#
# ToDo:
# Add support for
# /* style: allow:routine-name sig:value */
# where routine-name is the name of a routine that is on the warning list
# and value is a digital signature computed from the filename and routine-name
# by the lead programmer.
#
# Add line-length check.  Optionally warn of >80 character lines.

require "maint/parse.sub";

$debug = 0;
$showfiles = 0;

# Check for special args
@files = ();
foreach $arg (@ARGV) {
    if ($arg =~ /^-showfiles/) { $showfiles = 1; }
    elsif( $arg =~ /-debug/) { $debug = 1; }
    else {
	print "Adding $arg to files\n" if $debug;
	$files[$#files+1] = $arg;
    }
}

# Call once for each file
sub ProcessFile {
    $filename = $_[0];
    %warningmsgs = ();
    open( FD, "<$filename" ) || die "Could not open $filename";
    while (<FD>) {
#	if (/\/\*-ALLOW-PRINTF-\*\//) {
#	    
#	}
	$errsrc = " in $filename";
	$_ = StripComments( FD, $_ );
	# Check for C++ style comments
	if (/\/\//) {
	    print "C++ comment found in $filename:\n";
	    my $line = $_;
	    if (/(.*)\n/) {
		$line = "$1\n";
	    }
	    else {
		$line = $_;
	    }
	    print $line;
	    s/\/\/.*//;
	}
	&CheckForBadSubs( $_, $filename );
        &CheckForBadDefines( FD, $_, $filename );
    }
    # Output summary messages
    foreach $key (keys(%warningmsgs)) {
	print "$key ($warningmsgs{$key} times)\n";
    }
}

#
# Subroutines that we want to avoid
@avoidsubs = ( "fprintf", "fputs", "puts", "printf", 
               "malloc", "calloc", "free", "strdup", "realloc" );
@guardedsubs = ( "alloca", "closedir", "fnmatch", "getloadavg", 
		 "getmntent", "getpgrp", "memcmp", "mmap", 
		 "setpgrp", "setvbuf", "strcoll", "strftime",
		 "utime", "vfork", "vprintf", "wait3" );
%bettersubs = ( "strcpy" => "strncpy",
		"strcmp" => "strncmp",
		"strcat" => "strncat",
		"sprintf" => "snprintf" );

sub CheckForBadSubs {
    my $curline = $_[0];
    my $filename = $_[1];
    foreach $subname (@avoidsubs) {
	if (/(?<!\w)$subname\s*\(/) {
	    $msg = "Warning: found $subname in $filename";
	    if (defined($warningmsgs{$msg})) { 
		$warningmsgs{$msg} = $warningmsgs{$msg} + 1;
	    }
	    else {
		$warningmsgs{$msg} = 1;
	    }
	}
    }
#    foreach $subname (@guardedsubs) {
#	if (/$subname\s*\(/) {
#	    print "Caution: found reference to routine $subname in $filename\n";
#	}
#    }
    foreach $subname (@guardsubs) {
        if (/(?<!\w)$subname\s*\(/) {
            $msg = "Caution: found $subname in $filename";
            if (defined($warningmsgs{$msg})) {
                $warningmsgs{$msg} = $warningmsgs{$msg} + 1;
            }
            else {
                $warningmsgs{$msg} = 1;
            }
        }
    }
#    foreach $subname (keys %bettersubs) {
#	if (/$subname\s*\(/) {
#	    print "Caution: found reference to routine $subname in $filename\n";
#	    print "Consider using $bettersubs{$subname} instead\n";
#	}
#    }

    foreach $subname (keys %bettersubs) {
        if (/(?<!\w)$subname\s*\(/) {
            $msg = "Caution: found $subname in $filename, consider $bettersubs{$subname}";
            if (defined($warningmsgs{$msg})) {
                $warningmsgs{$msg} = $warningmsgs{$msg} + 1;
            }
            else {
                $warningmsgs{$msg} = 1;
            }
        }
    }
}

@GoodNames = ( 'HAVE_[A-Za-z0-9_]*', 'USE_[A-Za-z0-9_]*',
	       'MPICH_SINGLE_THREADED', 'CHAR_PTR_IS_ADDRESS', 'FOO',
	       'STDC_HEADERS', '__cplusplus',
	       'MPID_[A-Za-z0-9_]*',
	       'MPICH_[A-Za-z0-9_]*', 
	       'DBG_[A-Z0-9_]*',
	       'WITH_[A-Z0-9_]*',
	       'MPI_BUILD_PROFILING' );
@BadNames = ( 'rs6000', 'solaris', 'hpux', 'linux', 'HPUX', 'IRIX' );
sub CheckName {
    my $name = $_[0];
    foreach $good (@GoodNames) {
	if ($name =~ /$good/) { return 0; }
    }
    foreach $bad (@BadNames) {
	if ($name =~ /$bad/) { return 1; }
    }
    return 1;
}
sub CheckForBadDefines {
    my $FD = $_[0];
    my $curline = $_[1];
    my $filename = $_[2];
    if ($curline =~ /^\s*#if/) {
	while ($curline =~ /\/$/) {
	    $curline .= <$FD>;
	}
	# Search for either ifdef or defined(...)
	if ($curline =~ /^\s*#ifdef\s*(.*)\s*/) {
	    $defname = $1;
	    $defname =~ s/\r*\n*//g;
	    print "$defname\n" if $debug;
	    if (&CheckName( $defname ) ) {
		print "Warning: ifdef name $defname used in $filename is nonstandard\n"
	    }
	}
	elsif ($curline =~ /^\s*#if\s/ || $curline =~ /^\s*#elif\s/) {
	       while ($curline =~ /defined\(([^\)]*)\)/) {
		   $defname = $1;
		   print "$defname\n" if $debug;
		   if (&CheckName( $defname ) ) {
		       print "Warning: ifdef name $defname used in $filename is nonstandard\n"
		       }
		   $curline =~ s/defined\($defname\)//g;
	       }
	}
    }
}

foreach $file (@files) {
    print "$file\n" if $showfiles;
    &ProcessFile( $file );
}
