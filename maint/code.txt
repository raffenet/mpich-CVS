A brief summary of the checks performed by "codingcheck" and the
reasons for them.  

1. #ifdef and #define names:  We want to use a prefix on these in
    order to avoid clashes with other systems that aren't careful
    about names.  One vendor defined CACHE_ALIGN, which broke code
    used in MPICH1 to cache align data structures.  Prefixes should be
    USE_, HAVE_, MPIR_, MPID_ . 

2. malloc/free/calloc/realloc/strdup: By using the MPIU_xxx routines,
   it is easier to check for storage overwrites and leaks, even on
   systems (or at scales) where we don't have more sophisticated tools
   for trapping memory problems.  Since these can be replaced by
   macros that directly call malloc etc., there is no performance
   overhead. 

3. printf/fprintf: To allow for internationalization, all messages
   that users may see should go through MPIU_Usage_printf,
   MPIU_Msg_printf, MPIU_Error_printf, and MPIU_Internal_error_printf
   (this also helps separate messages that are intended for users and
   ones that represent some internal error that a user may see if
   something goes wrong).  Debugging messages should be either wrapped
   in MPIDEBUG(...) (as in MPIDEBUG(printf( ....))) or use DBG_PRINTF and
   DBG_FPRINTF.   

4. C++ files should use a C++ suffix (e.g., cxx or cpp; cxx is used by the
   C++ binding).  C++ header
    files should set the Emacs mode to C++, as in 
    /* -*- Mode: C++;  c-basic-offset:4 ; -*- */  
   Don't forget that // is not a valid C comment.

5. strcpy etc.: The standard C routines are very dangerous, since it
   is easy for them to allow an overwrite of memory.  The versions in
   src/util/mem/safestr.c are safer than the standard strcpy etc but
   do not access the entire array (e.g., strncpy sets n characters,
   not the min of (n,length of source string+1, MPIU_Strncpy does do
   only the min).  For sprint, use MPIU_Snprintf instead; this is just
   snprintf where snprintf is available but provides a partial
   implementation (just %s, %d, and %% + regular characters) for
   systems without snprintf. BTW, in going through the code, I found
   an strncpy( a, argv[i], strlen(argv[i])+1 ), whoever wrote this
   abomination owes a round of drinks for the group :). 

6. NMPI_xxx routines should only be used when the error handler has
   switched to errors return; this is easily done with the error nesting
   calls, and these can be nested, so that is it safe to use these for
   routines that may be called from inside a routine that has set 
   a nested call.  Also, if the call is very simple and cannot have an
   error, consider inlining the effect (e.g., use comm_ptr->local_size 
   instead of NMPI_Comm_size).

7. There are always exceptions.  These can be handled either by
   telling the code checker to skip a file (appropriate only for
   external files, such as crypt.h), or by enhancing the code checker.
   For example, in working on the printf stuff, I realized that we
   needed to separate out user errors and internal errors for messages
   (I should have thought of this; Pete Bradley's been saying this).
   Of course, there are other things to check for as well.  If there
   is something you think we should be checking for (and an easy way
   to do it), please contribute it. 

8. By default, the codechecks ignore directories that are named
   "test".  This provides an easy way to both clearly separate these
   programs (we've had bug reports about the test programs because
   they were in the source directory) and avoid complaints from the
   code checker.  Running the code checker over them is still possible
   (and a good idea) with the option -checktest (to maint/codingcheck)

Other Recommendations
Or things not checked for but desired

1. Installation scripts should use the install program, not cp, to 
   install files.  There are special targets in simplemake that let
   simplemake know which files are installed so that the correct commands
   can be generated.

2. 
