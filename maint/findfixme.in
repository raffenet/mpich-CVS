#! @PERL@
# -*- Mode: perl; -*- 
#
# Look for /* FIXME ... */ and print out the file, line, and comment.
# If the global $byOwner is true, append FIXMEs to the hash Fixmes by owner name
# (owner is unknown for FIXMEs with no owner).
# 
$byOwner = 1;
# Global hash Fixmes
%Fixmes = ();
#
sub ReadFile {
    my $filename = $_[0];
    
    my $linecount = 0;
    my $fileOwner = "unknown";

    open( INFD, "<$filename" ) || die "Could not open $filename\n";

    while (<INFD>) {
	$linecount++;

	if (/\/\*\s*OWNER=(\w*)\s+\*\//) {
	    $fileOwner = $1;
	}
	if (/\/\*\s*FIXME/) {
	    # Find any optional owner:
	    my $owner = $fileOwner;;
	    if (/FIXME\s*(\(\w*\))/) {
	        $owner = $1;
            }
	    # find the end of the comment 
	    while (! /\*\//) {
		$_ .= <INFD>;
		$linecount++;
	    }
	    if ($byOwner) {
		$Fixmes{$owner} .= "$filename:$filecount:$_";
	    }
	    else {
		print "$filename:$linecount:$_";
	    }
	}
    }
    close( INFD );
}

#
# Recursively process the given dir, calling the
# routine given as the second argument with the filename as the argument
$debug = 0;
$showfiles = 0;
$depth = 1;
$curdir = ".";
sub ProcessDir {
    my $DIR = "DIR$depth"; $depth++;
    my $dir = $_[0]; $dir =~ s/\/$//;
    my $ProcessFile = $_[1];
    my $savedir = $curdir;
    $curdir =~ s/\/$//;
    $curdir = "$curdir/$dir";
    print "Processing directory $curdir\n" if ($verbose);
    opendir( $DIR, "$curdir" ) || die "Cannot open directory $curdir\n";
    my @filelist;
    while ($file = readdir( $DIR) ) {
	print "File $file\n" if ($verbose);
	$filelist[$#filelist+1] = $file;
    }
    closedir( $DIR );
    foreach $file (@filelist) {
	print "processing $file\n" if ($verbose);
	if (-d "$curdir/$file") {
	    if (! ($file =~ /^\./) && ! ($file =~ /CVS/) ) { 
		&SetCurrentDirectory( "$curdir/$file" );
		&ProcessDir( $file, $ProcessFile );
	    }
	}
	elsif ($file =~ /\.[ch]$/) {
	    print "File $file\n" if ($verbose);
	    &$ProcessFile( "$curdir/$file" );
	}
    }
    closedir( $DIR );
    $curdir = $savedir;
}
# --------------------------------------------------------------------------
# These routines ensure that the current directory is printed before any
# warning messages.  This is used to reduce the amount of noise that
# comes out of the codingcheck
# --------------------------------------------------------------------------
$currentDirectory = "";
$directoryPrinted = 0;
sub SetCurrentDirectory {
    $currentDirectory =  $_[0];
    $directoryPrinted = 0;
}
sub PrintCurrentDirectory {
    if (!$directoryPrinted) {
	$directoryPrinted = 1;
	print "Directory $currentDirectory\n";
    }
}

# ---------------------------------------------------------------------------
@files= ();
foreach $arg (@ARGV) {
    if ($arg =~ /^-showfiles/) { $showfiles = 1; }
    elsif( $arg =~ /-debug/) { $debug = 1; }
    elsif ($arg =~ /-outfile=(.*)/) {
	$outfile = $1;
    }
    elsif ($arg =~ /-noowner/) { $byOwner = 0; }
    else {
	print "Adding $arg to files\n" if $debug;
	$files[$#files+1] = $arg;
    }
}

# Process the definitions

foreach $file (@files) {
    print "$file\n" if $showfiles;
    if (-d $file) {
	if ($file =~ /\.\./ || $file =~ /^\.$/) { next; }
	&ProcessDir( $file, "ReadFile" );
    }
    else {
	&ReadFile( $file );
    }
}
if ($byOwner) {
    # Print out by owner, using Fixme hash
    print $Fixmes{"unknown"};
    foreach $key (keys(%Fixmes)) {
	if ($key eq "unknown") { next; }
	print $Fixmes{$key};
    }
}
