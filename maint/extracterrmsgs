#! /usr/bin/perl
# 
require "maint/parse.sub";

$debug = 0;
$entrycount = 0;
%defined_args = ();
$showfiles = 0;
$quiet = 0;
$build_test_pgm = 1;

# Check for special args
@files = ();
$outfile = "";
foreach $arg (@ARGV) {
    if ($arg =~ /^-showfiles/) { $showfiles = 1; }
    elsif( $arg =~ /-debug/) { $debug = 1; }
    elsif( $arg =~ /-quiet/) { $quiet = 1; }
    elsif( $arg =~ /-notest/) { $build_test_pgm = 0; }
    elsif( $arg =~ /-outfile=(.*)/) { $outfile = $1; }
    else {
	print "Adding $arg to files\n" if $debug;
	$files[$#files+1] = $arg;
    }
}

if ($outfile ne "") {
    $OUTFD = "MyOutFile";
    open( $OUTFD, ">$outfile" ) || die "Could not open $outfile\n";
}
else {
    $OUTFD = STDOUT;
}
# Setup before processing the files
if ($build_test_pgm) {
    open( TESTFD, ">test/mpi/errhan/errcode.c" ) || die "Cannot create test program\n";
    print TESTFD "#include <stdio.h>\n#include \"mpi.h\"\n";
    print TESTFD "int MPIR_Err_create_code( int, const char [], ... );\n";
    print TESTFD "void ChkMsg( int, int, const char [] );\n\n";
    print TESTFD "int main(int argc, char **argv)\n";
    print TESTFD "{\n    int err;\n    MPI_Init( 0, 0 );\n";
}

# Process the definitions
foreach $file (@files) {
    print "$file\n" if $showfiles;
    &ProcessFile( $file );
}
&CreateErrmsgsHeader( $OUTFD );
&CreateErrMsgMapping( $OUTFD );

if ($build_test_pgm) {
    print TESTFD "    return 0;\n}\n";
}    

# ==========================================================================
# Call this for each file
# This reads a file and adds does the following:
#   add the generic message to the hash generic_msgs with value i.
#   add the specific message to the array specific_msgs in the ith location
#   adds the location to the hash generic_loc{msg} as the value (: separated)
#       and the hash specific_loc{msg}.
#   The last two are used to provide better error reporting.
#
$generic_count = 0;
$filename = "";    # Make global so that other routines can echo filename
sub ProcessFile { 
    $filename = $_[0];
    open (FD, "<$filename" ) || die "Could not open $filename\n";

    while (<FD>) {
	# First, remove any comments
	$errsrc = " in $filename";
	$_ = StripComments( FD, $_ );
	# Skip the definition of the function
	if (/int\s*MPIR_Err_create_code/) { next; }
	while (/MPIR_Err_create_code\s*(\(.*$)/) {
	    ($leader, $remainder, @args ) = &GetSubArgs( FD, $1 );
	    if ($debug) {
		foreach $arg (@args) {
		    print "|$arg|\n";
		}
	    }
	    if ($build_test_pgm) {
		&AddTestCall( @args )
	    }

	    # Check the 2nd and 3rd arguments
	    $arg2 = $args[1];
	    if ($arg2 =~ /\s$/) {
		print STDERR "trailing blank on arg $arg2 in $filename!\n"; 
	    }
	    if ($#args >1) {
		$arg3 = $args[2];
		if ($arg3 =~ /^[1-9]/) {
		    print STDERR "Error: third argument to Create_code is an invalid integer $arg3 (must be 0 or a string) in $filename\n";
		}
		if ($arg3 eq $arg2) {
		    print STDERR "Error: generic and instance messages must be different in $filename (message $arg2)\n";
		}
#		if ($arg3 =~ /^\s*0\s*$/) { $arg3 = $arg2; }
	    }
	    else {
		print STDERR "Warning: third argument to Create_code missing in $filename\n";
		$arg3 = "0";
	    }
	    if ($arg2 =~ /^\"\*\*/) {
		$reverse_loc{$arg2} = $filename;
		if ($arg3 ne "0") {
		    # Check arg3 matches
		    $arg2 =~ /^\"\*\*(\S+).*\"/;
		    $testarg1 = $1;
		    $arg3 =~ /^\"\*\*(\S+).*\"/;
		    $testarg2 = $1;
		    $reverse_loc{$arg3} = $filename;
		    if ($testarg1 ne $testarg2) {
			print STDERR
                       "Possible inconsistent error msg in $filename\r\ngeneric is $arg2 and specific is $arg3\r\n";
		    }
		}
	    }
	    else {
		# NonStandard arg
		print STDERR "Warning: NonStandard arg $arg2 in $filename\n";
	    }
	    if (!defined($generic_msgs{$arg2})) {
		if ($arg3 ne "0" && $arg3 ne $arg2) {
		    print "Adding specific short msg $arg3\n" if $debug;
		    # Check that this is really a specific message
		    # (contains %<format>)
		    if (! ($arg3 =~ /\%/)) {
			print STDERR "Warning: specific message $arg3 in $filename contains no format control\n";
		    }
		    $specific_msgs[$generic_count] = $arg3;
		}
		else {
		    $specific_msgs[$generic_count] = "";
		}
		# Check that the generic message does *not* have a format
		# control
		if ($arg2 =~ /%/) {
		    print STDERR "Warning: generic message $arg2 in $filename contains a format control\n";
		    }
		$generic_msgs{$arg2} = $generic_count++;
	    }
	    $generic_loc{$arg2} .= ":$filename";
	    $specific_loc{$arg3} .= ":$filename";
	    $_ = $remainder;
	}
    }		
    close FD;
}

# From the data collected above, generate the file containing the error message
# text.
# This is a temporary routine; the exact output form will be defined later
sub CreateErrmsgsHeader {
    $FD = $_[0];
    print $FD "/* -*- Mode: C; c-basic-offset:4 ; -*- */\
/*  \
 *  (C) 2001 by Argonne National Laboratory.\
 *      See COPYRIGHT in top-level directory.\
 *\
 * This file automatically created by extracterrmsgs\
 * DO NOT EDIT\
 */\n";
    print $FD "typedef struct {\
        const char *short_name, *long_name; } msgpair;\n"
}
#
# We also need a way to create the records
# We then hash these on the first occurance (or precompute the hashes?)
#
# The error messages are output in the following form:
# typedef struct {const char short[], const long[]} namemap;
# Generic messages
# static const char[] short1 = "";
# static const char[] long1 = "";
# ...
# static const namemap[] = { {short1, long1}, {...} }
sub CreateErrMsgMapping {
    my $OUTFD = $_[0];
    #
    # Read the file with the long names
    #...
    open( FD, "<src/mpi/errhan/errnames.txt" ) || return 0;
    while (<FD>) {
	if (/^\s*\#/) { next; }
	if (/^\s*(\*\*[^:]*):(.*)$/) {
	    my $name = $1;
	    my $repl = $2;
	    $repl =~ s/\r*\n*$//g;
	    while ($repl =~ /\\\s*$/) {
		# If there is a \\ at the end, read another.  
		# Remove the \ at the end (an alternative is to turn
		# it into a \n (newline), but we may want to avoid 
		# multiline messages
		$repl =~ s/\\\s*$//;
		my $inline = <FD>;
		$inline =~ s/^\s*//;   # remove leading spaces
		$repl .= $inline;
		$repl =~ s/[\r\n]*$//g; # remove newlines
	    }
	    my $namehasformat = ($name =~ /%/);
	    my $replhasformat = ($repl =~ /%/);
	    if ($namehasformat != $replhasformat) {
		print STDERR "Warning: format control usage in $name and $repl do not agree in errnames.txt\n";
	    }
	    $longnames{"\"$name\""} = $repl;
	}
    }
    close( FD );

    # Create a mapping of MPI error classes to the specific error
    # message by index into generic_err_msgs.  This reads the file
    # baseerrnames, looks up the generic message, and maps the MPI error
    # class to the corresponding index.
    # We must do this here because we must ensure that all MPI error
    # classes have been added to the generic messages
    @mpimsgs = ();
    open (FD, "<src/mpi/errhan/baseerrnames.txt" ) || 
	die "Could not open src/mpi/errhan/baseerrnames.txt";
    while (<FD>) {
	s/#.*$//;
	($mpiname,$num,$shortmsg) = split(/\s\s*/);
	if ($shortmsg ne "") {
	    if ($shortmsg =~ /\%/) {
		print STDERR "Generic message $shortmsg in baseerrnames.txt contains a format control\n";
	    }
	    if (!defined($generic_msgs{"\"$shortmsg\""})) {
		$generic_msgs{"\"$shortmsg\""} = $generic_count;
		$generic_count ++;
		$generic_loc{"\"$shortmsg\""} = ":baseerrnames.txt";
	    }
	    # This isn't correct.  Because we sort the msgs, the
	    # matching number must be computed *after* the sort.
	    # Thus, we first store the short message; then update the
	    # number.
	    #$mpimsg[$num] = $generic_msgs{"\"$shortmsg\""};
	    $mpimsg[$num] = "\"$shortmsg\"";
	}
    }
    close (FD);

    # Now, output each short,long key
    # Do the generic, followed by the specific, messages
    # The long messages must be available for the generic message output.
    # An alternative is to separate the short from the long messages;
    # the long messages are needed for > MSG_NONE, the short for > MSG_CLASS.
    print $OUTFD "#if MPICH_ERROR_MSG_LEVEL > MPICH_ERROR_MSG_NONE\n";
    print $OUTFD "/* The names are in sorted order, allowing the use of a simple\
  linear search or bisection algorithm to find the message corresponding to\
  a particular message */\n";
    my $num = 0;
    foreach my $key (sort keys %generic_msgs) {
	$longvalue = "\"\0\"";
	if ($key =~ /^\"\*\*/) {
	    if (!defined($longnames{$key})) {
		$seenfile = $generic_loc{$key};
		print STDERR "Shortname $key has no expansion (first seen in file $seenfile)\n";
	    }
	    else {
		# Escape any naked quotes
		$longvalue = s/(?<!\\)\"/\\\"/;
		$longvalue = "\"" . $longnames{$key} . "\"";
	    }
	}
	print $OUTFD "static const char short$num\[\] = $key;\n";
	print $OUTFD "static const char long$num\[\]  = $longvalue;\n";
	# Remember the number assigned to this short string.
	$short_to_num{$key} = $num;
	$num ++;
    }
    # Generate the mapping of short to long names
    print $OUTFD "static const int generic_msgs_len = $num;\n";
    my $i = 0;
    print $OUTFD "static msgpair generic_err_msgs[] = {\n";
    for (my $i = 0; $i < $num - 1; $i ++) {
	print $OUTFD "{ short$i, long$i },\n";
    }
    if ($num > 0) {
	print $OUTFD "{ short$num, long$num }\n";
    }
    print $OUTFD "};\n";
    print $OUTFD "#endif\n";

    my $num = 0;
    # Do in exactly the same order as the generic messages
    print $OUTFD "#if MPICH_ERROR_MSG_LEVEL > MPICH_ERROR_MSG_GENERIC\n";
    foreach $key (sort keys %generic_msgs) {
	$longvalue = "\"\0\"";
	$specname = $specific_msgs[$generic_msgs{$key}];
	if ($specname =~ /^\"\*\*/) {
	    if (!defined($longnames{$specname})) {
		print STDERR "Shortname $specname has no expansion (first seen in file $reverse_loc{$specname})\n";
	    }
	    else {
		# Escape any naked quotes
		$longvalue = s/(?<!\\)\"/\\\"/;
		$longvalue = "\"" . $longnames{$specname} . "\"";
	    }
	}
	if ($specname ne "" && $specname ne "0") {
	    print $OUTFD "static const char short_spc$num\[\] = $specname;\n";
	    print $OUTFD "static const char long_spc$num\[\]  = $longvalue;\n";
	    $has_spec[$num] = 1;
	}
	else {
	    $has_spec[$num] = 0;
	}
	$num ++;
    }
    # Generate the mapping of short to long names
    my $i = 0;
    print $OUTFD "/* This array parallels the generic_err_msgs array, with
 null entries where there is no special instance-specific message */\n";
    print $OUTFD "static msgpair specific_err_msgs[] = {\n";
    for ($i = 0; $i < $num ; $i ++) {
	if ($has_spec[$i]) {
	    print $OUTFD "{ short_spc$i, long_spc$i },\n";
	}
	else {
	    print $OUTFD "{ 0, 0 },\n";
	}
    }
    print $OUTFD "};\n";
    print $OUTFD "#endif\n";

    print $OUTFD "#if MPICH_ERROR_MSG_LEVEL > MPICH_ERROR_MSG_NONE\n";
    $maxval = $#mpimsg + 1;
    print $OUTFD "#define MPIR_MAX_ERROR_CLASS_INDEX $maxval\n";
    print $OUTFD "static int class_to_index[] = {\n";
    for ($i=0; $i<=$#mpimsg; $i++) {
	print $OUTFD "$short_to_num{$mpimsg[$i]},";
	print $OUTFD "\n" if !(($i + 1) % 10);
    }
    print $OUTFD "};\n";
    print $OUTFD "#endif\n";
}
#
# Add a call to test this message for the error message.
# Handle both the generic and specific messages
#
sub AddTestCall {

    # Ensure that the class is specified.  There are a few places
    # where this is a variable
    $errclass = $_[0];
    if (! ($errclass =~ /MPI_ERR/) ) {
	$errclass = "MPI_ERR_OTHER";
    }
    # Generic message (first instance only)
    if (!defined($testmsg{$_[1]})) {
	print TESTFD "    /* $filename */\n";
	print TESTFD "    err = MPIR_Err_create_code( $errclass, @_[1], 0 );\n";
	print TESTFD "    ChkMsg( err, $errclass, $_[1] );\n";
	$testmsg{$_[1]} = $filename;
    }

    # Specific messages
    if ($_[2] ne "0") {
	print TESTFD "    {\n";
	print TESTFD "    /* $filename */\n";
	# Use types in the string to create the types with default
	# values
	my $format = $_[2];
	my $fullformat = $format;
	my $narg = 0;
	my @args = ();
	while ($format =~ /[^%]*%(.)(.*)/) {
	    my $type = $1; 
	    $format  = $2;
	    $narg ++;
	    if ($type eq "d") {
		print TESTFD "    int i$narg = $narg;\n";
		$args[$#args+1] = "i$narg";
	    }
	    elsif ($type eq "s") {
		print TESTFD "    char s$narg\[\] = \"string$narg\";\n";
		$args[$#args+1] = "s$narg";
	    }
	    else {
		print STDERR "Unrecognized format type $type for $fullformat in $filename\n";
	    }
	}   
	$actargs = $#_ - 2;
	if ($actargs != $narg) {
	    print STDERR "Error: Format $fullformat provides $narg arguments but call has $actargs in $filename\n";
	}
	print TESTFD "     err = MPIR_Err_create_code( $errclass, @_[1], @_[2]";
	foreach my $arg (@args) {
	    print TESTFD ", $arg";
	}
	print TESTFD " );\n";
	print TESTFD "    ChkMsg( err, $errclass, $_[2] );\n    }\n";
	# ToDo: pass another string to ChkMsg that contains the 
	# names of the variables, as a single string (comma separated).
	# This allows us to review the source of the values for the args.
    }
}


#
# Other todos:
# It would be good to keep track of any .N MPI_ERR_xxx names in the structured
# comment and match these against any MPI_ERR_yyy used in the code, emitting a
# warning message for MPI_ERR_yyy values used in the code but not mentioned 
# in the header.  This could even apply to routines that are not at the MPI
# layer, forcing all routines to document all MPI error classes that they might
# return (this is like requiring routines to document the exceptions that 
# they may throw).
