#! @PERL@
# -*- Mode: perl; -*-
#
# Configure and build mpich2 with some of the options
#
# Set default values
$srcdir  = "/home/gropp/projects/mpich2";
$tmpdir = "/sandbox/gropp";
# rundir is the directory in which to run the tests.
$rundir = "";
$mpich1_dir = "/home/gropp/tmp/cvstesting/mpich";
# By default, use random arguments for the tests
$use_rand_args = 1;
#
$is_xml = 0;
# Set the default compilers.  These can be overridden by setting the CC
# and FC environment variables.
$ccname = "gcc";
$fcname = "f77";
#
# Set available options.  For enable and with, the values are
# {with,enable}-name[;possiblevalues]*
@enable_array = ( 
		  'error-checking;no;runtime;all', 
		  'error-messages;all;generic;class;none',
		  'timings;none;all;runtime',
		  'mpi-macros',
		  'g;none;all;handle;mem;dbg',
		  'internat',
		  'fast',
		  'f77',
		  'cxx',
		  'romio',
		  'coverage',
		  'strict',
		  'weak_symbols;no;yes',
		  'debugger',
		  'sharedlibs',
#                 'threads;single;multiple',
);
@with_array = (
	       'logging;none;rlog;dlog',
#	       'pmi;uni',
	       'pm;forker;mpd',
);
@env_array = (
#	      'CC;gcc;cc;pgcc;ecc;xlc',
#	      'FC;f77;pgf77;efc;xlf',
#	      'CXX;gcc;CC;pgCC;ecc;xlC',
#             'CFLAGS;-g;-O',
);	      

# Also cross;sample-cross-files, but we need the files first
# Also missing are levels of thread support.

$n_enable  = $#enable_array + 1;
$n_with    = $#with_array + 1;
$n_env     = $#env_array + 1;
$show      = 0;
$debug     = 0;
$max_count = 5;
$OUTFD     = OUTFD;
#
# The following variable separate the various sections
$TestStart = "-----------------------------------------------------------\n";
$TestEnd   = "-----------------------------------------------------------\n";
$TestDateStart = "Run on ";
$TestDateEnd   = "\n";
$TestHostStart = "Run on host ";
$TestHostEnd   = "\n";
$ConfigStart = " -- Begin Configure Step -- \n";
$ConfigEnd   = " -- End   Configure Step -- \n";
$MakeStart   = " -- Begin Make Step --\n";
$MakeEnd     = " -- End   Make Step --\n";
$MakeInstStart = " -- Begin Make Install Step --\n";
$MakeInstEnd   = " -- End   Make Install Step --\n";
$RunTestStart  = " -- Begin Run Test Step --\n";
$RunTestEnd    = " -- End   Run Test Step --\n";
$SumStart = "";
$SumEnd   = "";
$SumConfigStart = "Config status = ";
$SumConfigEnd   = "\n";
$SumMakeStart = "Make status = ";
$SumMakeEnd   = "\n";
$SumInstStart = "Install status = ";
$SumInstEnd   = "\n";
$SumTestRunStart = "Test status = ";
$SumTestRunEnd   = "\n";

# Read the arguments
foreach $_ (@ARGV) {
    if (/-enable-n=(\d*)/) {
	$n_enable = $1;
    }
    elsif (/-with-n=(\d*)/) {
	$n_with = $1;
    }
    elsif (/-show/) {
	$show = 1;
    }
    elsif (/-debug/) {
	$debug = 1;
    }
    elsif (/-envopt=(.*)/) {
	# Add a list of possible env values
	$env_array[$#env_array+1] = $1;
	$n_env    = $#env_array + 1;
    }
    elsif (/-srcdir=(.*)/) {
	$srcdir  = $1;
    }
    elsif (/-instdir=(.*)/) {
	$instdir = $1;
    }
    elsif (/-rundir=(.*)/) {
	$rundir = $1;
    }
    elsif (/-maxcount=(.*)/) {
	# max count.  Set to -1 for infinity
	$max_count = $1;
    }
    elsif (/-maxtime=(.*)/) {
	# max time in seconds
	set_time_left( $1 );
    }
    elsif (/-tests=(.*)/) {
	$tests = ";" . $1 . ";";
    }
    elsif (/-outfile=(.*)/) {
	$outfile = $1;
    }
    elsif (/-tmpdir=(.*)/) {
	$tmpdir = $1;
    }
    elsif (/-xml/) {
	&XMLStyle;
	$is_xml = 1;
    }
    elsif (/-norand/) {
	$use_rand_args = 0;
    }
    elsif (/-enable=(.*)/) {
	$use_rand_args = 0;
	$enable_args .= "$1 ";
    }
    elsif (/-with=(.*)/) {
	$use_rand_args = 0;
	$with_args .= "$1 ";
    }
    elsif (/-env=(.*)/) {
	$use_rand_args = 0;
	$env_args .= "--env-$1 ";
    }
    elsif (/-configarg=(.*)/) {
	# Use this to add a special arg (such as -host) to the 
	# configure call
	$config_args .= "$1 ";
    }
    elsif (/-help/) {
	print STDERR "\
checkbuilds [ -enable-n=d ] [ -with-n=d ] [ -show ] [-envopt=name;value;... ]
            [-srcdir=SRCDIR] [-instdir=INSTALLDIR] 
            [-maxcount=MAXCNT] [-maxtime=MAXTIME] 
            [-norand ] [-enable=enable-args] [-with=with-args]
            [-tmpdir=dir]
        -enable-n=d sets the number of --enable options to try
        -with=n=d set the number of --with options to try
        -envopt=name;value;... adds an environment variable with possible
                 values (quote the text so that the semicolons do not
                 cause trouble)

        -maxcount sets the number of builds to try
        -maxtime sets the maximum length of time to run
        Example:
        checkbuilds -envopt=\"CC;gcc;pgcc;ecc\"\n";
        exit(0);
    }

    else {
	print STDERR "Unrecognized argument $_\n";
	exit(1);
    }
}

#
# Set directories that have not been chosen.
if ($instdir eq "") {
    $instdir = "$tmpdir/cb/mpi2-inst";
}
if ($mpich_test_dir eq "") {
    $mpich_test_dir = "$tmpdir/cb/mpitest";
}
if ($intel_test_dir eq "") {
    $intel_test_dir = "$tmpdir/cb/MPITEST";
}
if ($mpicxx_test_dir eq "") {
    $mpicxx_test_dir = "$tmpdir/cv/mpicxxtest";
}

# ---------------------------------------------------------------------------

#
# ---------------------------------------------------------------------------
# Run one instance of the configuration
sub RunTest {
    my $makepgm;
    # 
    # Create the with and enable options
    @enable_chosen = ();
    @with_chosen = ();
    #$enable_args = "--enable-strict";  # Only if compiler is gcc
    # Chosen *without* replacement.  If an option is chosen twice, 
    # then there will be fewer options
    if ($use_rand_args) {
	$enable_args = &RandArgs( $n_enable, "enable_array", "enable", "disable" );
	$with_args   = &RandArgs ( $n_with, "with_array", "with", "without" );
	
	# To set the environment, use the same code to set things up,
	# then process the env array to set the environment
	$env_args    = &RandArgs( $n_env, "env_array", "env" );
    }
    $envset = "";
    %saveENV = %ENV;
    foreach $_ (split(/ /,$env_args)) {
	if (/--env-(.*)=(.*)/) {
	    $name  = $1;
	    $value = $2;
	    print "Env $name = $value\n" if $debug;
	    # Since most of these so far are programs, we should check to 
	    # see if they're available.  Instead, we'll make the user
	    # specify the valid values (see -envopt above)
	    $ENV{$name} = $value;
	    $envset .= "$name = $value; ";
	}
    }

    # Get the version of make to use
    if (defined($ENV{"MAKE"})) {
	$makepgm = $ENV{"MAKE"};
    }
    else {
	$makepgm = "make";
    }

    # Check configure location
    if ( ! (-x "$srcdir/configure") && (-x "./configure") ) {
	$srcdir = ".";
    }
    $config_status  = "none";
    $make_status    = "none";
    $install_status = "none";
    $test_status    = "none";
    if ($show) {
	print "Configure: $enable_args $with_args $config_args\n";
	if ($envset ne "") {
	    print "Environment = $envset\n";
	}
    }
    else {
#	$enable_args .= " --enable-echo";
	print $OUTFD $TestStart;
	my $host = `uname -n`;
	print $OUTFD "$TestHostStart$host$TestHostEnd";
	my $date = `date "+%Y-%m-%d-%H-%M"`;
	print $OUTFD "$TestDateStart$date$TestDateEnd";
	unlink "Makefile";
	print $OUTFD $ConfigStart;
	@config = split( /\s+/, "$srcdir/configure --prefix=$instdir $enable_args $with_args $config_args" );
	print $OUTFD "Configure: " . join(" ", @config) . "\n";
	if ($envset ne "") {
	    print $OUTFD "Environment = $envset\n";
	}
	$rc = &RunProgram( @config );
	$config_status = $rc;
	if (! -s "Makefile" && $rc == 0) {
	    $config_status = "No Makefile";
	    $rc = 1;
	}
	print $OUTFD $ConfigEnd;
	# print "rc = $rc\n";
	if ($rc == 0) {
	    print $OUTFD $MakeStart;
	    # Remove mpd just in case (see below)
	    unlink "bin/mpd";
	    $rc = &RunProgram( $makepgm );
	    print $OUTFD $MakeEnd;
	    $make_status = $rc;
	    if ($rc == 0) {
		print $OUTFD $MakeInstStart;
		# Clean the install directory
		# ????
		$install_status = &RunProgram( "$makepgm install" );
		print $OUTFD $MakeInstEnd;
		if ($install_status == 0) {
		    # Get mpd status from the with args ...
		    if (-x "bin/mpd") {
			$built_for_mpd = 1;
		    }
		    $test_status = &RunTestSuites;
		}
	    }
	}
	print $OUTFD $TestEnd;
    }
    %ENV = %saveENV;

    print $OUTFD $SumStart;
    print $OUTFD $SumConfigStart;
    print $OUTFD $config_status;
    print $OUTFD $SumConfigEnd;
    print $OUTFD $SumMakeStart;
    print $OUTFD $make_status;
    print $OUTFD $SumMakeEnd;
    print $OUTFD $SumInstStart;
    print $OUTFD $install_status;
    print $OUTFD $SumInstEnd;
    print $OUTFD $SumTestRunStart;
    print $OUTFD $test_status;
    print $OUTFD $SumTestRunEnd;
    print $OUTFD $SumEnd;
}

# ---------------------------------------------------------------------------
# Chosen *without* replacement.  If an option is chosen twice, 
# then there will be fewer options
sub RandArgs { 
    my ($n_choice, $array_name, $optname, $negoptname ) = @_;
    my @chosen = ( );
    my $args = "";
    my $array_len = $#$array_name;
    my $idx;

    print "select $n_choice\n" if $debug;
    for (my $i=0; $i<$n_choice; $i++) {
	$idx = int( rand (1 + $array_len) );
	print "Found $idx\n" if $debug;
	if ($chosen[$idx]) { next; }
	$chosen[$idx] = 1;
	@args = split( /;/, $$array_name[$idx] );
	print "Trying $$array_name[$idx]\n" if $debug;
	$name = $args[0];
	if ($#args == 0) {
	    # Only the name is provided.  Choose one of three
	    # choices:
	    #    No option (skip this one)
	    #    just --$optname-$name
	    #    just --$negoptname-$name (if non-null)
	    $idx = int ( rand ( 3 ) );
	    if ($idx == 0) {
		$args .= " --$optname-$name";
	    }
	    elsif ($idx == 1 && $negoptname ne "") {
		$args .= " --$negoptname-$name";
	    }
	    else {
		# skip
		;
	    }
	}
	else {
	    $idx = 1 + int( rand $#args );
	    $value = $args[$idx];
	    if ($value ne "") {
		$args .=  " --$optname-$name=$value";
	    }
	    else {
		$args .= " --$optname-$name";
	    }
	}
    }
    return $args;
}
    
# ---------------------------------------------------------------------------
# Timer support.  Time_left returns 1 if time remains, 0 otherwise
$final_time = -1;
sub set_time_left {
    my $delta_time = $_[0];
    $final_time = time + $delta_time;
}
sub time_left {
    if ($final_time eq "" || $final_time == -1) {     return 1; }
    if (time > $final_time) { return 0; }
    else                    { return 1; }
}

# ---------------------------------------------------------------------------
# cb for check build
#
# Eventually, we'll need
#   bootstep
#   compiler names
#   unbootstep
# for each test.
#
sub RunTestSuites {
    my $run_status = 0;
    foreach my $testname (split(';',$tests)) {
	if ($testname eq "") { next; }
	print $OUTFD $RunTestStart;
	if ($is_xml) { 
	    print $OUTFD "<TESTNAME>$testname</TESTNAME>\n";
	    }
	else {
	    print $OUTFD "Running test $testname...\n";
	}
	if ($testname eq "mpich") {
	    $cwd = `pwd`;
	    my @config;
	    # Make sure that the tests run past a failure to build an
	    # executable.  Without this, the summary doesn't include
	    # any tests in the same directory that completed.
	    $ENV{"MPITEST_CONTINUE"} = "always";

	    chdir $mpich_test_dir || die "Cannot change to $mpich_test_dir\n";
	    $config[0] = "$mpich1_dir/examples/test/configure";
	    $config[1] = "--prefix=$instdir";
	    $config[2] = "-mpilibname=mpich";
	    # This isn't right, since these need to use the compilation 
	    # scripts.  We'll approximate this by trying to use the
	    # compilation scripts if they're found
	    if (defined($ENV{"CC"})) {
		$ccname = $ENV{"CC"};
	    }
	    if (defined($ENV{"FC"})) {
	        $fcname = $ENV{"FC"};
	    }
	    # Note that there are no quotes in the following because
	    # they are not needed (no shell evaluation here)
	    if (-x "$instdir/bin/mpicc" ) {
		$config[3] = "-cc=$instdir/bin/mpicc";
	    }
	    else {
		$config[3] = "-cc=$ccname -I$instdir/include -L$instdir/lib";
	    }
	    if (-x "$instdir/bin/mpif77" ) {
		$config[4] = "-fc=$instdir/bin/mpif77";
	    }
	    else {
		$config[4] = "-fc=$fcname -I$instdir/include -L$instdir/lib";
	    }
	    if (defined($ENV{"MAKE"})) {
		$makepgm = $ENV{"MAKE"};
		$config[5] = "-make=$makepgm";
	    }
	    else {
		$makepgm = "make";
	    }
	    #$config[5] = "--enable-echo";
	    %saveENV = %ENV;
	    $ENV{MPIRUN} = "$instdir/bin/mpiexec";
	    # This timeout needs to be made uniform for all mpiruns
	    if ($built_for_mpd) {
		$ENV{MPIEXEC_TIMEOUT} = "60";
	    }
	    else {
		$ENV{MPIEXEC_TIMEOUT} = "1";
	    }
	    $rc = &RunProgram( @config );
	    if ($rc == 0) {
		# HACK for mpd for now.
		if ($built_for_mpd) {
		    &RunMPD;
		}
		$rc = &RunProgram( "$makepgm testing" );
		$test_status = $rc;
		if ($run_status == 0 && $rc != 0) { $run_status = $rc; }
		if ($built_for_mpd) {
		    `$instdir/bin/mpdallexit`;
		    kill 2, $pid;
		    kill 3, $pid;
		    kill 9, $pid;
		    waitpid $pid,0;
		}
	    }
	    else {
		$run_status = $rc;
		print $OUTFD "Configure step for test failed\n";
		print $OUTFD "Could not execute " . join(" ", @config) . "\n";
		print $OUTFD "Environment was\n";
		foreach $key (keys(%ENV)) {
		    print $OUTFD "$key = $ENV{$key}\n";
		}
	    }
	    %ENV = %saveENV;
	    chdir $cwd;
	}
	elsif ($testname eq "intel") {
	    ;
	}
	elsif ($testname eq "mpicxx") {
	    ;
	}
	else {
	    print $OUTFD "Unrecognized test $testname\n";
	}
	print $OUTFD $RunTestEnd;
    }
    return $run_status;
}
# ---------------------------------------------------------------------------
# RunProgram LIST
sub RunProgram {
    # perl does not correctly handle "2>&1 >>foo" redirection in system
    # correctly (some stderr escapes to the prior stderr).  This
    # code attempts to do the correct thing.
    # By reopening stdout and stderr, we can ensure that all of the 
    # output goes to the specified files.  Unfortunately, we can't
    # force perl to correctly flush files without open/close
    #
    # We now use a different approach that uses a open that creates a 
    # fork and associates file handle (CFD for Child FD).
    @args = @_;
    $pid = open(CFD,"-|");
    if ($pid == 0) {
        open STDIN, '/dev/null';
	# Do we want to allow an output filter, e.g., to convert the 
	# output into well-formed XML?
        open STDERR, ">>&STDOUT";
        exec @args;
    }
    else {
	# Read from the child
	while (<CFD>) {
	    if ($is_xml) {
		# xml-ify the line by escaping the special characters
		s/</\*AMP\*lt;/g;
		s/>/\*AMP\*gt;/g;
		s/&/\*AMP\*amp;/g;
		s/\*AMP\*/&/g;
	    }
	    print $OUTFD $_;
	}
	# Closing a pipe implicitly waits for the command on the other
	# end to complete, and puts the exit status into $?
	close CFD;
	# end of read from the child
	# Note that this status is usually shifted right by 8, so
	# we check for that
        $rc = $?;
	if ($rc > 255) { $rc = $rc >> 8; }
    }
    return $rc;
}
# ---------------------------------------------------------------------------
sub RunMPD {
    # We need to background the mpd.
    # If there is already an mpd running (for us), we want to stop it
    $mpdlocalsock = "/tmp/mpd2.console_". $ENV{"LOGNAME"};
    if (-S $mpdlocalsock) {
	system "$instdir/bin/mpdallexit";
    }
    $rc = $? >> 8;
    # It is ok if allexit fails; all that means is that there was no
    # mpd to stop.
#    if ($rc != 0) {
#	print $OUTFD "Error running $instdir/bin/mpdallexit\n";
#    }
    system "$instdir/bin/mpd -d";
    $rc = $? >> 8;
    if ($rc != 0) {
	print $OUTFD "Error running $instdir/bin/mpd -d\n";
    }
    else {
	print $OUTFD "Started mpd in demon mode\n";
    }
    sleep 1;
    return;

#      # Run the mpd in the background.  Eventually, decide what to 
#      # do with stdout and stderr. FIXME
#      $pid = fork();
#      if ($pid == 0) {
#  	# Child runs this
#  	open STDERR, ">>&STDOUT";
#  	open STDIN, '/dev/null';
#  	exec split(/\s+/, "$instdir/bin/mpd -d");
#  	die "Failed to run mpd";
#      }
#      else {
#  	# Wait a little for the mpd to start.
#  	sleep 1;
#      }
}
#
# Change output style
sub XMLStyle {
    $TestStart     = "<BUILDTEST>\n";
    $TestEnd       = "</BUILDTEST>\n";
    $TestDateStart = "<DATE>\n";
    $TestDateEnd   = "</DATE>\n";
    $TestHostStart = "<HOST>\n";
    $TestHostEnd   = "</HOST>\n";
    $ConfigStart   = "<CONFIG>\n";
    $ConfigEnd     = "</CONFIG>\n";
    $MakeStart     = "<MAKE>\n";
    $MakeEnd       = "</MAKE>\n";
    $MakeInstStart = "<MAKEINST>\n";
    $MakeInstEnd   = "</MAKEINST>\n";
    $RunTestStart  = "<RUNTEST>\n";
    $RunTestEnd    = "</RUNTEST>\n";
    $SumStart      = "<SUMMARY>\n";
    $SumEnd        = "</SUMMARY>\n";
    $SumConfigStart = "<STATUS NAME=\"configure\">";
    $SumConfigEnd   = "</STATUS>\n";
    $SumMakeStart  = "<STATUS NAME=\"make\">";
    $SumMakeEnd    = "</STATUS>\n";
    $SumInstStart  = "<STATUS NAME=\"install\">";
    $SumInstEnd    = "</STATUS>\n";
    $SumTestRunStart = "<STATUS NAME=\"test\">";
    $SumTestRunEnd   = "</STATUS>\n";
}
# ---------------------------------------------------------------------------
#
# Other options
# --enable-threads={single, multiple}
# ---------------------------------------------------------------------------
# Here's the real code to execute
# ---------------------------------------------------------------------------

if ($rundir ne "") { 
    chdir $rundir || die "could not change directory to $rundir\n";
}

# Select the output file
if ($outfile ne "") {
    if (! ($outfile =~ /^\//) ) {
	# Ensure that we have an absolute directory for the output file
	my $curdir = `pwd`;
	chop $curdir;
	$outfile = "$curdir/$outfile";
    }
    open( $OUTFD, ">$outfile" ) || die "Could not open $outfile for writing\n";
    # Setting autoflush is not enough to ensure that output is 
    # correctly ordered when child processes also write to the file.
    # All of the shells get this right but unfortunately perl does not.
    #autoflush $OUTFD 1;
    if ($is_xml) {
	print $OUTFD "<?xml version='1.0' ?>\n";
	print $OUTFD "<?xml-stylesheet href=\"build.xsl\" type=\"text/xsl\" ?>\n";
	print $OUTFD "<MPICH2BUILD>\n";
    }
}
else {
    $OUTFD = STDOUT;
}

# ---------------------------------------------------------------------------
#
# There are several ways to run the tests.  They are
#   For a fixed number of times
#   For a fixed length of time
for ($test_count = 0; 
     ($max_count < 0 || $test_count < $max_count) && &time_left;
     $test_count++) {
    if ($is_xml) {
    }
    else {
	print $OUTFD "\nRunning test $test_count\n\n";
    }
    &RunTest;
}
if ($is_xml) {
    print $OUTFD "</MPICH2BUILD>\n";
}
close $OUTFD;
