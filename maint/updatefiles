#! /bin/sh
#
# Update all of the derived files
# For best performance, execute this in the top-level directory.
# There are some experimental features to allow it to be executed in
# subdirectories
#
# Eventually, we want to allow this script to be executed anywhere in the
# mpich tree.  This is not yet implemented.
at_top=no
if [ -d maint -a -s maint/simplemake.in ] ; then
    at_top=yes
fi
#
# Default choices
do_codingcheck=yes
do_geterrmsgs=yes
#
# Extract the arguments intended for updatefiles.  Any others are
# given to simplemake.  
temp_args=""
for arg in "$@" ; do
    case $arg in 
    -with-codecheck|--with-codecheck)
    do_codingcheck=yes
    ;;
    -without-codecheck|--without-codecheck)
    do_codingcheck=no
    ;;
    -help|--help|-usage|--usage)
    cat <<EOF
    updatefiles [ --with-codecheck | --without-codecheck ] 
                [ args for simplemake ] 
    Update the files in the MPICH2 build tree.  This file builds the 
    configure files, creates the Makefile.in files (using the simplemake
    program), extracts the error messages, and performs basic coding checks.
    Coding checks may be suppressed with --without-codecheck .
EOF
    exit
    ;;
    *)
    temp_args="$temp_args $arg"
    esac
done
# Reset the arguments.  Note that this doesn't handle arguments that contain
# blanks.  I hope that we don't need those.
set -- $temp_args
#
# Get the Autoconf macro files
if [ $at_top = "yes" -a ! -d confdb ] ; then
    # setup to allow CVSROOT instead of an absolute directory path
    if [ -n "$CVSROOT" -a -d "$CVSROOT/fpmpi" ] ; then
        cvs -q checkout confdb
    elif [ -d /home/gropp/cvsMaster_z ] ; then 
        cvs -q -d /home/gropp/cvsMaster_z checkout confdb
    else
        echo "Checkout confdb from /home/gropp/cvsMaster_z and rerun"
	exit 1
    fi
fi
#
if [ $at_top = "no" ] ; then
    echo "Must execute at top level directory for now"
    exit 1
fi
#
# Capture the error messages
if [ -x maint/extracterrmsgs -a $do_geterrmsgs = "yes" ] ; then
    echo "Extracting the error messages..."
    maint/extracterrmsgs src/mpi/*/*.c src/util/*/*.c > .tmp 2>.err
    # (error here is ok)
    update_errdefs=yes
    if [ -s .err ] ; then 
       cat .err
       rm -f .err2
       grep -v "Warning:" .err > .err2
       if [ -s .err2 ] ; then
           echo "Because of errors in extracting error messages, the file"
           echo "src/mpi/errhan/defmsg.h was not updated."
           update_errdefs=no
       fi
       rm -f .err .err2
    fi
    if [ -s .tmp -a "$update_errdefs" = "yes" ] ; then
        mv .tmp src/mpi/errhan/defmsg.h
    fi
fi
# Build simplemake if necessary
made_simplemake=no
if [ ! -x maint/configure ] ; then
    (cd maint && autoconf )
fi
# The following relies on the Unix find command
if find -name 'maint/configure.in' -newer 'maint/configure' ; then
    (cd maint && autoconf)
fi
if [ ! -x maint/simplemake ] ; then
    (cd maint && ./configure )
    made_simplemake=yes
fi
# The following relies on the Unix find command
if find -name 'maint/simplemake.in' -newer 'maint/simplemake' ; then
    (cd maint && ./configure)
    made_simplemake=yes
fi
#
if [ ! -x maint/simplemake ] ; then
    echo "Could not create simplemake"
    echo "You can copy simplemake.in to simplemake, replacing @PERL@ with the"
    echo "path to Perl (version5).  Make sure the resulting file has"
    echo "execute permissions set."
    exit 1
fi
#
if [ $made_simplemake != "no" ] ; then
    # Check that only the first line was changed:
    rm -f .t1 .t2
    sed -e 1d maint/simplemake.in > .t1
    sed -e 1d maint/simplemake > .t2
    if diff .t1 .t2 >/dev/null 2>&1 ; then
        :
    else
        echo "Something is wrong with simplemake; configure may have"
        echo "replaced variables that it should not have."
        diff .t1 .t2
        exit 1
    fi
    rm -f .t1 .t2
fi
#
# Create the Makefile.in files
# Make sure that these files exist so that the gcc dependency creation
# can work
rm_prepost=no
if [ ! -s src/include/mpidpre.h ] ; then
    rm_prepost=yes
fi
otherargs="$@"
# If there is no mpi.h file (and other files, but testing on mpi.h should
# be enough), don't generate the dependency information in the Makefiles
# Currently, the dependency generation relies on using gcc, so we may 
# want to test on that as well.
if [ ! -s src/include/mpi.h ] ; then 
    otherargs="$otherargs -nodepend"
else
    # The next two files may be needed to build the dependency lists
    touch src/include/mpidpre.h src/include/mpidpost.h
fi
maint/simplemake -common=maint/makedefs \
    -autoconf="-l ROOTDIR/confdb" \
    -libdir='${MPILIBNAME}'=ROOTDIR/lib $otherargs \
    Makefile.sm
#
# Create the configure files and run autoheader
# Eventually, make this a test for find available.  Perhaps
# find . -name configure.in > /dev/null 2>&1
# The problem is that even though cygnus has find, the DOS find
# is identified first.  We probably need a test for this case
find . -name 'configure.in' >/dev/null 2>&1
if [ $? = 0 ] ; then has_unix_find=yes ; else has_unix_find=no ; fi
# if [ $? = 0 ] ; then .. code with find
if [ "$has_unix_find" = "yes" ] ; then
    for dir in `find . -name 'configure.in' -print` ; do
        dir=`dirname $dir`
	if [ -s $dir/Makefile.in ] ; then 
            echo "Found $dir/configure.in"
            (cd $dir ; make -f Makefile.in configure)
        fi
    done
else
    echo "You need to install find (in findutils)"
    exit 1
fi
if [ $rm_prepost = yes ] ; then
    rm -f src/include/mpidpre.h src/include/mpidpost.h
fi
#
if [ -x maint/codingcheck -a $do_codingcheck = "yes" ] ; then
    echo "Running coding check"
    echo "checking mpi code"
    maint/codingcheck src/mpi/*/*.c src/include/*.h src/util/*/*.c
    echo "checking mm device code"
    maint/codingcheck src/mpid/mm/src/*/*.c src/mpid/mm/include/*.h
    echo "checking ch3 device code"
    maint/codingcheck src/mpid/ch3/channels/*/src/*.c src/mpid/ch3/src/*.c
    echo "checking pmi code"
    maint/codingcheck src/pmi/impls/*/*.c
fi
