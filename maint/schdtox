#! /usr/bin/perl
# 
# Convert the schedule file to a spreadsheet
# Microsoft Project can read in files with the form
#ID\tUnique_ID\tTask_Name\tDuration\tType\tOutline_Level\tBaseline_Duration\tPredecessors\tStart_Date\tFinish_Date\tEarly_Start\tEarly_Finish\tLate_Start\tLate_Finish\tFree_Slack\tTotal_Slack\tLeveling_Delay\tPercent_Complete\tActual_Start\tActual_Finish\tBaseline_Start\tBaseline_Finish\tConstraint_Type\tConstraint_Date\tStop\tResume\tCreated
# We might get away with a subset of these

# and all fields tab separated.  Powerpoint appears to ignore durations
# and takes only dates.  This is called the "Task export map"

$do_html = 0;
foreach $_ (@ARGV) {
    if (/-html/) { $do_html = 1; shift; }
    else {
	print STDERR "Unexpected option $_\n";
	exit 1;
    }
}
#
# Skip header
while (<>) {
    if (/-------------------------/) { last; }
}

#
# Phase 1:  Read the file and assign id's to each function.  We need the
# Ids to compute the dependencies.
# Store the information by routine:
#   nametoid{routine} = id
#   nametotime{routine} = avg
#   nametodepend{routine} = dependstring
# This phase does no output
%nametoid = ();
%nametotime = ();
%nametodepend = ();
%nametoowner = ();
@idtoname = ();
$id = 1;
while (<>) {
    s/[\r\n]*$//;
    if (/^\s*BEGIN\s*(\w*)/) {
	$prefix = "$1:";
    }
    elsif (/^\s*END\s*(\w*)/) {
	if ($prefix != "$1:") { 
	    print STDERR "Warning: Found END $1 while processing $prefix\n";
	}
	$prefix = ""
    }
    elsif (/^.*,.*,.*,.*,.*,.*/) { 
	($routine,$min,$max,$avg,$priority,$name,$depend,$actual,$finished) = 
	    split(/,/);
	# Validate data (check for typos)
	if ($min ne "" && $min =~ /([\.0-9]*)/ && $1 ne $min) {
	    print STDERR "$routine: min value ($min) not valid\n";
	}
	if ($max ne "" && $max =~ /([\.0-9]*)/ && $1 ne $max) {
	    print STDERR "$routine: max value ($max) not valid\n";
	}
	if ($avg ne "" && $avg =~ /([\.0-9]*)/ && $1 ne $avg) {
	    print STDERR "$routine: avg value ($avg) not valid\n";
	}
	if ($priority ne "" && $priority =~ /([\.0-9]*)/ && $1 ne $priority) {
	    print STDERR "$routine: priority value ($priority) not valid\n";
	}
	#print "$routine:$min:$max:$avg:$priority:$name:$depend:$actual\n";
	# Add any prefix to the routine
	$routine = "$prefix$routine";
	#print "$routine\t$min\t$max\t$avg\t$priority\t$name\t$depend\n";
	# eventually convert depend into id's for each routine.
	$nametoid{$routine} = $id;
	if ($actual eq "") { 
	    if ($avg eq "") { $avg = 1; }
	    $nametotime{$routine} = $avg;
	}
	else {
	    if ($actual eq "done") { $actual = 1; }
	    $nametotime{$routine} = $actual;
	    $nametofinished{$routine} = $finished;
	}	    
	$nametodepend{$routine} = $depend;
	$nametoowner{$routine} = $name;
	$idtoname[$id] = $routine;
	$id ++;
    }
    elsif (/^([^,]*),/) {	
	#print "$1\n";
	#print "$id\t$id\t$1\t\r\n";
	$routine = $1;
	# Add any prefix to the routine
	$routine = "$prefix$routine";
        $nametotime{$routine} = 1;
	$nametoid{$routine} = $id;
	$idtoname[$id] = $routine;
	$id ++;
    }
}

sub convert_depend {
    $depend = $_[0];
    $dependlist= "";
    # Look in depend for strings
    @names = split(/\s\s*/,$depend);
    foreach $name (@names) {
	if (defined($nametoid{$name})) {
	    $dependlist .= "$nametoid{$name},";
	}
    }
    chop $dependlist;
    return $dependlist;
}

sub Earlier {
    $date1 = $_[0];
    $date2 = $_[1];
    # Return 1 if $date1 is before $date2
    ($month1,$day1,$year1) = split(/\//,$date1);
    ($month2,$day2,$year2) = split(/\//,$date2);
    if ($year1 < $year2) { return 1; }
    if ($year1 > $year2) { return 0; }
    if ($month1 < $month2) { return 1; }
    if ($month1 > $month2) { return 0; }
    if ($day1 < $day2) { return 1; }
    return 0;
}

$firstdate = "3/2/02";

sub PrintAsSpreadsheet {
print "ID\tUnique_ID\tTask_name\tDuration\tPredecessors\tResource_Names\tActual_Finish\r\n";
for ($i = 1; $i <$id; $i++) {
    $routine = $idtoname[$i];
    $avg     = $nametotime{$routine};
    $depend  = $nametodepend{$routine};
    $dependlist = convert_depend( $depend );
    $owner   = $nametoowner{$routine};
    $finished = $nametofinished{$routine};
    # For Microsoft project, we set the earliest date to be near the 
    # beginning of the time that we starting keeping the schedule.
    if ($finished ne "" && Earlier( $finished, $firstdate )) {
	$finished = $firstdate;
    }
    $nl = "\r\n";
    $nl = "\n";
    print "$i\t$i\t$routine\t$avg\t\"$dependlist\"\t\"$owner\"\t\"$finished\"$nl";
}
}

sub PrintAsHtml {
    $done_count = 0;
    $tot_count = 0;
    print "<TABLE>\n";
    foreach $key (sort(keys(%nametotime))) {
	if ($key =~ /^MPI_/) { 
	    $tot_count ++;
	    $routine = $key;
	    $avg     = $nametotime{$routine};
	    $depend  = $nametodepend{$routine};
	    $dependlist = convert_depend( $depend );
	    $owner   = $nametoowner{$routine};
	    $finished = $nametofinished{$routine};
	    $color = "FF0000";
	    if ($finished ne "") { 
		$done_count++;
		$finished = "done";
	        $color = "00FF00";}
	    print "<TR><TD><FONT COLOR=\"$color\">$routine</FONT><TD>$finished<TD>$owner</TR>\n";
	}
    }
    print "</TABLE>\n";
    print "<TABLE><TR><TH>Routines Finished<TH>Routines Left</TR>\n";
    $left_count = $tot_count - $done_count;
    print "<TR><TD>$done_count<TD>$left_count</TR></TABLE>\n";
}

if ($do_html) {
    &PrintAsHtml;
}
else {
    &PrintAsSpreadsheet;
}
