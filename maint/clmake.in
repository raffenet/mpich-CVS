#! @PERL@
# -*- Mode: perl; -*-
#
$debug = 0;
# Define the known commands, along with known make noise (results of
# echo)
@commands = ( "pgcc", "gcc", "icc", "rm", "mv", "ar", "ranlib", "perl", "for", 
	      "if", "make", "[A-Za-z0-9_\/-]*\/mpicc",
	      "cleaning", "/bin/rm", "sleep", "g77", "f77", "f90", "pgCC",
	      "pgf77", "pgf90", "CC", "g\\+\\+", "c\\+\\+",
	      "[A-Za-z0-9_\/-]*\/icc",
	      "/usr/bin/ar", "mkdir",
	      "mpicc", "mpicxx",
	      "compiling ROMIO in", 
	      "Make completed",
	      "\\(cd .tmp", 
	      "building profiling interface in directory",
	      "/usr/bin/install",
	      "Copying Upshot",
	      "Making upshot", "\s*\$", );
# Read lines.  Categorize lines as commands and output.  This
# script suppresses commands that generate no extra output.
# The approach is to read a line and then read the next line.
# While the line is a command and the next line is not, output the
# line.
#
# We use eof() (see man perlfun) so that we can accept filenames on the
# commandline.
$cmdline = "";
while (<>) {
    if (eof()) { next; }
    if ($cmdline eq "") {
	# Get the next command line
	print "Read line cmdline \n" if $debug;
	$cmdline = <>;
	# Get any continuation lines
	while ($cmdline =~ /\\$/) {
	    print "Read continuation line ... \n" if $debug;
	    $cmdline .= <>;
	}
    }
    if ($nextline eq "") {
	print "Read line ... \n" if $debug;
	$nextline = <>;
	while ($nextline =~ /\\$/) {
	    print "Read line continuation ... \n" if $debug;
	    $nextline .= <>;
	}
    }
    
    # Now, is $nextline a command or not?
    $is_command = 0;
    foreach $cmdname (@commands) {
	if ($nextline =~ /^\s*$cmdname/) {
	    $is_command = 1;
	    last;
	}
    }
    # If it isn't, we assume that it is an error message for the
    # preceding command.  We'll then keep reading lines until
    # we find the next command.
    if (!$is_command) {
	# Simplify the command line before printing
	$cmdline =~ s/-I[^\s]*\s+//g;
	$cmdline =~ s/-ansi//g;
	$cmdline =~ s/-W[^\s]*\s+//g;
	$cmdline =~ s/-DHAVE_CONFIG_H//g;
	$cmdline =~ s/-DGCC_WALL//g;
	print $cmdline;
	
	# Now, keep looking for a cmdline
	while (!$is_command) {
	    print $nextline;
	    print "Read line ... \n" if $debug;
	    $nextline = <>;
	    while ($nextline =~ /\\$/) {
		print "Read line continuation ... \n" if $debug;
		$nextline .= <>;
	    }
	    if ($nextline eq "" || eof()) { 
		$is_command = 1;
	    }
	    foreach $cmdname (@commands) {
		if ($nextline =~ /^\s*$cmdname/) {
		    $is_command = 1;
		    last;
		}
	    }
	}
	# Add a newline to separate the output
	print "\n";
    }
    $cmdline = $nextline;
    $nextline = "";
}

