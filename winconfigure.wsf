<package>
<job id="winconfigure">
    <runtime>
        <description>This script generates files for building MPICH2</description>
        <unnamed
            name = "--force"
            helpstring = "Force the creation of new files, overwriting the old"
            required = "false"
        />
        <unnamed
            name = "--force=no"
            helpstring = "Only create files that do not already exist"
            required = "false"
        />
        <unnamed
            name = "--win64"
            helpstring = "Generate sizes for 64 bit Windows"
            required = "false"
        />
        <unnamed
            name = "--win32"
            helpstring = "Generate sizes for 32 bit Windows"
            required = "false"
        />
        <unnamed
            name = "--enable-timer-type=x86cycle"
            helpstring = "Use the Pentium rdtsc instruction for timing"
            required = "false"
        />
        <unnamed
            name = "--enable-timer-type=queryperformancecounter"
            helpstring = "Use QueryPerformanceCounter for timing"
            required = "false"
        />
        <unnamed
			name = "--with-mcxx"
			helpstring = "Generate the managed C++ interface"
			required = "false"
		/>
		<unnamed
			name = "--f77_name_lower"
			helpstring = "Generate lowercase Fortran interface"
			required = "false"
		/>
		<unnamed
			name = "--f77_name_lower_uscore"
			helpstring = "Generate lowercase Fortran interface with one underscore"
			required = "false"
		/>
		<unnamed
			name = "--f77_name_lower_2uscore"
			helpstring = "Generate lowercase Fortran interface with two underscores"
			required = "false"
		/>
		<unnamed
			name = "--f77_name_upper"
			helpstring = "Generate uppercase Fortran interface"
			required = "false"
		/>
		<unnamed
			name = "--f77_name_mixed"
			helpstring = "Generate mixed case Fortran interface"
			required = "false"
		/>
		<unnamed
			name = "--f77_name_mixed_uscore"
			helpstring = "Generate mixed case Fortran interface with one underscore"
			required = "false"
		/>
		<unnamed
			name = "--defmsg"
			helpstring = "Generate defmsg.h"
			required = "false"
		/>
		<unnamed
			name = "--genstates"
			helpstring = "Generate mpiallstates.h and describe_states.c"
			required = "false"
		/>
		<unnamed
			name = "--mpicc"
			helpstring = "Generate mpicc.wsf"
			required = "false"
		/>
		<unnamed
			name = "--ifaces"
			helpstring = "Generate the interfaces (c++,f77,f90,etc)"
			required = "false"
		/>
		<unnamed
			name = "--remove-fortran"
			helpstring = "Remove fortran code and interfaces"
			required = "false"
		/>
		<unnamed
			name = "--use-ib-rdma"
			helpstring = "Use the rdma interface in the infiniband channel"
			required = "false"
		/>
		<unnamed
			name = "--cleancode"
			helpstring = "Clean up the code"
			required = "false"
		/>
		<unnamed
			name = "--dlldec"
			helpstring = "Add dll decoration to the mpi function prototypes"
			required = "false"
		/>
		<unnamed
			name = "--testdir"
			helpstring = "Configure the test directory only"
			require = "false"
		/>
		<unnamed
			name = "--gen-mpi"
			helpstring = "Generate the stub MPI functions"
			require = "false"
		/>
		<unnamed
			name = "--vs05"
			helpstring = "apply settings to the Visual Studio 2005 project files"
			require = "false"
		/>
<!--		<unnamed
			name = "--mt"
			helpstring = "build multithreaded libraries"
			require = "false"
		/>
-->
        <example>Example: winconfigure.wsf --force</example>
    </runtime>
<script language="VBScript">

' check if we are running cscript or wscript
bEcho = false
If InStr(1, LCase(WScript.FullName), "cscript") > 0 Then
	bEcho = true
End If
' Use cEcho to echo information to the command line only.
' The output is truncated to 4096 characters.
Function cEcho(str)
	If bEcho Then
		On Error Resume Next
		WScript.Echo str
		if err <> 0 then
			num_chars = Len(str) / 2
			if num_chars > 4096 then
				num_chars = 4096
			end if
			WScript.Echo Left(str, num_chars) & vbCrLf & "..." & vbCrLf
			WScript.Echo Right(str, num_chars)
		end if
	End If
End Function

'bMultiThreaded = false
x64 = False
bVS2005 = False
bUseIbRDMA = False
bUsePinCache = False
bRemoveFortran = False
'bWin64 = False
bUseCycleCounter = False
bForce = True
bCleanCode = False
bAddDllDecoration = False
bMcxx = False
bf77_name_lower = False
bf77_name_lower_uscore = False
bf77_name_lower_2uscore = False
bf77_name_upper = True
bf77_name_mixed = False
b77_name_mixed_uscore = False
unhandled_definitions = ""
unhandled_ats = ""
'
' Miscellaneous settings
'
MPI_MAX_PROCESSOR_NAME = "128"
'If bWin64 Then
  MPI_AINT64               = "__int64"
  BSEND_OVERHEAD64         = "95"
'Else
  MPI_AINT32               = "int"
  BSEND_OVERHEAD32         = "59"
'End If
MPI_FINT               = "int"
'MPI_OFFSET             = "long long"
MPI_OFFSET             = "__int64"
'MPI_OFFSET_TYPEDEF     = "typedef __int64 MPI_Offset;"
'MPI_OFFSET_TYPEDEF     = "typedef long long MPI_Offset;"
MPI_OFFSET_TYPEDEF     = "#if defined(USE_GCC) || defined(__GNUC__)" + vbCrLf + "typedef long long MPI_Offset;" + vbCrLf + "#else" + vbCrLf + "typedef __int64 MPI_Offset;" + vbCrLf + "#endif"
EXTRA_STATUS_DECL      = ""
HAVE_ROMIO             = "#include ""mpio.h"""

set f = WScript.CreateObject("Scripting.FileSystemObject")

'Set fin = f.OpenTextFile("src\util\thread\posix_types.i")
Set fin = f.OpenTextFile("src\util\thread\win_types.i")
mpe_thread_typedefs = fin.ReadAll()
fin.Close()
'Set fin = f.OpenTextFile("src\util\thread\posix_funcs.i")
Set fin = f.OpenTextFile("src\util\thread\win_funcs.i")
mpe_thread_funcs = fin.ReadAll()
'mpe_thread_funcs = Replace(mpe_thread_funcs, "sched_yield()", "Sleep(0)")
fin.Close()
Set fin = f.OpenTextFile("src\mpid\common\thread\mpe_types.i")
mpid_thread_typedefs = fin.ReadAll()
fin.Close()
Set fin = f.OpenTextFile("src\mpid\common\thread\mpe_funcs.i")
mpid_thread_funcs = fin.ReadAll()
mpid_thread_funcs = Replace(mpid_thread_funcs, "sched_yield()", "Sleep(0)")
fin.Close()

' Process arguments
argCount = WScript.Arguments.Count
For arg = 0 To argCount - 1
  argValue = WScript.Arguments(arg)
'  If argValue = "--win64" Then
'    bWin64 = True
'    MPI_AINT64 = "__int64"
'    BSEND_OVERHEAD64 = "95"
'    bUseCycleCounter = False
'  ElseIf argValue = "--win32" Then
'    bWin64 = False
  If argValue = "--enable-timer-type=x86cycle" Then
    bUseCycleCounter = True
  ElseIf argValue = "--enable-timer-type=queryperformancecounter" Then
    bUseCycleCounter = False
  ElseIf argValue = "--enable-hptiming" Then
    bUseCycleCounter = True
  ElseIf argValue = "--enable-hptiming=yes" Then
    bUseCycleCounter = True
  ElseIf argValue = "--enable-hptiming=no" Then
    bUseCycleCounter = False
  ElseIf argValue = "--force" Then
    bForce = True
  ElseIf argValue = "--force=yes" Then
    bForce = True
  ElseIf argValue = "--force=no" Then
    bForce = False
  ElseIf argValue = "--cleancode" Then
    bCleanCode = True
  ElseIf argValue = "--dlldec" Then
    bAddDllDecoration = True
  ElseIf argValue = "--with-mcxx" Then
	bMcxx = True
  ElseIf argValue = "--f77_name_lower" Then
	bf77_name_lower = True
  ElseIf argValue = "--f77_name_lower_uscore" Then
	bf77_name_lower_uscore = True
  ElseIf argValue = "--f77_name_lower_2uscore" Then
	bf77_name_loser_2uscore = True
  ElseIf argValue = "--f77_name_upper" Then
	bf77_name_upper = True
  ElseIf argValue = "--f77_name_mixed" Then
	bf77_name_mixed = True
  ElseIf argValue = "--f77_name_mixed_uscore" Then
	b77_name_mixed_uscore = True
  ElseIf argValue = "--defmsg" Then
    GenerateDefmsg()
    WScript.Quit
  ElseIf argValue = "--genstates" Then
    GenerateStatesFiles()
    WScript.Quit
  ElseIf argValue = "--mpicc" Then
	GenerateMPICC()
	WScript.Quit
  ElseIf argValue = "--ifaces" Then
	WScript.Echo "Option not implemented, run the entire script to generate the interfaces"
	' BuildIFaces needs the dictionary object to replace the @xxx@s in mpif.h
	'BuildIFaces()
	WScript.Quit
  ElseIf argValue = "--remove-fortran" Then
    bRemoveFortran = True
  ElseIf argValue = "--use-ib-rdma" Then
	bUseIbRDMA = True
  ElseIf argValue = "--use_ib_rdma" Then
	bUseIbRDMA = True
  ElseIf argValue = "--use-pin-cache" Then
    bUsePinCache = True
  ElseIf argValue = "--use_pin_cache" Then
    bUsePinCache = True
  ElseIf argValue = "--testdir" Then
    ConfigureTestDir()
    WScript.Quit
  ElseIf argValue = "--gen-mpi" Then
	FindMPIFuncs()
	WScript.Quit
  ElseIf argValue = "--gen-sfort" Then
	CreateStdcallFortranInterface()
	WScript.Quit
  ElseIf argValue = "--vs05" Then
    bVS2005 = True
'  ElseIf argValue = "--mt" Then
'    bMultiThreaded = true
  ElseIf argValue = "--help" Then
    WScript.Arguments.ShowUsage
    WScript.Quit
  End If
Next

'
' datatype sizes
'
  len_short           = "02"
  len_int             = "04"
  len_long            = "04"
  len_long_long       = "08"
  len_float           = "04"
  len_double          = "08"
  len_long_double     = "08"
  len_wchar           = "02"
  len_wchar_t         = "02"
  len_float_int       = "08"
  len_double_int      = "10"
  len_long_int        = "08"
  len_short_int       = "08"
  len_2_int           = "08"
  len_long_double_int = "10"
' Fortran datatype sizes
'If bWin64 Then
  len_integer64         = "08"
'else
  len_integer32         = "04"
'end if
  len_doublecplx      = "10"
  len_2dc             = "20"
'If bWin64 Then
'  len_short           = "02"
'  len_int             = "04"
'  len_long            = "04"
'  len_long_long       = "08"
'  len_float           = "04"
'  len_double          = "08"
'  len_long_double     = "08"
'  len_wchar           = "02"
'  len_wchar_t         = "02"
'  len_float_int       = "08"
'  len_double_int      = "10"
'  len_long_int        = "08"
'  len_short_int       = "08"
'  len_2_int           = "08"
'  len_long_double_int = "10"
'' Fortran datatype sizes
'  len_integer         = "08"
'  len_doublecplx      = "10"
'  len_2dc             = "20"
'Else
'  len_short           = "02"
'  len_int             = "04"
'  len_long            = "04"
'  len_long_long       = "08"
'  len_float           = "04"
'  len_double          = "08"
'  len_long_double     = "08"
'  len_wchar           = "02"
'  len_wchar_t         = "02"
'  len_float_int       = "08"
'  len_double_int      = "10"
'  len_long_int        = "08"
'  len_short_int       = "08"
'  len_2_int           = "08"
'  len_long_double_int = "10"
'' Fortran datatype sizes
'  len_integer         = "04"
'  len_doublecplx      = "10"
'  len_2dc             = "20"
'End If


Function CreateDtypeDictionary(byref types, str, b64)
	dim regEx, Match, Matches
	set regEx = New RegExp
	'set types = WScript.CreateObject("Scripting.Dictionary")
	' remove all dnl lines to prevent false matches
	regEx.Pattern = "dnl .*"
	regEx.IgnoreCase = True
	regEx.Global = True
	str = regEx.Replace(str, "")
	' find the datatype handles
	regEx.Pattern = "MPI_.*=""?0x4c00.*[0-9a-f][0-9a-f]"
	regEx.IgnoreCase = False
	regEx.Global = True
	Set Matches = regEx.Execute(str)
	For Each Match in Matches
		size_str = RegExpFind("\$\{len.*\}", Match.Value)
		dtype_str = RegExpFind("MPI_[^=]*", Match.Value)
		dtype_val_str = RegExpFind("0x4c00.*[0-9a-f][0-9a-f]", Match.Value)
		if size_str <> "" then
			Select Case size_str
				Case "${len_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_int)
				Case "${len_short}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_short)
				Case "${len_long}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_long)
				Case "${len_long_long}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_long_long)
				Case "${len_float_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_float_int)
				Case "${len_double_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_double_int)
				Case "${len_long_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_long_int)
				Case "${len_short_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_short_int)
				Case "${len_2_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_2_int)
				Case "${len_long_double_int}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_long_double_int)
				Case "${len_double}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_double)
				Case "${len_doublecplx}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_doublecplx)
				Case "${len_2dc}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_2dc)
				Case "${len_float}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_float)
				Case "${len_long_double}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_long_double)
				Case "${len_integer}"
					if b64 then
						dtype_val_str = Replace(dtype_val_str, size_str, len_integer64)
					else
						dtype_val_str = Replace(dtype_val_str, size_str, len_integer32)
					end if
				Case "${len_wchar_t}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_wchar_t)
				Case "${len_wchar}"
					dtype_val_str = Replace(dtype_val_str, size_str, len_wchar)
				Case Else
					unmatched_size_strs = unmatched_size_strs & " " & size_str & vbCrLf
			End Select
		end if
		if types.Exists(dtype_str) then
			if types.Item(dtype_str) <> dtype_val_str then
				temp_str = dtype_str & " = " & types.Item(dtype_str) & " or " & dtype_val_str
				MsgBox temp_str
			end if
		else
			types.Add dtype_str, dtype_val_str
		end if
	Next
	if unmatched_size_strs <> "" then
		MsgBox unmatched_size_strs
	end if
	'CreateDtypeDictionary = types
End Function

'
' Create a dictionary of all the datatype handles
'
unmatched_size_strs = ""
set fin = f.OpenTextFile("configure.in")
contents = fin.ReadAll()
fin.Close()
'set fin = f.OpenTextFile("src\binding\f77\configure.in")
'contents = contents + fin.ReadAll()
'fin.Close()
'set dtypes = CreateDtypeDictionary(contents, false)
'set dtypes64 = CreateDtypeDictionary(contents, true)
set dtypes = WScript.CreateObject("Scripting.Dictionary")
CreateDtypeDictionary dtypes, contents, false
set dtypes64 = WScript.CreateObject("Scripting.Dictionary")
CreateDtypeDictionary dtypes64, contents, false

'mpi_datatype_prefix = "4c00"

'MPI_CHAR              = "0x" + mpi_datatype_prefix                 + "0101"
'MPI_SIGNED_CHAR       = "0x" + mpi_datatype_prefix                 + "0118"
'MPI_UNSIGNED_CHAR     = "0x" + mpi_datatype_prefix                 + "0102"
'MPI_BYTE              = "0x" + mpi_datatype_prefix                 + "010d"
'MPI_WCHAR             = "0x" + mpi_datatype_prefix + len_wchar       + "0e"
'MPI_WCHAR_T           = "0x" + mpi_datatype_prefix + len_wchar_t     + "0e"
'MPI_SHORT             = "0x" + mpi_datatype_prefix + len_short       + "03"
'MPI_UNSIGNED_SHORT    = "0x" + mpi_datatype_prefix + len_short       + "04"
'MPI_INT               = "0x" + mpi_datatype_prefix + len_int         + "05"
'MPI_UNSIGNED          = "0x" + mpi_datatype_prefix + len_int         + "06"
'MPI_LONG              = "0x" + mpi_datatype_prefix + len_long        + "07"
'MPI_UNSIGNED_LONG     = "0x" + mpi_datatype_prefix + len_long        + "08"
'MPI_LONG_LONG         = "0x" + mpi_datatype_prefix + len_long_long   + "09"
'MPI_LONG_LONG_INT     = "0x" + mpi_datatype_prefix + len_long_long   + "09"
'MPI_UNSIGNED_LONG_LONG ="0x" + mpi_datatype_prefix + len_long_long   + "19"
'MPI_FLOAT             = "0x" + mpi_datatype_prefix + len_float       + "0a"
'MPI_DOUBLE            = "0x" + mpi_datatype_prefix + len_double      + "0b"
'MPI_LONG_DOUBLE       = "0x" + mpi_datatype_prefix + len_long_double + "0c"
'MPI_PACKED            = "0x" + mpi_datatype_prefix                 + "010f"
'MPI_LB                = "0x" + mpi_datatype_prefix                 + "0010"
'MPI_UB                = "0x" + mpi_datatype_prefix                 + "0011"
'MPI_REAL4             = "0x" + mpi_datatype_prefix                 + "0427"
'MPI_REAL8             = "0x" + mpi_datatype_prefix                 + "0829"
'MPI_REAL16            = "0x" + mpi_datatype_prefix                 + "1029"
'MPI_COMPLEX8          = "0x" + mpi_datatype_prefix                 + "0828"
'MPI_COMPLEX16         = "0x" + mpi_datatype_prefix                 + "102b"
'MPI_COMPLEX32         = "0x" + mpi_datatype_prefix                 + "2030"
'MPI_INTEGER1          = "0x" + mpi_datatype_prefix                 + "012d"
'MPI_INTEGER2          = "0x" + mpi_datatype_prefix                 + "022f"
'MPI_INTEGER4          = "0x" + mpi_datatype_prefix                 + "0430"
'MPI_INTEGER8          = "0x" + mpi_datatype_prefix                 + "082a"
'MPI_INTEGER16         = "0x" + mpi_datatype_prefix                 + "102f"
'MPI_FLOAT_INT         = "0x" + mpi_datatype_prefix + len_float_int       + "12"
'MPI_DOUBLE_INT        = "0x" + mpi_datatype_prefix + len_double_int      + "13"
'MPI_LONG_INT          = "0x" + mpi_datatype_prefix + len_long_int        + "14"
'MPI_SHORT_INT         = "0x" + mpi_datatype_prefix + len_short_int       + "15"
'MPI_2INT              = "0x" + mpi_datatype_prefix + len_2_int           + "16"
'MPI_LONG_DOUBLE_INT   = "0x" + mpi_datatype_prefix + len_long_double_int + "17"
'MPI_CHARACTER         = "0x" + mpi_datatype_prefix                + "011a"
'MPI_INTEGER           = "0x" + mpi_datatype_prefix + len_integer    + "1b"
'MPI_REAL              = "0x" + mpi_datatype_prefix + len_integer    + "1c"
'MPI_LOGICAL           = "0x" + mpi_datatype_prefix + len_integer    + "1d"
'MPI_COMPLEX           = "0x" + mpi_datatype_prefix + len_double     + "1e"
'MPI_DOUBLE_PRECISION  = "0x" + mpi_datatype_prefix + len_double     + "1f"
'MPI_2INTEGER          = "0x" + mpi_datatype_prefix + len_double     + "20"
'MPI_2REAL             = "0x" + mpi_datatype_prefix + len_double     + "21"
'MPI_DOUBLE_COMPLEX    = "0x" + mpi_datatype_prefix + len_doublecplx + "22"
'MPI_2DOUBLE_PRECISION = "0x" + mpi_datatype_prefix + len_doublecplx + "23"
'MPI_2COMPLEX          = "0x" + mpi_datatype_prefix + len_doublecplx + "24"
'MPI_2DOUBLE_COMPLEX   = "0x" + mpi_datatype_prefix + len_2dc        + "25"

'F77_MPI_COMPLEX           = "1275070494"
'F77_MPI_DOUBLE_COMPLEX    = "1275072546"
'F77_MPI_LOGICAL           = "1275069469"
'F77_MPI_REAL              = "1275069468"
'F77_MPI_DOUBLE_PRECISION  = "1275070495"
'F77_MPI_INTEGER           = "1275069467"
'F77_MPI_2INTEGER          = "1275070496"
'F77_MPI_2COMPLEX          = "1275072548"
'F77_MPI_2DOUBLE_COMPLEX   = "1275076645"
'F77_MPI_2REAL             = "1275070497"
'F77_MPI_2DOUBLE_PRECISION = "1275072547"
'F77_MPI_CHARACTER         = "1275068698"
'F77_MPI_LB                = "1275068432"
'F77_MPI_PACKED            = "1275068687"
'F77_MPI_UB                = "1275068433"
'F77_COMPLEX8              = "1275070504"
'F77_COMPLEX16             = "1275072554"
'F77_COMPLEX32             = "MPI_DATATYPE_NULL"
'F77_INTEGER1              = "1275068717"
'F77_INTEGER2              = "1275068975"
'F77_INTEGER4              = "1275069488"
'F77_INTEGER8              = "1275070507"
'F77_INTEGER16             = "MPI_DATATYPE_NULL"
'F77_REAL4                 = "1275069479"
'F77_REAL8                 = "1275070505"
'F77_REAL16                = "MPI_DATATYPE_NULL"

'
' Set the datatype variables from the dictionary
'
mpi_datatype_prefix = "4c00"
missing_datatypes = ""

if dtypes.Exists("MPI_CHAR") then
	MPI_CHAR = dtypes.Item("MPI_CHAR")
else
	missing_datatypes = missing_datatypes & "MPI_CHAR" & vbCrLf
	MPI_CHAR              = "0x" + mpi_datatype_prefix                 + "0101"
end if
if dtypes.Exists("MPI_SIGNED_CHAR") then
	MPI_SIGNED_CHAR = dtypes.Item("MPI_SIGNED_CHAR")
else
	missing_datatypes = missing_datatypes & "MPI_SIGNED_CHAR" & vbCrLf
	MPI_SIGNED_CHAR       = "0x" + mpi_datatype_prefix                 + "0118"
end if
if dtypes.Exists("MPI_UNSIGNED_CHAR") then
	MPI_UNSIGNED_CHAR = dtypes.Item("MPI_UNSIGNED_CHAR")
else
	missing_datatypes = missing_datatypes & "MPI_UNSIGNED_CHAR" & vbCrLf
	MPI_UNSIGNED_CHAR     = "0x" + mpi_datatype_prefix                 + "0102"
end if
if dtypes.Exists("MPI_BYTE") then
	MPI_BYTE = dtypes.Item("MPI_BYTE")
else
	missing_datatypes = missing_datatypes & "MPI_BYTE" & vbCrLf
	MPI_BYTE              = "0x" + mpi_datatype_prefix                 + "010d"
end if
if dtypes.Exists("MPI_WCHAR") then
	MPI_WCHAR = dtypes.Item("MPI_WCHAR")
else
	missing_datatypes = missing_datatypes & "MPI_WCHAR" & vbCrLf
	MPI_WCHAR             = "0x" + mpi_datatype_prefix + len_wchar       + "0e"
end if
if dtypes.Exists("MPI_WCHAR_T") then
	MPI_WCHAR_T = dtypes.Item("MPI_WCHAR_T")
else
	'missing_datatypes = missing_datatypes & "MPI_WCHAR_T" & vbCrLf
	'MPI_WCHAR_T           = "0x" + mpi_datatype_prefix + len_wchar_t     + "0e"
	MPI_WCHAR_T = dtypes.Item("MPI_WCHAR")
end if
if dtypes.Exists("MPI_SHORT") then
	MPI_SHORT = dtypes.Item("MPI_SHORT")
else
	missing_datatypes = missing_datatypes & "MPI_SHORT" & vbCrLf
	MPI_SHORT             = "0x" + mpi_datatype_prefix + len_short       + "03"
end if
if dtypes.Exists("MPI_UNSIGNED_SHORT") then
	MPI_UNSIGNED_SHORT = dtypes.Item("MPI_UNSIGNED_SHORT")
else
	missing_datatypes = missing_datatypes & "MPI_UNSIGNED_SHORT" & vbCrLf
	MPI_UNSIGNED_SHORT    = "0x" + mpi_datatype_prefix + len_short       + "04"
end if
if dtypes.Exists("MPI_INT") then
	MPI_INT = dtypes.Item("MPI_INT")
else
	missing_datatypes = missing_datatypes & "MPI_INT" & vbCrLf
	MPI_INT               = "0x" + mpi_datatype_prefix + len_int         + "05"
end if
if dtypes.Exists("MPI_UNSIGNED_INT") then
	MPI_UNSIGNED_INT = dtypes.Item("MPI_UNSIGNED_INT")
else
	missing_datatypes = missing_datatypes & "MPI_UNSIGNED_INT" & vbCrLf
	MPI_UNSIGNED_INT      = "0x" + mpi_datatype_prefix + len_int         + "06"
end if
if dtypes.Exists("MPI_UNSIGNED") then
	MPI_UNSIGNED = dtypes.Item("MPI_UNSIGNED")
else
	'missing_datatypes = missing_datatypes & "MPI_UNSIGNED" & vbCrLf
	'MPI_UNSIGNED          = "0x" + mpi_datatype_prefix + len_int         + "06"
	MPI_UNSIGNED = dtypes.Item("MPI_UNSIGNED_INT")
end if
if dtypes.Exists("MPI_LONG") then
	MPI_LONG = dtypes.Item("MPI_LONG")
else
	missing_datatypes = missing_datatypes & "MPI_LONG" & vbCrLf
	MPI_LONG              = "0x" + mpi_datatype_prefix + len_long        + "07"
end if
if dtypes.Exists("MPI_UNSIGNED_LONG") then
	MPI_UNSIGNED_LONG = dtypes.Item("MPI_UNSIGNED_LONG")
else
	missing_datatypes = missing_datatypes & "MPI_UNSIGNED_LONG" & vbCrLf
	MPI_UNSIGNED_LONG     = "0x" + mpi_datatype_prefix + len_long        + "08"
end if
if dtypes.Exists("MPI_LONG_LONG") then
	MPI_LONG_LONG = dtypes.Item("MPI_LONG_LONG")
else
	missing_datatypes = missing_datatypes & "MPI_LONG_LONG" & vbCrLf
	MPI_LONG_LONG         = "0x" + mpi_datatype_prefix + len_long_long   + "09"
end if
if dtypes.Exists("MPI_LONG_LONG_INT") then
	MPI_LONG_LONG_INT = dtypes.Item("MPI_LONG_LONG_INT")
else
	'missing_datatypes = missing_datatypes & "MPI_LONG_LONG_INT" & vbCrLf
	'MPI_LONG_LONG_INT     = "0x" + mpi_datatype_prefix + len_long_long   + "09"
	MPI_LONG_LONG_INT = dtypes.Item("MPI_LONG_LONG")
end if
if dtypes.Exists("MPI_UNSIGNED_LONG_LONG") then
	MPI_UNSIGNED_LONG_LONG = dtypes.Item("MPI_UNSIGNED_LONG_LONG")
else
	missing_datatypes = missing_datatypes & "MPI_UNSIGNED_LONG_LONG" & vbCrLf
	MPI_UNSIGNED_LONG_LONG ="0x" + mpi_datatype_prefix + len_long_long   + "19"
end if
if dtypes.Exists("MPI_FLOAT") then
	MPI_FLOAT = dtypes.Item("MPI_FLOAT")
else
	missing_datatypes = missing_datatypes & "MPI_FLOAT" & vbCrLf
	MPI_FLOAT             = "0x" + mpi_datatype_prefix + len_float       + "0a"
end if
if dtypes.Exists("MPI_DOUBLE") then
	MPI_DOUBLE = dtypes.Item("MPI_DOUBLE")
else
	missing_datatypes = missing_datatypes & "MPI_DOUBLE" & vbCrLf
	MPI_DOUBLE            = "0x" + mpi_datatype_prefix + len_double      + "0b"
end if
if dtypes.Exists("MPI_LONG_DOUBLE") then
	MPI_LONG_DOUBLE = dtypes.Item("MPI_LONG_DOUBLE")
else
	missing_datatypes = missing_datatypes & "MPI_LONG_DOUBLE" & vbCrLf
	MPI_LONG_DOUBLE       = "0x" + mpi_datatype_prefix + len_long_double + "0c"
end if
if dtypes.Exists("MPI_PACKED") then
	MPI_PACKED = dtypes.Item("MPI_PACKED")
else
	missing_datatypes = missing_datatypes & "MPI_PACKED" & vbCrLf
	MPI_PACKED            = "0x" + mpi_datatype_prefix                 + "010f"
end if
if dtypes.Exists("MPI_LB") then
	MPI_LB = dtypes.Item("MPI_LB")
else
	missing_datatypes = missing_datatypes & "MPI_LB" & vbCrLf
	MPI_LB                = "0x" + mpi_datatype_prefix                 + "0010"
end if
if dtypes.Exists("MPI_UB") then
	MPI_UB = dtypes.Item("MPI_UB")
else
	missing_datatypes = missing_datatypes & "MPI_UB" & vbCrLf
	MPI_UB                = "0x" + mpi_datatype_prefix                 + "0011"
end if
if dtypes.Exists("MPI_REAL4") then
	MPI_REAL4 = dtypes.Item("MPI_REAL4")
else
	missing_datatypes = missing_datatypes & "MPI_REAL4" & vbCrLf
	MPI_REAL4             = "0x" + mpi_datatype_prefix                 + "0427"
end if
if dtypes.Exists("MPI_REAL8") then
	MPI_REAL8 = dtypes.Item("MPI_REAL8")
else
	missing_datatypes = missing_datatypes & "MPI_REAL8" & vbCrLf
	MPI_REAL8             = "0x" + mpi_datatype_prefix                 + "0829"
end if
if dtypes.Exists("MPI_REAL16") then
	MPI_REAL16 = dtypes.Item("MPI_REAL16")
else
	missing_datatypes = missing_datatypes & "MPI_REAL16" & vbCrLf
	MPI_REAL16            = "0x" + mpi_datatype_prefix                 + "1029"
end if
if dtypes.Exists("MPI_COMPLEX8") then
	MPI_COMPLEX8 = dtypes.Item("MPI_COMPLEX8")
else
	missing_datatypes = missing_datatypes & "MPI_COMPLEX8" & vbCrLf
	MPI_COMPLEX8          = "0x" + mpi_datatype_prefix                 + "0828"
end	if
if dtypes.Exists("MPI_COMPLEX16") then
	MPI_COMPLEX16 = dtypes.Item("MPI_COMPLEX16")
else
	missing_datatypes = missing_datatypes & "MPI_COMPLEX16" & vbCrLf
	MPI_COMPLEX16         = "0x" + mpi_datatype_prefix                 + "102b"
end if
if dtypes.Exists("MPI_COMPLEX32") then
	MPI_COMPLEX32 = dtypes.Item("MPI_COMPLEX32")
else
	missing_datatypes = missing_datatypes & "MPI_COMPLEX32" & vbCrLf
	MPI_COMPLEX32         = "0x" + mpi_datatype_prefix                 + "2030"
end if
if dtypes.Exists("MPI_INTEGER1") then
	MPI_INTEGER1 = dtypes.Item("MPI_INTEGER1")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER1" & vbCrLf
	MPI_INTEGER1          = "0x" + mpi_datatype_prefix                 + "012d"
end if
if dtypes.Exists("MPI_INTEGER2") then
	MPI_INTEGER2 = dtypes.Item("MPI_INTEGER2")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER2" & vbCrLf
	MPI_INTEGER2          = "0x" + mpi_datatype_prefix                 + "022f"
end if
if dtypes.Exists("MPI_INTEGER4") then
	MPI_INTEGER4 = dtypes.Item("MPI_INTEGER4")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER4" & vbCrLf
	MPI_INTEGER4          = "0x" + mpi_datatype_prefix                 + "0430"
end if
if dtypes.Exists("MPI_INTEGER8") then
	MPI_INTEGER8 = dtypes.Item("MPI_INTEGER8")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER8" & vbCrLf
	MPI_INTEGER8          = "0x" + mpi_datatype_prefix                 + "082a"
end if
if dtypes.Exists("MPI_INTEGER16") then
	MPI_INTEGER16 = dtypes.Item("MPI_INTEGER16")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER16" & vbCrLf
	MPI_INTEGER16         = "0x" + mpi_datatype_prefix                 + "102f"
end if
if dtypes.Exists("MPI_FLOAT_INT") then
	MPI_FLOAT_INT = dtypes.Item("MPI_FLOAT_INT")
else
	'missing_datatypes = missing_datatypes & "MPI_FLOAT_INT" & vbCrLf
	'MPI_FLOAT_INT         = "0x" + mpi_datatype_prefix + len_float_int       + "12"
	MPI_FLOAT_INT         = "0x8c000000"
end if
if dtypes.Exists("MPI_DOUBLE_INT") then
	MPI_DOUBLE_INT = dtypes.Item("MPI_DOUBLE_INT")
else
	'missing_datatypes = missing_datatypes & "MPI_DOUBLE_INT" & vbCrLf
	'MPI_DOUBLE_INT        = "0x" + mpi_datatype_prefix + len_double_int      + "13"
	MPI_DOUBLE_INT        = "0x8c000001"
end if
if dtypes.Exists("MPI_LONG_INT") then
	MPI_LONG_INT = dtypes.Item("MPI_LONG_INT")
else
	'missing_datatypes = missing_datatypes & "MPI_LONG_INT" & vbCrLf
	'MPI_LONG_INT          = "0x" + mpi_datatype_prefix + len_long_int        + "14"
	MPI_LONG_INT          = "0x8c000002"
end if
if dtypes.Exists("MPI_SHORT_INT") then
	MPI_SHORT_INT = dtypes.Item("MPI_SHORT_INT")
else
	'missing_datatypes = missing_datatypes & "MPI_SHORT_INT" & vbCrLf
	'MPI_SHORT_INT         = "0x" + mpi_datatype_prefix + len_short_int       + "15"
	MPI_SHORT_INT         = "0x8c000003"
end if
if dtypes.Exists("MPI_2INT") then
	MPI_2INT = dtypes.Item("MPI_2INT")
else
	missing_datatypes = missing_datatypes & "MPI_2INT" & vbCrLf
	MPI_2INT              = "0x" + mpi_datatype_prefix + len_2_int           + "16"
end if
if dtypes.Exists("MPI_LONG_DOUBLE_INT") then
	MPI_LONG_DOUBLE_INT = dtypes.Item("MPI_LONG_DOUBLE_INT")
else
	'missing_datatypes = missing_datatypes & "MPI_LONG_DOUBLE_INT" & vbCrLf
	'MPI_LONG_DOUBLE_INT   = "0x" + mpi_datatype_prefix + len_long_double_int + "17"
	MPI_LONG_DOUBLE_INT   = "0x8c000004"
end if
if dtypes.Exists("MPI_CHARACTER") then
	MPI_CHARACTER = dtypes.Item("MPI_CHARACTER")
else
	missing_datatypes = missing_datatypes & "MPI_CHARACTER" & vbCrLf
	MPI_CHARACTER         = "0x" + mpi_datatype_prefix                + "011a"
end if
' Win32 versions
if dtypes.Exists("MPI_INTEGER") then
	MPI_INTEGER_W32 = dtypes.Item("MPI_INTEGER")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER" & vbCrLf
	MPI_INTEGER_W32           = "0x" + mpi_datatype_prefix + len_integer    + "1b"
end if
if dtypes.Exists("MPI_REAL") then
	MPI_REAL_W32 = dtypes.Item("MPI_REAL")
else
	missing_datatypes = missing_datatypes & "MPI_REAL" & vbCrLf
	MPI_REAL_W32              = "0x" + mpi_datatype_prefix + len_integer    + "1c"
end if
if dtypes.Exists("MPI_LOGICAL") then
	MPI_LOGICAL_W32 = dtypes.Item("MPI_LOGICAL")
else
	missing_datatypes = missing_datatypes & "MPI_LOGICAL" & vbCrLf
	MPI_LOGICAL_W32           = "0x" + mpi_datatype_prefix + len_integer    + "1d"
end if
' Win64 versions
if dtypes64.Exists("MPI_INTEGER") then
	MPI_INTEGER_W64 = dtypes64.Item("MPI_INTEGER")
else
	missing_datatypes = missing_datatypes & "MPI_INTEGER" & vbCrLf
	MPI_INTEGER_W64           = "0x" + mpi_datatype_prefix + len_integer    + "1b"
end if
if dtypes64.Exists("MPI_REAL") then
	MPI_REAL_W64 = dtypes64.Item("MPI_REAL")
else
	missing_datatypes = missing_datatypes & "MPI_REAL" & vbCrLf
	MPI_REAL_W64              = "0x" + mpi_datatype_prefix + len_integer    + "1c"
end if
if dtypes64.Exists("MPI_LOGICAL") then
	MPI_LOGICAL_W64 = dtypes64.Item("MPI_LOGICAL")
else
	missing_datatypes = missing_datatypes & "MPI_LOGICAL" & vbCrLf
	MPI_LOGICAL_W64           = "0x" + mpi_datatype_prefix + len_integer    + "1d"
end if
' end versions
if dtypes.Exists("MPI_COMPLEX") then
	MPI_COMPLEX = dtypes.Item("MPI_COMPLEX")
else
	missing_datatypes = missing_datatypes & "MPI_COMPLEX" & vbCrLf
	MPI_COMPLEX           = "0x" + mpi_datatype_prefix + len_double     + "1e"
end if
if dtypes.Exists("MPI_DOUBLE_PRECISION") then
	MPI_DOUBLE_PRECISION = dtypes.Item("MPI_DOUBLE_PRECISION")
else
	missing_datatypes = missing_datatypes & "MPI_DOUBLE_PRECISION" & vbCrLf
	MPI_DOUBLE_PRECISION  = "0x" + mpi_datatype_prefix + len_double     + "1f"
end if
if dtypes.Exists("MPI_2INTEGER") then
	MPI_2INTEGER = dtypes.Item("MPI_2INTEGER")
else
	missing_datatypes = missing_datatypes & "MPI_2INTEGER" & vbCrLf
	MPI_2INTEGER          = "0x" + mpi_datatype_prefix + len_double     + "20"
end if
if dtypes.Exists("MPI_2REAL") then
	MPI_2REAL = dtypes.Item("MPI_2REAL")
else
	missing_datatypes = missing_datatypes & "MPI_2REAL" & vbCrLf
	MPI_2REAL             = "0x" + mpi_datatype_prefix + len_double     + "21"
end if
if dtypes.Exists("MPI_DOUBLE_COMPLEX") then
	MPI_DOUBLE_COMPLEX = dtypes.Item("MPI_DOUBLE_COMPLEX")
else
	missing_datatypes = missing_datatypes & "MPI_DOUBLE_COMPLEX" & vbCrLf
	MPI_DOUBLE_COMPLEX    = "0x" + mpi_datatype_prefix + len_doublecplx + "22"
end if
if dtypes.Exists("MPI_2DOUBLE_PRECISION") then
	MPI_2DOUBLE_PRECISION = dtypes.Item("MPI_2DOUBLE_PRECISION")
else
	missing_datatypes = missing_datatypes & "MPI_2DOUBLE_PRECISION" & vbCrLf
	MPI_2DOUBLE_PRECISION = "0x" + mpi_datatype_prefix + len_doublecplx + "23"
end if
if dtypes.Exists("MPI_2COMPLEX") then
	MPI_2COMPLEX = dtypes.Item("MPI_2COMPLEX")
else
	missing_datatypes = missing_datatypes & "MPI_2COMPLEX" & vbCrLf
	MPI_2COMPLEX          = "0x" + mpi_datatype_prefix + len_doublecplx + "24"
end if
if dtypes.Exists("MPI_2DOUBLE_COMPLEX") then
	MPI_2DOUBLE_COMPLEX = dtypes.Item("MPI_2DOUBLE_COMPLEX")
else
	missing_datatypes = missing_datatypes & "MPI_2DOUBLE_COMPLEX" & vbCrLf
	MPI_2DOUBLE_COMPLEX   = "0x" + mpi_datatype_prefix + len_2dc        + "25"
end if

if missing_datatypes <> "" then
	MsgBox "Missing datatypes:" & vbCrLf & missing_datatypes
	WScript.Quit
end if

Function ToInteger(c)
	Dim i
	i = 0
	if c = "0" then i = 0 end if
	if c = "1" then i = 1 end if
	if c = "2" then i = 2 end if
	if c = "3" then i = 3 end if
	if c = "4" then i = 4 end if
	if c = "5" then i = 5 end if
	if c = "6" then i = 6 end if
	if c = "7" then i = 7 end if
	if c = "8" then i = 8 end if
	if c = "9" then i = 9 end if
	if c = "a" then i = 10 end if
	if c = "b" then i = 11 end if
	if c = "c" then i = 12 end if
	if c = "d" then i = 13 end if
	if c = "e" then i = 14 end if
	if c = "f" then i = 15 end if
	ToInteger = i
End Function

'first = true
Function HexToInt(str)
	Dim i, multiplier, index
	i = 0
	multiplier = 1
	for index = len(str) to 3 step -1
		i = i + (ToInteger(Mid(str, index, 1)) * multiplier)
		multiplier = multiplier * 16
		'if first then
		'	MsgBox "char " & Mid(str, index, 1) & ", i = " & i
		'end if
	next
	'first = false
	HexToInt = i
End Function

F77_MPI_DOUBLE_COMPLEX    = HexToInt(dtypes.Item("MPI_DOUBLE_COMPLEX"))
F77_MPI_COMPLEX           = HexToInt(dtypes.Item("MPI_COMPLEX"))
F77_MPI_LOGICAL_W32           = HexToInt(dtypes.Item("MPI_LOGICAL"))
F77_MPI_LOGICAL_W64           = HexToInt(dtypes64.Item("MPI_LOGICAL"))
F77_MPI_REAL_W32              = HexToInt(dtypes.Item("MPI_REAL"))
F77_MPI_REAL_W64              = HexToInt(dtypes64.Item("MPI_REAL"))
F77_MPI_DOUBLE_PRECISION  = HexToInt(dtypes.Item("MPI_DOUBLE_PRECISION"))
F77_MPI_INTEGER_W32           = HexToInt(dtypes.Item("MPI_INTEGER"))
F77_MPI_INTEGER_W64           = HexToInt(dtypes64.Item("MPI_INTEGER"))
F77_MPI_2INTEGER          = HexToInt(dtypes.Item("MPI_2INTEGER"))
F77_MPI_2COMPLEX          = HexToInt(dtypes.Item("MPI_2COMPLEX"))
F77_MPI_2DOUBLE_COMPLEX   = HexToInt(dtypes.Item("MPI_2DOUBLE_COMPLEX"))
F77_MPI_2REAL             = HexToInt(dtypes.Item("MPI_2REAL"))
F77_MPI_2DOUBLE_PRECISION = HexToInt(dtypes.Item("MPI_2DOUBLE_PRECISION"))
F77_MPI_CHARACTER         = HexToInt(dtypes.Item("MPI_CHARACTER"))
F77_MPI_BYTE              = HexToInt(dtypes.Item("MPI_BYTE"))
F77_MPI_LB                = HexToInt(dtypes.Item("MPI_LB"))
F77_MPI_PACKED            = HexToInt(dtypes.Item("MPI_PACKED"))
F77_MPI_UB                = HexToInt(dtypes.Item("MPI_UB"))
F77_COMPLEX8              = HexToInt(dtypes.Item("MPI_COMPLEX8"))
F77_COMPLEX16             = HexToInt(dtypes.Item("MPI_COMPLEX16"))
F77_COMPLEX32             = HexToInt(dtypes.Item("MPI_COMPLEX32"))
F77_INTEGER1              = HexToInt(dtypes.Item("MPI_INTEGER1"))
F77_INTEGER2              = HexToInt(dtypes.Item("MPI_INTEGER2"))
F77_INTEGER4              = HexToInt(dtypes.Item("MPI_INTEGER4"))
F77_INTEGER8              = HexToInt(dtypes.Item("MPI_INTEGER8"))
F77_INTEGER16             = HexToInt(dtypes.Item("MPI_INTEGER16"))
F77_REAL4                 = HexToInt(dtypes.Item("MPI_REAL4"))
F77_REAL8                 = HexToInt(dtypes.Item("MPI_REAL8"))
F77_REAL16                = HexToInt(dtypes.Item("MPI_REAL16"))

if false then
foo = ""
foo = "F77_MPI_COMPLEX = " &                F77_MPI_COMPLEX          & vbCrLf
foo = foo & "F77_MPI_DOUBLE_COMPLEX = " &   F77_MPI_DOUBLE_COMPLEX   & vbCrLf
foo = foo & "F77_MPI_LOGICAL = " &          F77_MPI_LOGICAL          & vbCrLf
foo = foo & "F77_MPI_REAL = " &             F77_MPI_REAL             & vbCrLf
foo = foo & "F77_MPI_DOUBLE_PRECISION = " & F77_MPI_DOUBLE_PRECISION & vbCrLf
foo = foo & "F77_MPI_INTEGER = " &          F77_MPI_INTEGER          & vbCrLf
foo = foo & "F77_MPI_2INTEGER = " &         F77_MPI_2INTEGER         & vbCrLf
foo = foo & "F77_MPI_2COMPLEX = " &         F77_MPI_2COMPLEX         & vbCrLf
foo = foo & "F77_MPI_2DOUBLE_COMPLEX = " &  F77_MPI_2DOUBLE_COMPLEX  & vbCrLf
foo = foo & "F77_MPI_2REAL = " &            F77_MPI_2REAL            & vbCrLf
foo = foo & "F77_MPI_2DOUBLE_PRECISION = " & F77_MPI_2DOUBLE_PRECISION & vbCrLf
foo = foo & "F77_MPI_CHARACTER = " &        F77_MPI_CHARACTER        & vbCrLf
foo = foo & "F77_MPI_LB = " &               F77_MPI_LB               & vbCrLf
foo = foo & "F77_MPI_PACKED = " &           F77_MPI_PACKED           & vbCrLf
foo = foo & "F77_MPI_UB = " &               F77_MPI_UB               & vbCrLf
foo = foo & "F77_COMPLEX8 = " &             F77_COMPLEX8             & vbCrLf
foo = foo & "F77_COMPLEX16 = " &            F77_COMPLEX16            & vbCrLf
foo = foo & "F77_COMPLEX32 = " &            F77_COMPLEX32            & vbCrLf
foo = foo & "F77_INTEGER1 = " &             F77_INTEGER1             & vbCrLf
foo = foo & "F77_INTEGER2 = " &             F77_INTEGER2             & vbCrLf
foo = foo & "F77_INTEGER4 = " &             F77_INTEGER4             & vbCrLf
foo = foo & "F77_INTEGER8 = " &             F77_INTEGER8             & vbCrLf
foo = foo & "F77_INTEGER16 = " &            F77_INTEGER16            & vbCrLf
foo = foo & "F77_REAL4 = " &                F77_REAL4                & vbCrLf
foo = foo & "F77_REAL8 = " &                F77_REAL8                & vbCrLf
foo = foo & "F77_REAL16 = " &               F77_REAL16               & vbCrLf
WScript.Echo foo
end if

Function DecorateMPIFuncs(str)
	' uncomment out the HAVE_EXPORTS_MPI_API block
	'str = ReplaceBetweenTags(str, "/*", "HAVE_EXPORT_MPI_API", "*/", "#ifdef MPICH2_STATIC_LIBRARY" & vbCrLf & "#define EXPORT_MPI_API" & vbCrLf & "#else" & vbCrLf & "#ifdef MPICH2_EXPORTS" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllexport)" & vbCrLf & "#else" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllimport)" & vbCrLf & "#endif" & vbCrLf & "#endif" & vbCrLf & "#ifndef MPI_CALL" & vbCrLf & "#define MPI_CALL __cdecl" & vbCrLf & "#endif" & vbCrLf)
	str = Replace(str, "/* --Insert Additional Definitions Here-- */", "#ifdef MPICH2_STATIC_LIBRARY" & vbCrLf & "#define EXPORT_MPI_API" & vbCrLf & "#else" & vbCrLf & "#ifdef MPICH2_EXPORTS" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllexport)" & vbCrLf & "#else" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllimport)" & vbCrLf & "#endif" & vbCrLf & "#endif" & vbCrLf & "#ifndef MPI_CALL" & vbCrLf & "#define MPI_CALL __cdecl" & vbCrLf & "#endif" & vbCrLf)
	' add dllspec and calling convention to the MPI api
	first_index = InStr(str, "#ifndef MPICH_SUPPRESS_PROTOTYPES")
	last_index = InStr(str, "#endif /* MPICH_SUPPRESS_PROTOTYPES */")
	if first_index <> 0 and last_index <> 0 then
		prototypes = Mid(str, first_index, last_index - first_index)
		prototypes = Replace(prototypes, "int MPI_", "EXPORT_MPI_API int MPI_CALL MPI_")
		prototypes = Replace(prototypes, "double PMPI_Wtime", "EXPORT_MPI_API double MPI_CALL PMPI_Wtime")
		prototypes = Replace(prototypes, "double PMPI_Wtick", "EXPORT_MPI_API double MPI_CALL PMPI_Wtick")
		prototypes = Replace(prototypes, "double MPI_Wtime", "EXPORT_MPI_API double MPI_CALL MPI_Wtime")
		prototypes = Replace(prototypes, "double MPI_Wtick", "EXPORT_MPI_API double MPI_CALL MPI_Wtick")
		str = ReplaceBetweenTags(str, "#ifndef MPICH_SUPPRESS_PROTOTYPES", "MPI_Send", "#endif /* MPICH_SUPPRESS_PROTOTYPES */", prototypes & "#endif /* MPICH_SUPPRESS_PROTOTYPES */")
	end if
	' add dllspec and calling convention to the PMPI api
	first_index = InStr(str, "#if !defined(MPI_BUILD_PROFILING)")
	last_index = InStr(str, "#endif  /* MPI_BUILD_PROFILING */")
	if first_index <> 0 and last_index <> 0 then
		prototypes = Mid(str, first_index, last_index - first_index)
		prototypes = Replace(prototypes, "int PMPI_", "EXPORT_MPI_API int MPI_CALL PMPI_")
		prototypes = Replace(prototypes, "double PMPI_Wtime", "EXPORT_MPI_API double MPI_CALL PMPI_Wtime")
		prototypes = Replace(prototypes, "double PMPI_Wtick", "EXPORT_MPI_API double MPI_CALL PMPI_Wtick")
		str = ReplaceBetweenTags(str, "#if", "MPI_BUILD_PROFILING", "#endif  /* MPI_BUILD_PROFILING */", prototypes & "#endif  /* MPI_BUILD_PROFILING */")
	end if
	DecorateMPIFuncs = str
End Function

'
' Generate mpi.h
'
'if bWin64 then
	if not f.FolderExists("src\include\win64") then
		f.CreateFolder("src\include\win64")
	end if
	cEcho "Creating src\include\win64\mpi.h"
	set fout64 = f.CreateTextFile("src\include\win64\mpi.h")
'else
	if not f.FolderExists("src\include\win32") then
		f.CreateFolder("src\include\win32")
	end if
	cEcho "Creating src\include\win32\mpi.h"
	set fout32 = f.CreateTextFile("src\include\win32\mpi.h")
'end if
set fin = f.OpenTextFile("src\include\mpi.h.in")

contents32 = fin.ReadAll()
contents64 = contents32
fin.Close()
contents32 = ReplaceAts(contents32, false, false)
contents64 = ReplaceAts(contents64, false, true)
if bAddDllDecoration then
	contents32 = DecorateMPIFuncs(contents32)
	contents64 = DecorateMPIFuncs(contents64)
'	' uncomment out the HAVE_EXPORTS_MPI_API block
'	'contents = ReplaceBetweenTags(contents, "/*", "HAVE_EXPORT_MPI_API", "*/", "#ifdef MPICH2_STATIC_LIBRARY" & vbCrLf & "#define EXPORT_MPI_API" & vbCrLf & "#else" & vbCrLf & "#ifdef MPICH2_EXPORTS" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllexport)" & vbCrLf & "#else" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllimport)" & vbCrLf & "#endif" & vbCrLf & "#endif" & vbCrLf & "#ifndef MPI_CALL" & vbCrLf & "#define MPI_CALL __cdecl" & vbCrLf & "#endif" & vbCrLf)
'	contents = Replace(contents, "/* --Insert Additional Definitions Here-- */", "#ifdef MPICH2_STATIC_LIBRARY" & vbCrLf & "#define EXPORT_MPI_API" & vbCrLf & "#else" & vbCrLf & "#ifdef MPICH2_EXPORTS" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllexport)" & vbCrLf & "#else" & vbCrLf & "#define EXPORT_MPI_API __declspec(dllimport)" & vbCrLf & "#endif" & vbCrLf & "#endif" & vbCrLf & "#ifndef MPI_CALL" & vbCrLf & "#define MPI_CALL __cdecl" & vbCrLf & "#endif" & vbCrLf)
'	' add dllspec and calling convention to the MPI api
'	first_index = InStr(contents, "#ifndef MPICH_SUPPRESS_PROTOTYPES")
'	last_index = InStr(contents, "#endif /* MPICH_SUPPRESS_PROTOTYPES */")
'	if first_index <> 0 and last_index <> 0 then
'		prototypes = Mid(contents, first_index, last_index - first_index)
'		prototypes = Replace(prototypes, "int MPI_", "EXPORT_MPI_API int MPI_CALL MPI_")
'		prototypes = Replace(prototypes, "double PMPI_Wtime", "EXPORT_MPI_API double MPI_CALL PMPI_Wtime")
'		prototypes = Replace(prototypes, "double PMPI_Wtick", "EXPORT_MPI_API double MPI_CALL PMPI_Wtick")
'		prototypes = Replace(prototypes, "double MPI_Wtime", "EXPORT_MPI_API double MPI_CALL MPI_Wtime")
'		prototypes = Replace(prototypes, "double MPI_Wtick", "EXPORT_MPI_API double MPI_CALL MPI_Wtick")
'		contents = ReplaceBetweenTags(contents, "#ifndef MPICH_SUPPRESS_PROTOTYPES", "MPI_Send", "#endif /* MPICH_SUPPRESS_PROTOTYPES */", prototypes & "#endif /* MPICH_SUPPRESS_PROTOTYPES */")
'	end if
'	' add dllspec and calling convention to the PMPI api
'	first_index = InStr(contents, "#if !defined(MPI_BUILD_PROFILING)")
'	last_index = InStr(contents, "#endif  /* MPI_BUILD_PROFILING */")
'	if first_index <> 0 and last_index <> 0 then
'		prototypes = Mid(contents, first_index, last_index - first_index)
'		prototypes = Replace(prototypes, "int PMPI_", "EXPORT_MPI_API int MPI_CALL PMPI_")
'		prototypes = Replace(prototypes, "double PMPI_Wtime", "EXPORT_MPI_API double MPI_CALL PMPI_Wtime")
'		prototypes = Replace(prototypes, "double PMPI_Wtick", "EXPORT_MPI_API double MPI_CALL PMPI_Wtick")
'		contents = ReplaceBetweenTags(contents, "#if", "MPI_BUILD_PROFILING", "#endif  /* MPI_BUILD_PROFILING */", prototypes & "#endif  /* MPI_BUILD_PROFILING */")
'	end if
end if
fout32.Write(contents32)
fout64.Write(contents64)
fout32.Close()
fout64.Close()

Function internalFindCFiles(ByRef key, ByRef files, folder)
	For Each sub_folder in folder.SubFolders
		internalFindCFiles key, files, sub_folder
	Next
	For Each file in folder.Files
		If Right(file.Name, 2) = ".c" Then
			files.Add key, file.Path
			key = key + 1
		End If
	Next
End Function
Function FindCFiles(ByRef files, folder)
	files.RemoveAll()
	key = 0
	internalFindCFiles key, files, folder
End Function

' Add the dll decorations to the source files
if bAddDllDecoration then
	set c_files = CreateObject("Scripting.Dictionary")
	FindCFiles c_files, f.GetFolder("src\mpi")
	' replace "int MPI_" with "EXPORT_MPI_API int MPI_CALL MPI_"
	' fixup MPI_Fint MPI_
	a = c_files.Items
	If c_files.Count > 0 Then
		For i = 0 to c_files.Count - 1
			'cEcho a(i)
			set fin = f.OpenTextFile(a(i))
			contents = fin.ReadAll()
			fin.Close()
			new_contents = Replace(contents, "int MPI_", "EXPORT_MPI_API int MPI_CALL MPI_")
			new_contents = Replace(new_contents, "MPI_FEXPORT_MPI_API int", "EXPORT_MPI_API MPI_Fint")
			if new_contents <> contents then
				'cEcho new_contents
				cEcho "Modifying file: " & a(i)
				set fout = f.CreateTextFile(a(i))
				fout.Write(new_contents)
				fout.Close()
			end if
		Next
	End If
end if

Function FindMPIFuncs()
	Dim index, index2, right_str, result
	set c_files = CreateObject("Scripting.Dictionary")
	FindCFiles c_files, f.GetFolder("src\mpi")
	' replace "int MPI_" with "EXPORT_MPI_API int MPI_CALL MPI_"
	' fixup MPI_Fint MPI_
	a = c_files.Items
	If c_files.Count > 0 Then
		For i = 0 to c_files.Count - 1
			'cEcho a(i)
			set fin = f.OpenTextFile(a(i))
			contents = fin.ReadAll()
			fin.Close()
			index = InStr(contents, "int MPI_")
			If index <> 0 Then
				right_str = Right(contents, Len(contents) - index + 1)
				index2 = InStr(right_str, ")")
				If index2 <> 0 Then
					If Mid(contents, index-5, 5) = "MPI_F" then
						result = "MPI_F"
					else
						result = ""
					end if
					result = result & Left(right_str, index2) & vbCrLf & "{" & vbCrLf & "    return MPI_SUCCESS;" & vbCrLf & "}" & vbCrLf
					cEcho result
				End If
			End If
		Next
	End If	
End Function

Function internalPrintFortranInterface(dir)
	Dim index, index2, right_str, result
	set c_files = CreateObject("Scripting.Dictionary")
	FindCFiles c_files, f.GetFolder(dir)
	' replace "int MPI_" with "EXPORT_MPI_API int MPI_CALL MPI_"
	' fixup MPI_Fint MPI_
	a = c_files.Items
	If c_files.Count > 0 Then
		For i = 0 to c_files.Count - 1
			'cEcho a(i)
			set fin = f.OpenTextFile(a(i))
			contents = fin.ReadAll()
			fin.Close()
			index = InStr(contents, "int MPI_")
			If index <> 0 Then
				right_str = Right(contents, Len(contents) - index + 1)
				index2 = InStr(right_str, ")")
				If index2 <> 0 Then
					If Mid(contents, index-5, 5) = "MPI_F" then
						result = "MPI_F"
					else
						result = ""
					end if
					result = result & Left(right_str, index2)' & vbCrLf & "{" & vbCrLf & "    return MPI_SUCCESS;" & vbCrLf & "}" & vbCrLf
					cEcho result
				End If
			End If
		Next
	End If	
End Function

Function PrintFortranInterface()
	internalPrintFortranInterface("src\mpi\coll")
	internalPrintFortranInterface("src\mpi\pt2pt")
	internalPrintFortranInterface("src\mpi\rma")
End Function

'Function PrintFortranInterface()
'	Dim index, index2, right_str, result
'	set c_files = CreateObject("Scripting.Dictionary")
'	FindCFiles c_files, f.GetFolder("src\binding\f77")
'	a = c_files.Items
'	If c_files.Count > 0 Then
'		For i = 0 to c_files.Count - 1
'			set fin = f.OpenTextFile(a(i))
'			contents = fin.ReadAll()
'			fin.Close()
'			index = InStrRev(contents, "FORT_DLL_SPEC void FORT_CALL mpi_")
'			If index <> 0 Then
'				right_str = Right(contents, Len(contents) - index + 1)
'				index2 = InStr(right_str, ")")
'				If index2 <> 0 Then
'					result = Left(right_str, index2)' & vbCrLf & "{" & vbCrLf & "    return MPI_SUCCESS;" & vbCrLf & "}" & vbCrLf
'					cEcho result
'				End If
'			End If
'		Next
'	End If	
'End Function

Function internalFindFCFiles(ByRef key, ByRef files, folder)
	For Each sub_folder in folder.SubFolders
		internalFindFCFiles key, files, sub_folder
	Next
	For Each file in folder.Files
		If Right(file.Name, 3) = "f.c" Then
			files.Add key, file.Path
			key = key + 1
		End If
	Next
End Function
Function FindFCFiles(ByRef files, folder)
	files.RemoveAll()
	key = 0
	internalFindFCFiles key, files, folder
End Function

Function FindStr(pattern, str)
   Dim regEx, Match, Matches           ' Create variable.
   Set regEx = New RegExp              ' Create a regular expression.
   regEx.Pattern = pattern             ' Set pattern.
   regEx.IgnoreCase = True             ' Set case insensitivity.
   regEx.Global = True                 ' Set global applicability.
   Set Matches = regEx.Execute(str)    ' Execute search.
   For Each Match in Matches           ' Return the first match
      FindStr = Match.Value
      Exit Function
   Next
   FindStr = ""
End Function

Function AddStringLengthParameters(str)
	Dim result, index, cur_arg, match, end_str
	cur_arg = 1
	result = ""
	end_str = ""
	match = FindStr("void\s*\*\s*\w+,", str)
	while match <> ""
		index = InStr(str, match)
		result = result & Left(str, index + Len(match) - 2) & " FORT_MIXED_LEN(d" & cur_arg & ")"
		end_str = end_str & " FORT_END_LEN(d" & cur_arg & ")"
		cur_arg = cur_arg + 1
		str = Right(str, Len(str) - index - Len(match) + 2)
		match = FindStr("void\s*\*\s*\w+,", str)
	wend
	AddStringLengthParameters = result & str & end_str
End Function

Function CreateStdcallFortranInterface()
	Dim index, index2, right_str, result, prototype, filename
	set c_files = CreateObject("Scripting.Dictionary")
	cEcho "Creating src\binding\f77\fprotos.h"
	set fprotos = f.CreateTextFile("src\binding\f77\fprotos.h")
	fprotos.WriteLine( "/* -*- Mode: C; c-basic-offset:4 ; -*- */" & vbNewLine & "/*" & vbNewLine & " *  (C) 2001 by Argonne National Laboratory." & vbNewLine & " *      See COPYRIGHT in top-level directory." & vbNewLine & " */" )
	fprotos.WriteLine("")
	fprotos.WriteLine("#ifndef FPROTOS_H")
	fprotos.WriteLine("#define FPROTOS_H")
	fprotos.WriteLine("")
	fprotos.WriteLine("/* fprotos.h.  Generated automatically by winconfigure.  */")
	fprotos.WriteLine("")
	'fnames = Split("MPI_Allgather MPI_Allgatherv MPI_Allreduce MPI_Alltoall MPI_Alltoallv MPI_Alltoallw MPI_Bcast MPI_Exscan MPI_Gather MPI_Gatherv MPI_Reduce MPI_Reduce_scatter MPI_Scan MPI_Scatter MPI_Scatterv MPI_Bsend MPI_Bsend_init MPI_Buffer_attach MPI_Buffer_detach MPI_Ibsend MPI_Irecv MPI_Irsend MPI_Isend MPI_Issend MPI_Recv MPI_Recv_init MPI_Rsend MPI_Rsend_init MPI_Send MPI_Sendrecv MPI_Sendrecv_replace MPI_Send_init MPI_Ssend MPI_Ssend_init MPI_Accumulate MPI_Get MPI_Put MPI_Win_create")
	fnames = Split("mpi_allgather_ +mpi_allgatherv_ +mpi_allreduce_ +mpi_alltoall_ +mpi_alltoallv_ +mpi_alltoallw_ +mpi_bcast_ +mpi_exscan_ +mpi_gather_ +mpi_gatherv_ +mpi_reduce_ +mpi_reduce_scatter_ +mpi_scan_ +mpi_scatter_ +mpi_scatterv_ +mpi_bsend_ +mpi_bsend_init_ +mpi_buffer_attach_ +mpi_buffer_detach_ +mpi_ibsend_ +mpi_irecv_ +mpi_irsend_ +mpi_isend_ +mpi_issend_ +mpi_recv_ +mpi_recv_init_ +mpi_rsend_ +mpi_rsend_init_ +mpi_send_ +mpi_sendrecv_ +mpi_sendrecv_replace_ +mpi_send_init_ +mpi_ssend_ +mpi_ssend_init_ +mpi_accumulate_ +mpi_get_ +mpi_put_ +mpi_win_create_ ", "+")
	FindFCFiles c_files, f.GetFolder("src\binding\f77")
	a = c_files.Items
	If c_files.Count > 0 Then
		For i = 0 to c_files.Count - 1
			set fin = f.OpenTextFile(a(i))
			contents = fin.ReadAll()
			fin.Close()
			found = false
			for each name in fnames
				if InStr(contents, name) then
					'cEcho "found " & name & " in: " & vbCrLf & contents
					found = true
					exit for
				end if
			next
			if found = true then
				index = InStrRev(contents, "FORT_DLL_SPEC void FORT_CALL mpi_")
				If index <> 0 Then
					result = Left(contents, index - 1)
					right_str = Right(contents, Len(contents) - index + 1)
					index2 = InStr(right_str, ")")
					If index2 <> 0 Then
						result = result & AddStringLengthParameters(Left(right_str, index2 - 1)) & Right(right_str, Len(right_str) - index2 + 1)
						result = Replace(result, "fproto.h", "fprotos.h")
						index = InStrRev(result, "FORT_DLL_SPEC void FORT_CALL mpi_")
						right_str = Right(result, Len(result) - index + 1)
						index2 = InStr(right_str, "))")
						prototype = "extern " & Left(right_str, index2 + 1) & ";"
						'prototype = Replace(prototype, "FORT_MIXED_LEN", "FORT_MIXED_LEN_DECL")
						'prototype = Replace(prototype, "FORT_END_LEN", "FORT_END_LEN_DECL")
						filename = Replace(a(i), ".c", "s.c")
						'cEcho "filename: " & filename
						'cEcho "prototype: " & prototype
						'cEcho result
						cEcho "Creating file: " & filename
						set file = f.CreateTextFile(filename)
						file.Write(result)
						file.Close()
						fprotos.WriteLine(prototype)
					End If
				End If
			End If
		Next
	End If
	fprotos.WriteLine("")
	fprotos.WriteLine("#endif")
	fprotos.Close()
End Function

'
' Generate mpichtimer.h
'

cEcho "Creating src\include\win32\mpichtimer.h"
set fout = f.CreateTextFile("src\include\win32\mpichtimer.h")
'set fin = f.OpenTextFile("src\mpi\timer\mpichtimer.h.in")
set fin = f.OpenTextFile("src\include\mpichtimer.h.in")

contents = fin.ReadAll()
contents = ReplaceAts(contents, false, false)
fout.Write(contents)
fin.Close()
fout.Close()

cEcho "Creating src\include\win64\mpichtimer.h"
set fout = f.CreateTextFile("src\include\win64\mpichtimer.h")
'set fin = f.OpenTextFile("src\mpi\timer\mpichtimer.h.in")
set fin = f.OpenTextFile("src\include\mpichtimer.h.in")


contents = fin.ReadAll()
contents = ReplaceAts(contents, false, true)
fout.Write(contents)
fin.Close()
fout.Close()

'
' Generate mpio.h
'

cEcho "Creating src\include\mpio.h"
set fout = f.CreateTextFile("src\include\mpio.h")
set fin = f.OpenTextFile("src\mpi\romio\include\mpio.h.in")

contents = fin.ReadAll()
contents = ReplaceAts(contents, false, false)
if bAddDllDecoration then
	contents = ReplaceBetweenTags(contents, "/* MPI-IO function prototypes */", "HAVE_PRAGMA_HP_SEC_DEF", "#if defined(__cplusplus)", "#if defined(__cplusplus)")
end if
fout.Write(contents)
fin.Close()
fout.Close()

'cEcho "Creating src\include\win64\mpio.h"
'set fout = f.CreateTextFile("src\include\win64\mpio.h")
'set fin = f.OpenTextFile("src\mpi\romio\include\mpio.h.in")
'
'contents = fin.ReadAll()
'contents = ReplaceAts(contents, false, true)
'if bAddDllDecoration then
'	contents = ReplaceBetweenTags(contents, "/* MPI-IO function prototypes */", "HAVE_PRAGMA_HP_SEC_DEF", "#if defined(__cplusplus)", "#if defined(__cplusplus)")
'end if
'fout.Write(contents)
'fin.Close()
'fout.Close()

'
' Generate romioconf.h
'

cEcho "Creating src\mpi\romio\adio\include\romioconf.h"
set fout = f.CreateTextFile("src\mpi\romio\adio\include\romioconf.h")

fout.WriteLine("/* -*- Mode: C; c-basic-offset:4 ; -*- */")
fout.WriteLine("/*")
fout.WriteLine(" *  (C) 2001 by Argonne National Laboratory.")
fout.WriteLine(" *      See COPYRIGHT in top-level directory.")
fout.WriteLine(" */")
fout.WriteLine("#ifndef ROMIOCONF_H")
fout.WriteLine("#define ROMIOCONF_H")
fout.WriteLine("")
fout.WriteLine("/* Define if `sys_siglist' is declared by <signal.h>.  */")
fout.WriteLine("#undef SYS_SIGLIST_DECLARED")
fout.WriteLine("")
fout.WriteLine("#undef AIO_HANDLE_IN_AIOCB")
fout.WriteLine("#undef AIO_PRIORITY_DEFAULT")
fout.WriteLine("#undef AIO_SIGNOTIFY_NONE")
fout.WriteLine("#undef AIO_SUN")
fout.WriteLine("#undef FREEBSD")
fout.WriteLine("#undef HAVE_LONG_LONG_64")
fout.WriteLine("#undef HAVE_MOUNT_NFS")
fout.WriteLine("#undef HAVE_MPI_COMBINERS")
fout.WriteLine("#undef HAVE_MPI_DARRAY_SUBARRAY")
fout.WriteLine("#ifndef HAVE_MPI_INFO")
fout.WriteLine("#define HAVE_MPI_INFO")
fout.WriteLine("#endif")
fout.WriteLine("#undef HAVE_MPI_LONG_LONG_INT")
fout.WriteLine("#undef HAVE_PRAGMA_CRI_DUP")
fout.WriteLine("#undef HAVE_PRAGMA_HP_SEC_DEF")
fout.WriteLine("#undef HAVE_PRAGMA_WEAK")
fout.WriteLine("#undef HAVE_PREAD64")
fout.WriteLine("#ifndef HAVE_STATUS_SET_BYTES")
fout.WriteLine("#define HAVE_STATUS_SET_BYTES")
fout.WriteLine("#endif")
fout.WriteLine("#ifndef HAVE_STRERROR")
fout.WriteLine("#define HAVE_STRERROR")
fout.WriteLine("#endif")
fout.WriteLine("#undef HAVE_SYSERRLIST")
fout.WriteLine("#undef HAVE_WEAK_SYMBOLS")
fout.WriteLine("#undef HFS")
fout.WriteLine("#undef HPUX")
fout.WriteLine("#undef INT_LT_POINTER")
fout.WriteLine("#undef IRIX")
fout.WriteLine("#undef LINUX")
fout.WriteLine("#ifndef MPICH")
fout.WriteLine("#define MPICH")
fout.WriteLine("#endif")
fout.WriteLine("#undef MPIHP")
fout.WriteLine("#undef MPILAM")
fout.WriteLine("#undef MPISGI")
fout.WriteLine("#undef MPI_OFFSET_IS_INT")
fout.WriteLine("#undef NEEDS_MPI_TEST")
fout.WriteLine("#undef NFS")
fout.WriteLine("#undef NO_AIO")
fout.WriteLine("#undef NO_FD_IN_AIOCB")
fout.WriteLine("#undef NO_MPI_SGI_type_is_contig")
fout.WriteLine("#undef PARAGON")
fout.WriteLine("#undef PFS")
fout.WriteLine("#undef PIOFS")
fout.WriteLine("#undef PRINT_ERR_MSG")
fout.WriteLine("#undef ROMIO_PVFS")
fout.WriteLine("#undef ROMIO_TESTFS")
fout.WriteLine("#undef SFS")
fout.WriteLine("#undef SOLARIS")
fout.WriteLine("#undef SPPUX")
fout.WriteLine("#undef SX4")
fout.WriteLine("#undef UFS")
fout.WriteLine("#undef XFS")
fout.WriteLine("")
fout.WriteLine("#ifndef ROMIO_NTFS")
fout.WriteLine("#define ROMIO_NTFS")
fout.WriteLine("#endif")
fout.WriteLine("#ifndef HAVE_INT64")
fout.WriteLine("#define HAVE_INT64 1")
fout.WriteLine("#endif")
fout.WriteLine("")
fout.WriteLine("#ifndef HAS_MPIR_ERR_SETMSG")
fout.WriteLine("#define HAS_MPIR_ERR_SETMSG")
fout.WriteLine("#endif")
fout.WriteLine("")
fout.WriteLine("#ifndef FORTRANDOUBLEUNDERSCORE")
fout.WriteLine("#define FORTRANCAPS")
fout.WriteLine("#endif")
fout.WriteLine("")
fout.WriteLine("#endif")

fout.Close()


Function BuildIFaces()

	Dim WshShell
	set f = WScript.CreateObject("Scripting.FileSystemObject")

	'
	' Generate mpicxx.h
	'
	If bForce Or Not f.FileExists("src\binding\cxx\mpicxx.h.in") Then

		Set WshShell = CreateObject("WScript.Shell")
		WshShell.CurrentDirectory = "src\binding\cxx"
		cEcho WshShell.CurrentDirectory & ">perl buildiface -nosep"
		WshShell.Run "perl buildiface -nosep", 0, true
		WshShell.CurrentDirectory = "..\..\.."
	
	End If

	If f.FileExists("src\binding\cxx\mpicxx.h.in") Then
	
	  set fin = f.OpenTextFile("src\binding\cxx\mpicxx.h.in")
	  cEcho "Creating src\include\mpicxx.h"
	  set fout = f.CreateTextFile("src\include\mpicxx.h")
	  contents = fin.ReadAll()
	  contents = ReplaceAts(contents, false, false)
	  if bCleanCode then
		cEcho "modifying the comm, win datatype classes to handle unreferenced variables."
		' Comm class
		contents = ReplaceBetweenTags(contents, "int", "NULL_COPY_FN( const Comm &oldcomm", "}", "int NULL_COPY_FN( const Comm &oldcomm, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldcomm; keyval; ex; attr_in; attr_out; flag = 1; return 0; }")
		contents = ReplaceBetweenTags(contents, "int", "NULL_DELETE_FN( Comm &comm", "}", "int NULL_DELETE_FN( Comm &comm, int keyval, void * attr, void *ex ) { comm; keyval; attr; ex; return 0; }")
		contents = ReplaceBetweenTags(contents, "int", "DUP_FN( const Comm &oldcomm", "}", "int DUP_FN( const Comm &oldcomm, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldcomm; keyval; ex; flag = 1; *(void **)attr_out = attr_in; return 0; }")
		' Win class
		contents = ReplaceBetweenTags(contents, "int", "NULL_COPY_FN( const Win &oldwin", "}", "int NULL_COPY_FN( const Win &oldwin, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldwin; keyval; ex; attr_in; attr_out; flag = 1; return 0; }")
		contents = ReplaceBetweenTags(contents, "int", "NULL_DELETE_FN( Win &win", "}", "int NULL_DELETE_FN( Win &win, int keyval, void * attr, void *ex ) { win; keyval; attr; ex; return 0; }")
		contents = ReplaceBetweenTags(contents, "int", "DUP_FN( const Win &oldwin", "}", "int DUP_FN( const Win &oldwin, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldwin; keyval; ex; flag = 1; *(void **)attr_out = attr_in; return 0; }")
		' Datatype class
		contents = ReplaceBetweenTags(contents, "int", "NULL_COPY_FN( const Datatype &oldtype", "}", "int NULL_COPY_FN( const Datatype &oldtype, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldtype; keyval; ex; attr_in; attr_out; flag = 1; return 0; }")
		contents = ReplaceBetweenTags(contents, "int", "NULL_DELETE_FN( Datatype &type", "}", "int NULL_DELETE_FN( Datatype &type, int keyval, void * attr, void *ex ) { type; keyval; attr; ex; return 0; }")
		contents = ReplaceBetweenTags(contents, "int", "DUP_FN( const Datatype &oldtype", "}", "int DUP_FN( const Datatype &oldtype, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldtype; keyval; ex; flag = 1; *(void **)attr_out = attr_in; return 0; }")
	  end if	
	  fout.Write(contents)
	  fin.Close()
	  fout.Close()
	
'	  set fin = f.OpenTextFile("src\binding\cxx\mpicxx.h.in")
'	  cEcho "Creating src\include\win64\mpicxx.h"
'	  set fout = f.CreateTextFile("src\include\win64\mpicxx.h")
'	  contents = fin.ReadAll()
'	  contents = ReplaceAts(contents, false, true)
'	  if bCleanCode then
'		' Comm class
'		contents = ReplaceBetweenTags(contents, "int", "NULL_COPY_FN( const Comm &oldcomm", "}", "int NULL_COPY_FN( const Comm &oldcomm, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldcomm; keyval; ex; attr_in; attr_out; flag = 1; return 0; }")
'		contents = ReplaceBetweenTags(contents, "int", "NULL_DELETE_FN( Comm &comm", "}", "int NULL_DELETE_FN( Comm &comm, int keyval, void * attr, void *ex ) { comm; keyval; attr; ex; return 0; }")
'		contents = ReplaceBetweenTags(contents, "int", "DUP_FN( const Comm &oldcomm", "}", "int DUP_FN( const Comm &oldcomm, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldcomm; keyval; ex; flag = 1; *(void **)attr_out = attr_in; return 0; }")
'		' Win class
'		contents = ReplaceBetweenTags(contents, "int", "NULL_COPY_FN( const Win &oldwin", "}", "int NULL_COPY_FN( const Win &oldwin, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldwin; keyval; ex; attr_in; attr_out; flag = 1; return 0; }")
'		contents = ReplaceBetweenTags(contents, "int", "NULL_DELETE_FN( Win &win", "}", "int NULL_DELETE_FN( Win &win, int keyval, void * attr, void *ex ) { win; keyval; attr; ex; return 0; }")
'		contents = ReplaceBetweenTags(contents, "int", "DUP_FN( const Win &oldwin", "}", "int DUP_FN( const Win &oldwin, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldwin; keyval; ex; flag = 1; *(void **)attr_out = attr_in; return 0; }")
'		' Datatype class
'		contents = ReplaceBetweenTags(contents, "int", "NULL_COPY_FN( const Datatype &oldtype", "}", "int NULL_COPY_FN( const Datatype &oldtype, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldtype; keyval; ex; attr_in; attr_out; flag = 1; return 0; }")
'		contents = ReplaceBetweenTags(contents, "int", "NULL_DELETE_FN( Datatype &type", "}", "int NULL_DELETE_FN( Datatype &type, int keyval, void * attr, void *ex ) { type; keyval; attr; ex; return 0; }")
'		contents = ReplaceBetweenTags(contents, "int", "DUP_FN( const Datatype &oldtype", "}", "int DUP_FN( const Datatype &oldtype, int keyval, void *ex, void *attr_in, void *attr_out, bool &flag ) { oldtype; keyval; ex; flag = 1; *(void **)attr_out = attr_in; return 0; }")
'	  end if	
'	  fout.Write(contents)
'	  fin.Close()
'	  fout.Close()

	Else
	
	  WScript.Echo("Run ""perl buildiface -nosep"" from the src\binding\cxx directory before running winconfigure")
	  
	End IF
	
	
	'
	' Generate mpimcxx.h
	'
	If bMcxx Then
	
		If bForce Or Not f.FileExists("src\binding\mcxx\mpimcxx.h.in") Then
	
			Set WshShell = CreateObject("WScript.Shell")
			WshShell.CurrentDirectory = "src\binding\mcxx"
			cEcho WshShell.CurrentDirectory & ">perl buildiface -nosep"
			WshShell.Run "perl buildiface -nosep", 0, true
			WhShell.CurrentDirectory = "..\..\.."
	
		End If
	
		If f.FileExists("src\binding\mcxx\mpimcxx.h.in") Then

			set fin = f.OpenTextFile("src\binding\mcxx\mpimcxx.h.in")
			cEcho "Creating src\include\mpimcxx.h"
			set fout = f.CreateTextFile("src\include\mpimcxx.h")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

'			set fin = f.OpenTextFile("src\binding\mcxx\mpimcxx.h.in")
'			cEcho "Creating src\include\mpimcxx64.h"
'			set fout = f.CreateTextFile("src\include\mpimcxx64.h")
'			contents = fin.ReadAll()
'			contents = ReplaceAts(contents, false, true)
'			fout.Write(contents)
'			fin.Close()
'			fout.Close()

		Else
	
			WScript.Echo("Run ""perl buildiface -nosep"" from the src\binding\mcxx directory before running winconfigure")
	  
		End If
		
	End If

	If Not bRemoveFortran Then
		'
		' Generate mpif.h
		'
		If bForce Or Not f.FileExists("src\binding\f77\mpif.h.in") Then

			Set WshShell = CreateObject("WScript.Shell")
			WshShell.CurrentDirectory = "src\binding\f77"
			cEcho WshShell.CurrentDirectory & ">perl buildiface"
			WshShell.Run "perl buildiface", 0, true
			WshShell.CurrentDirectory = "..\..\.."

		End If

		If f.FileExists("src\binding\f77\mpif.h.in") Then

			set fin = f.OpenTextFile("src\binding\f77\mpif.h.in")
			cEcho "Creating src\include\win32\mpif.h"
			set fout = f.CreateTextFile("src\include\win32\mpif.h")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, true, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

			set fin = f.OpenTextFile("src\binding\f77\mpif.h.in")
			cEcho "Creating src\include\win64\mpif.h"
			set fout = f.CreateTextFile("src\include\win64\mpif.h")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, true, true)
			fout.Write(contents)
			fin.Close()
			fout.Close()

		Else
	
			WScript.Echo("Run ""perl buildiface"" from the src\binding\f77 directory before running winconfigure")
	
		End If

		'
		' Create the string versions of the fortran interface necessitated by the stdcall calling convention
		'
		CreateStdcallFortranInterface()
		
		'
		' Generate setbotf.f
		'
		If f.FileExists("src\binding\f77\setbotf.f.in") Then

			set fin = f.OpenTextFile("src\binding\f77\setbotf.f.in")
			cEcho "Creating src\binding\f77\setbotf.f"
			set fout = f.CreateTextFile("src\binding\f77\setbotf.f")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, true, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

'			set fin = f.OpenTextFile("src\binding\f77\setbotf.f.in")
'			cEcho "Creating src\binding\f77\setbotf64.f"
'			set fout = f.CreateTextFile("src\binding\f77\setbotf64.f")
'			contents = fin.ReadAll()
'			contents = ReplaceAts(contents, true, true)
'			fout.Write(contents)
'			fin.Close()
'			fout.Close()
			
		Else
			cEcho "Skipping file: src\binding\f77\setbotf.f"
		End If

		'
		' Generate F90 module files
		'
		If bForce Or Not f.FileExists("src\binding\f90\mpi.f90") Then

			Set WshShell = CreateObject("WScript.Shell")
			WshShell.CurrentDirectory = "src\binding\f90"
			cEcho WshShell.CurrentDirectory & ">perl buildiface"
			WshShell.Run "perl buildiface", 0, true
			WshShell.CurrentDirectory = "..\..\.."

		End If

		If Not f.FileExists("src\binding\f90\mpi.f90") Then

			WScript.Echo("Run ""perl buildiface"" from the src\binding\f90 directory to generate the F90 modules")

		End If
	
	End If

End Function

BuildIFaces()

'
' Generate defmsg.h
'
'Function RunCmd(cmd_line)
'	Set oExec = WshShell.Exec("cmd /C " & cmd_line & " 2>&1")
'	cmd_output = oExec.StdOut.ReadAll()
'	RunCmd = cmd_output
'End Function
Function RunCmd(cmd_line)
	Dim results(2)
	Set WshShell = CreateObject("WScript.Shell")
	cEcho WshShell.CurrentDirectory & ">" & cmd_line
	Set oExec = WshShell.Exec(cmd_line)
	cmd_output = ""
    err_output = ""
	If Not oExec.StdOut.AtEndOfStream Then
		cmd_output = cmd_output & oExec.StdOut.ReadAll
	End If
    If Not oExec.StdErr.AtEndOfStream Then
		err_output = err_output & oExec.StdErr.ReadAll
	End If
    Do While oExec.Status <> 1
        WScript.Sleep 10
    Loop
    results(0) = cmd_output
    results(1) = err_output
    RunCmd = results
End Function

Function RemoveWarnings(str)
	lines = Split(str, vbCrLf)
	result = ""
	for each line in lines
		line = Trim(line)
		if Len(line) > 0 and (not Left(line, 7) = "Warning") then
			result = result & line & vbCrLf
		end if
	next
	RemoveWarnings = result
End Function

Function GenerateDefmsg()
	set f = WScript.CreateObject("Scripting.FileSystemObject")
	set fin = f.OpenTextFile("maint\errmsgdirs")
	contents = fin.ReadAll()
	fin.Close()
	contents = Trim(contents)
	contents = Replace(contents, "/", "\")
	contents = Replace(contents, vbCrLf, "")
	cmd_line = "perl maint\extracterrmsgs -skip=src\util/multichannel/mpi.c " & contents
	'WScript.Echo(cmd_line)
	output = RunCmd(cmd_line)
	output(1) = RemoveWarnings(output(1))
	If Len(output(1)) > 0 Then
		WScript.Echo(output(1))
		WScript.Echo("Because of errors in extracting error messages, the file src\mpi\errhan\defmsg.h was not updated.")
	Else
		set fout = f.OpenTextFile("src\mpi\errhan\defmsg.h", 2, True)
		fout.Write(output(0))
		fout.Close()
	End If
End Function

If bForce Then
	GenerateDefmsg()
End If

'
' Generate mpiallstates.h and describe_states.c
'
Function GenerateStatesFiles()
	set f = WScript.CreateObject("Scripting.FileSystemObject")
	If f.FileExists("maint\genstates.in") Then

		set fin = f.OpenTextFile("maint\genstates.in")
		cEcho "Creating maint\genstates"
		set fout = f.CreateTextFile("maint\genstates")
		contents = fin.ReadAll()
		contents = Replace(contents, "@PERL@", "perl")
		fout.Write(contents)
		fin.Close()
		fout.Close()
		Set WshShell = CreateObject("WScript.Shell")
		cEcho WshShell.CurrentDirectory & ">perl maint\genstates"
		WshShell.Run "perl maint\genstates", 0, true

	Else

		If InStr(1, LCase(WScript.FullName), "cscript") > 0 Then
			WScript.Echo("Missing file: maint\genstates.in")
		End If
  
	End If

End Function

If bForce Then
	GenerateStatesFiles()
End If

'
' Validate .in files
'

Function RegExpFind(pattern, str)
   Dim regEx, Match, Matches           ' Create variable.
   Set regEx = New RegExp              ' Create a regular expression.
   regEx.Pattern = pattern             ' Set pattern.
   regEx.IgnoreCase = True             ' Set case insensitivity.
   regEx.Global = True                 ' Set global applicability.
   Set Matches = regEx.Execute(str)    ' Execute search.
   For Each Match in Matches           ' Return the first match
      RegExpFind = Match.Value
      Exit For
   Next
End Function

Function ReplaceAts( str, use_f77, b64 )
	Dim regEx, Match, Matches
	Set regEx = New RegExp
	regEx.Pattern = "@.*@"
	regEx.IgnoreCase = True
	regEx.Global = True
	Set Matches = regEx.Execute(str)
	For Each Match in Matches
		Select Case Match
			Case "@MPI_CHAR@"
				str = Replace(str, "@MPI_CHAR@", MPI_CHAR)
			Case "@MPI_SIGNED_CHAR@"
				str = Replace(str, "@MPI_SIGNED_CHAR@", MPI_SIGNED_CHAR)
			Case "@MPI_WCHAR@"
				str = Replace(str, "@MPI_WCHAR@", MPI_WCHAR)
			Case "@MPI_UNSIGNED_CHAR@"
				str = Replace(str, "@MPI_UNSIGNED_CHAR@", MPI_UNSIGNED_CHAR)
			Case "@MPI_SHORT@"
				str = Replace(str, "@MPI_SHORT@", MPI_SHORT)
			Case "@MPI_UNSIGNED_SHORT@"
				str = Replace(str, "@MPI_UNSIGNED_SHORT@", MPI_UNSIGNED_SHORT)
			Case "@MPI_INT@"
				str = Replace(str, "@MPI_INT@", MPI_INT)
			Case "@MPI_UNSIGNED@"
				str = Replace(str, "@MPI_UNSIGNED@", MPI_UNSIGNED)
			Case "@MPI_UNSIGNED_INT@"
				str = Replace(str, "@MPI_UNSIGNED_INT@", MPI_UNSIGNED)
			Case "@MPI_LONG@"
				str = Replace(str, "@MPI_LONG@", MPI_LONG)
			Case "@MPI_UNSIGNED_LONG@"
				str = Replace(str, "@MPI_UNSIGNED_LONG@", MPI_UNSIGNED_LONG)
			Case "@MPI_LONG_LONG@"
				str = Replace(str, "@MPI_LONG_LONG@", MPI_LONG_LONG)
			Case "@MPI_UNSIGNED_LONG_LONG@"
				str = Replace(str, "@MPI_UNSIGNED_LONG_LONG@", MPI_UNSIGNED_LONG_LONG)
			Case "@MPI_FLOAT@"
				str = Replace(str, "@MPI_FLOAT@", MPI_FLOAT)
			Case "@MPI_DOUBLE@"
				str = Replace(str, "@MPI_DOUBLE@", MPI_DOUBLE)
			Case "@MPI_LONG_DOUBLE@"
				str = Replace(str, "@MPI_LONG_DOUBLE@", MPI_LONG_DOUBLE)
			Case "@MPI_BYTE@"
				If use_f77 Then
					str = Replace(str, "@MPI_BYTE@", F77_MPI_BYTE)
				Else
					str = Replace(str, "@MPI_BYTE@", MPI_BYTE)
				End If
			Case "@MPI_WCHAR_T@"
				str = Replace(str, "@MPI_WCHAR_T@", MPI_WCHAR_T)
			Case "@MPI_PACKED@"
				If use_f77 Then
					str = Replace(str, "@MPI_PACKED@", F77_MPI_PACKED)
				Else
					str = Replace(str, "@MPI_PACKED@", MPI_PACKED)
				End If
			Case "@MPI_LB@"
				If use_f77 Then
					str = Replace(str, "@MPI_LB@", F77_MPI_LB)
				Else
					str = Replace(str, "@MPI_LB@", MPI_LB)
				End If
			Case "@MPI_UB@"
				If use_f77 Then
					str = Replace(str, "@MPI_UB@", F77_MPI_UB)
				Else
					str = Replace(str, "@MPI_UB@", MPI_UB)
				End If
			Case "@MPI_FLOAT_INT@"
				str = Replace(str, "@MPI_FLOAT_INT@", MPI_FLOAT_INT)
			Case "@MPI_DOUBLE_INT@"
				str = Replace(str, "@MPI_DOUBLE_INT@", MPI_DOUBLE_INT)
			Case "@MPI_LONG_INT@"
				str = Replace(str, "@MPI_LONG_INT@", MPI_LONG_INT)
			Case "@MPI_SHORT_INT@"
				str = Replace(str, "@MPI_SHORT_INT@", MPI_SHORT_INT)
			Case "@MPI_2INT@"
				str = Replace(str, "@MPI_2INT@", MPI_2INT)
			Case "@MPI_LONG_DOUBLE_INT@"
				str = Replace(str, "@MPI_LONG_DOUBLE_INT@", MPI_LONG_DOUBLE_INT)
			Case "@MPI_CHARACTER@"
				If use_f77 Then
					str = Replace(str, "@MPI_CHARACTER@", F77_MPI_CHARACTER)
				Else
					str = Replace(str, "@MPI_CHARACTER@", MPI_CHARACTER)
				End If
			Case "@MPI_INTEGER@"
				If b64 then
					If use_f77 Then
						str = Replace(str, "@MPI_INTEGER@", F77_MPI_INTEGER_W64)
					Else
						str = Replace(str, "@MPI_INTEGER@", MPI_INTEGER_W64)
					End If
				Else
					If use_f77 Then
						str = Replace(str, "@MPI_INTEGER@", F77_MPI_INTEGER_W32)
					Else
						str = Replace(str, "@MPI_INTEGER@", MPI_INTEGER_W32)
					End If
				End If
			Case "@MPI_REAL@"
				If b64 Then
					If use_f77 Then
						str = Replace(str, "@MPI_REAL@", F77_MPI_REAL_W64)
					Else
						str = Replace(str, "@MPI_REAL@", MPI_REAL_W64)
					End If
				Else
					If use_f77 Then
						str = Replace(str, "@MPI_REAL@", F77_MPI_REAL_W32)
					Else
						str = Replace(str, "@MPI_REAL@", MPI_REAL_W32)
					End If
				End If
			Case "@MPI_LOGICAL@"
				If b64 Then
					If use_f77 Then
						str = Replace(str, "@MPI_LOGICAL@", F77_MPI_LOGICAL_W64)
					Else
						str = Replace(str, "@MPI_LOGICAL@", MPI_LOGICAL_W64)
					End If
				Else
					If use_f77 Then
						str = Replace(str, "@MPI_LOGICAL@", F77_MPI_LOGICAL_W32)
					Else
						str = Replace(str, "@MPI_LOGICAL@", MPI_LOGICAL_W32)
					End If
				End If
			Case "@MPI_COMPLEX@"
				If use_f77 Then
					str = Replace(str, "@MPI_COMPLEX@", F77_MPI_COMPLEX)
				Else
					str = Replace(str, "@MPI_COMPLEX@", MPI_COMPLEX)
				End If
			Case "@MPI_DOUBLE_PRECISION@"
				If use_f77 Then
					str = Replace(str, "@MPI_DOUBLE_PRECISION@", F77_MPI_DOUBLE_PRECISION)
				Else
					str = Replace(str, "@MPI_DOUBLE_PRECISION@", MPI_DOUBLE_PRECISION)
				End If
			Case "@MPI_2INTEGER@"
				If use_f77 Then
					str = Replace(str, "@MPI_2INTEGER@", F77_MPI_2INTEGER)
				Else
					str = Replace(str, "@MPI_2INTEGER@", MPI_2INTEGER)
				End If
			Case "@MPI_2REAL@"
				If use_f77 Then
					str = Replace(str, "@MPI_2REAL@", F77_MPI_2REAL)
				Else
					str = Replace(str, "@MPI_2REAL@", MPI_2REAL)
				End If
			Case "@MPI_DOUBLE_COMPLEX@"
				If use_f77 Then
					str = Replace(str, "@MPI_DOUBLE_COMPLEX@", F77_MPI_DOUBLE_COMPLEX)
				Else
					str = Replace(str, "@MPI_DOUBLE_COMPLEX@", MPI_DOUBLE_COMPLEX)
				End If
			Case "@MPI_2DOUBLE_PRECISION@"
				If use_f77 Then
					str = Replace(str, "@MPI_2DOUBLE_PRECISION@", F77_MPI_2DOUBLE_PRECISION)
				Else
					str = Replace(str, "@MPI_2DOUBLE_PRECISION@", MPI_2DOUBLE_PRECISION)
				End If
			Case "@MPI_2COMPLEX@"
				If use_f77 Then
					str = Replace(str, "@MPI_2COMPLEX@", F77_MPI_2COMPLEX)
				else
					str = Replace(str, "@MPI_2COMPLEX@", MPI_2COMPLEX)
				End If
			Case "@MPI_2DOUBLE_COMPLEX@"
				if use_f77 Then
					str = Replace(str, "@MPI_2DOUBLE_COMPLEX@", F77_MPI_2DOUBLE_COMPLEX)
				Else
					str = Replace(str, "@MPI_2DOUBLE_COMPLEX@", MPI_2DOUBLE_COMPLEX)
				End If
			Case "@MPI_MAX_PROCESSOR_NAME@"
				str = Replace(str, "@MPI_MAX_PROCESSOR_NAME@", MPI_MAX_PROCESSOR_NAME)
			Case "@BSEND_OVERHEAD@"
				if b64 then
					str = Replace(str, "@BSEND_OVERHEAD@", BSEND_OVERHEAD64)
				else
					str = Replace(str, "@BSEND_OVERHEAD@", BSEND_OVERHEAD32)
				end if
			Case "@MPI_AINT@"
				if b64 then
					str = Replace(str, "@MPI_AINT@", MPI_AINT64)
				else
					str = Replace(str, "@MPI_AINT@", MPI_AINT32)
				end if
			Case "@MPI_FINT@"
				str = Replace(str, "@MPI_FINT@", MPI_FINT)
			Case "@MPI_OFFSET@"
				str = Replace(str, "@MPI_OFFSET@", MPI_OFFSET)
			Case "@MPI_OFFSET_TYPEDEF@"
				str = Replace(str, "@MPI_OFFSET_TYPEDEF@", MPI_OFFSET_TYPEDEF)
			Case "@EXTRA_STATUS_DECL@"
				str = Replace(str, "@EXTRA_STATUS_DECL@", EXTRA_STATUS_DECL)
			Case "@HAVE_ROMIO@"
				str = Replace(str, "@HAVE_ROMIO@", HAVE_ROMIO)
			Case "@MPI_REAL4@"
				str = Replace(str, "@MPI_REAL4@", MPI_REAL4)
			Case "@MPI_REAL8@"
				str = Replace(str, "@MPI_REAL8@", MPI_REAL8)
			Case "@MPI_REAL16@"
				str = Replace(str, "@MPI_REAL16@", MPI_REAL16)
			Case "@MPI_COMPLEX8@"
				str = Replace(str, "@MPI_COMPLEX8@", MPI_COMPLEX8)
			Case "@MPI_COMPLEX16@"
				str = Replace(str, "@MPI_COMPLEX16@", MPI_COMPLEX16)
			Case "@MPI_COMPLEX32@"
				str = Replace(str, "@MPI_COMPLEX32@", MPI_COMPLEX32)
			Case "@MPI_INTEGER1@"
				str = Replace(str, "@MPI_INTEGER1@", MPI_INTEGER1)
			Case "@MPI_INTEGER2@"
				str = Replace(str, "@MPI_INTEGER2@", MPI_INTEGER2)
			Case "@MPI_INTEGER4@"
				str = Replace(str, "@MPI_INTEGER4@", MPI_INTEGER4)
			Case "@MPI_INTEGER8@"
				str = Replace(str, "@MPI_INTEGER8@", MPI_INTEGER8)
			Case "@MPI_INTEGER16@"
				str = Replace(str, "@MPI_INTEGER16@", MPI_INTEGER16)
			Case "@MPICH_TIMER_KIND@"
				If bUseCycleCounter Then
					str = Replace(str, "@MPICH_TIMER_KIND@", "USE_WIN86_CYCLE")
				Else
					str = Replace(str, "@MPICH_TIMER_KIND@", "USE_QUERYPERFORMANCECOUNTER")
				End If
			Case "@MPID_TIMER_TYPE@"
				If bUseCycleCounter Then
					str = Replace(str, "@MPID_TIMER_TYPE@", "unsigned __int64")
				Else
					str = Replace(str, "@MPID_TIMER_TYPE@", "LARGE_INTEGER")
				End If
			Case "@DEFINE_MPI_OFFSET@"
				'str = Replace(str, "@DEFINE_MPI_OFFSET@", "typedef __int64 MPI_Offset;")
				'str = Replace(str, "@DEFINE_MPI_OFFSET@", "#if defined(USE_GCC) || defined(__GNUC__)" + vbCrLf + "typedef long long MPI_Offset;" + vbCrLf + "#else" + vbCrLf + "typedef __int64 MPI_Offset;" + vbCrLf + "#endif")
				'str = Replace(str, "@DEFINE_MPI_OFFSET@", "typedef long long MPI_Offset;")
				str = Replace(str, "@DEFINE_MPI_OFFSET@", MPI_OFFSET_TYPEDEF)
			Case "@NEEDS_MPI_FINT@"
				str = Replace(str, "@NEEDS_MPI_FINT@", "")
			Case "@HAVE_MPI_INFO@"
				str = Replace(str, "@HAVE_MPI_INFO@", "#define HAVE_MPI_INFO")
			Case "@HAVE_MPI_DARRAY_SUBARRAY@"
				str = Replace(str, "@HAVE_MPI_DARRAY_SUBARRAY@", "")
			Case "@DEFINE_HAVE_MPI_GREQUEST@"
				str = Replace(str, "@DEFINE_HAVE_MPI_GREQUEST@", "#define HAVE_MPI_GREQUEST")
			Case "@ADDRESS_KIND@"
				str = Replace(str, "@ADDRESS_KIND@", "4")
			Case "@OFFSET_KIND@"
				str = Replace(str, "@OFFSET_KIND@", "4")
			Case "@F77_COMPLEX16@"
				str = Replace(str, "@F77_COMPLEX16@", F77_COMPLEX16)
			Case "@F77_COMPLEX32@"
				str = Replace(str, "@F77_COMPLEX32@", F77_COMPLEX32)
			Case "@F77_COMPLEX8@"
				str = Replace(str, "@F77_COMPLEX8@", F77_COMPLEX8)
			Case "@F77_INTEGER1@"
				str = Replace(str, "@F77_INTEGER1@", F77_INTEGER1)
			Case "@F77_INTEGER2@"
				str = Replace(str, "@F77_INTEGER2@", F77_INTEGER2)
			Case "@F77_INTEGER4@"
				str = Replace(str, "@F77_INTEGER4@", F77_INTEGER4)
			Case "@F77_INTEGER8@"
				str = Replace(str, "@F77_INTEGER8@", F77_INTEGER8)
			Case "@F77_INTEGER16@"
				str = Replace(str, "@F77_INTEGER16@", F77_INTEGER16)
			Case "@F77_REAL4@"
				str = Replace(str, "@F77_REAL4@", F77_REAL4)
			Case "@F77_REAL8@"
				str = Replace(str, "@F77_REAL8@", F77_REAL8)
			Case "@F77_REAL16@"
				str = Replace(str, "@F77_REAL16@", F77_REAL16)
			Case "@MPI_F77_BYTE@"
				str = Replace(str, "@MPI_F77_BYTE@", F77_MPI_BYTE)
			Case "@MPI_F77_UB@"
				str = Replace(str, "@MPI_F77_UB@", F77_MPI_UB)
			Case "@MPI_F77_LB@"
				str = Replace(str, "@MPI_F77_LB@", F77_MPI_LB)
			Case "@MPI_F77_PACKED@"
				str = Replace(str, "@MPI_F77_PACKED@", F77_MPI_PACKED)
			Case "@MPI_STATUS_SIZE@"
				str = Replace(str, "@MPI_STATUS_SIZE@", "5")
			Case "@HAVE_CXX_EXCEPTIONS@"
				str = Replace(str, "@HAVE_CXX_EXCEPTIONS@", "1")
			Case "@F77_MPI_ADDRESS@"
				str = Replace(str, "@F77_MPI_ADDRESS@", "INTEGER")
			Case "@F77_MPI_OFFSET@"
				str = Replace(str, "@F77_MPI_OFFSET@", "INTEGER*8")
			Case "@PCONTROL_LIST@"
				'str = Replace(str, "@PCONTROL_LIST@", "")
			Case "@configure_input@"
				'str = Replace(str, "@configure_input@", "")
			Case "@DLLIMPORT@"
				str = Replace(str, "@DLLIMPORT@", "CDEC$ ATTRIBUTES DLLIMPORT::/MPIPRIV1/" & vbNewLine & "CDEC$ ATTRIBUTES DLLIMPORT::/MPIPRIV2/" & vbNewLine & "CDEC$ ATTRIBUTES DLLIMPORT::/MPIPRIVC/")
			Case "@MPE_THREAD_TYPEDEFS@"
				str = Replace(str, "@MPE_THREAD_TYPEDEFS@", mpe_thread_typedefs)
			Case "@MPE_THREAD_FUNCS@"
				str = Replace(str, "@MPE_THREAD_FUNCS@", mpe_thread_funcs)
			Case "@MPID_THREAD_TYPEDEFS@"
				str = Replace(str, "@MPID_THREAD_TYPEDEFS@", mpid_thread_typedefs)
			Case "@MPID_THREAD_FUNCS@"
				str = Replace(str, "@MPID_THREAD_FUNCS@", mpid_thread_funcs)
			Case Else
				unhandled_ats = unhandled_ats & Match & vbNewLine
		End Select
	Next
	ReplaceAts = str
End Function

Sub AddDefinitions( fout, filename, b64 )
	If f.FileExists( filename ) Then
		Set f2 = f.OpenTextFile( filename )
		Dim regEx, Match, Matches
		Set regEx = New RegExp
		contents = f2.ReadAll()
		regEx.Pattern = "/\*.*\*/[\r\n]*#undef.*[\r\n]*"
		regEx.IgnoreCase = True
		regEx.Global = True
		Set Matches = regEx.Execute(contents)
		For Each Match in Matches
			comment = RegExpFind("/\*.*\*/", Match.Value)
			define = RegExpFind("#undef.*", Match.Value)
			define = Mid(define, 8)
			define = Replace(define, vbNewLine, " ")
			define = Replace(define, vbCr, " ")
			define = Replace(define, vbLf, " ")
			define = Trim(define)
			fout.WriteLine(comment)
			Select Case define
				Case "HAVE_INT16_T"
					fout.WriteLine("/* #undef HAVE_INT16_T */")
				Case "HAVE_INT32_T"
					fout.WriteLine("/* #undef HAVE_INT32_T */")
				Case "HAVE_INT64_T"
					fout.WriteLine("/* #undef HAVE_INT64_T */")
				Case "const"
					fout.WriteLine("/* #undef const */")
				Case "inline"
					fout.WriteLine("#define inline __inline")
				Case "STDC_HEADERS"
					fout.WriteLine("#define STDC_HEADERS 1")
				Case "SIZEOF_DOUBLE"
					fout.WriteLine("#define SIZEOF_DOUBLE 8")
				Case "SIZEOF_FLOAT"
					fout.WriteLine("#define SIZEOF_FLOAT 4")
				Case "SIZEOF_INT"
					fout.WriteLine("#define SIZEOF_INT 4")
				Case "SIZEOF_LONG"
					fout.WriteLine("#define SIZEOF_LONG 4")
				Case "SIZEOF_LONG_DOUBLE"
					fout.WriteLine("#define SIZEOF_LONG_DOUBLE 12")
				Case "SIZEOF_LONG_LONG"
					fout.WriteLine("/*#define SIZEOF_LONG_LONG 8*/")
				Case "SIZEOF_SHORT"
					fout.WriteLine("#define SIZEOF_SHORT 2")
				Case "SIZEOF_VOID_P"
					If b64 Then
						fout.WriteLine("#define SIZEOF_VOID_P 8")
					Else
						fout.WriteLine("#define SIZEOF_VOID_P 4")
					End If
				Case "SIZEOF_WCHAR_T"
					fout.WriteLine("#define SIZEOF_WCHAR_T 2")
				Case "HAVE_GETCWD"
					fout.WriteLine("#define HAVE_GETCWD 1")
				Case "HAVE_GETHOSTNAME"
					fout.WriteLine("#define HAVE_GETHOSTNAME 1")
				Case "HAVE_PUTENV"
					fout.WriteLine("#define HAVE_PUTENV 1")
				Case "HAVE_SELECT"
					fout.WriteLine("#define HAVE_SELECT 1")
				Case "HAVE_SLEEP"
					fout.WriteLine("#define HAVE_SLEEP 1")
				Case "HAVE_SOCKET"
					fout.WriteLine("#define HAVE_SOCKET 1")
				Case "HAVE_STRDUP"
					fout.WriteLine("#define HAVE_STRDUP 1")
				Case "HAVE_ERRNO_H"
					fout.WriteLine("#define HAVE_ERRNO_H 1")
				Case "HAVE_FCNTL_H"
					fout.WriteLine("#define HAVE_FCNTL_H 1")
				Case "HAVE_STDLIB_H"
					fout.WriteLine("#define HAVE_STDLIB_H 1")
				Case "HAVE_STDIO_H"
					fout.WriteLine("#define HAVE_STDIO_H")
				Case "HAVE_ERROR_CHECKING"
					fout.WriteLine("#define HAVE_ERROR_CHECKING MPID_ERROR_LEVEL_ALL")
					fout.WriteLine("/*#undef HAVE_ERROR_CHECKING*/")
				Case "HAVE_TIMING MPID_TIMING_KIND_LOG"
					fout.WriteLine("/*#define HAVE_TIMING MPID_TIMING_KIND_LOG*/")
				Case "HAVE_TIMING MPID_TIMING_KIND_ALL"
					fout.WriteLine("/*#define HAVE_TIMING MPID_TIMING_KIND_ALL*/")
				Case "USE_LOGGING MPID_LOGGING_RLOG"
					fout.WriteLine("/*#define USE_LOGGING MPID_LOGGING_RLOG*/")
				Case "USE_LOGGING MPID_LOGGING_DLOG"
					fout.WriteLine("/*#define USE_LOGGING MPID_LOGGING_DLOG*/")
				Case "MPICH_SINGLE_THREADED"
					fout.WriteLine("#define MPICH_SINGLE_THREADED ")
				Case "USE_MEMORY_TRACING"
					fout.WriteLine("/* #undef USE_MEMORY_TRACING */")
				Case "restrict"
					fout.WriteLine("#define restrict")
				Case "CHAR_PTR_IS_BYTE"
					fout.WriteLine("/* #undef CHAR_PTR_IS_BYTE */")
				Case "HAVE_GCC_AND_PENTIUM_ASM"
					fout.WriteLine("/* #undef HAVE_GCC_AND_PENTIUM_ASM */")
				Case "HAVE_INTTYPES_H"
					fout.WriteLine("/* #undef HAVE_INTTYPES_H */")
				Case "HAVE_MEMORY_H"
					fout.WriteLine("/* #undef HAVE_MEMORY_H */")
				Case "HAVE_PRAGMA_CRI_DUP"
					fout.WriteLine("/* #undef HAVE_PRAGMA_CRI_DUP */")
				Case "HAVE_PRAGMA_HP_SEC_DEF"
					fout.WriteLine("/* #undef HAVE_PRAGMA_HP_SEC_DEF */")
				Case "HAVE_PRAGMA_WEAK"
					fout.WriteLine("/* #undef HAVE_PRAGMA_WEAK */")
				Case "HAVE_PTHREAD_CREATE"
					fout.WriteLine("/* #undef HAVE_PTHREAD_CREATE */")
				Case "HAVE_STDINT_H"
					fout.WriteLine("/* #undef HAVE_STDINT_H */")
				Case "HAVE_STRINGS_H"
					fout.WriteLine("/* #undef HAVE_STRINGS_H */")
				Case "HAVE_STRING_H"
					fout.WriteLine("#define HAVE_STRING_H")
				Case "HAVE_SYS_STAT_H"
					fout.WriteLine("/* #undef HAVE_SYS_STAT_H */")
				Case "HAVE_SYS_TYPES_H"
					'fout.WriteLine("/* #undef HAVE_SYS_TYPES_H */")
					fout.WriteLine("#define HAVE_SYS_TYPES_H 1")
				Case "HAVE_THR_CREATE"
					fout.WriteLine("/* #undef HAVE_THR_CREATE */")
				Case "HAVE_TIMING"
					fout.WriteLine("/* #undef HAVE_TIMING */")
				Case "HAVE_UNISTD_H"
					fout.WriteLine("/* #undef HAVE_UNISTD_H */")
				Case "SIZEOF_INT_IS_AINT"
					fout.WriteLine("/* #undef SIZEOF_INT_IS_AINT */")
				Case "volatile"
					fout.WriteLine("/* #undef volatile */")
				Case "HAVE_GETTIMEOFDAY"
					fout.WriteLine("/*#define HAVE_GETTIMEOFDAY 1*/")
				Case "HAVE_MUTEX_INIT"
					fout.WriteLine("/* #undef HAVE_MUTEX_INIT */")
				Case "HAVE_PTHREAD_MUTEXATTR_INIT"
					fout.WriteLine("/*#define HAVE_PTHREAD_MUTEXATTR_INIT 1*/")
				Case "HAVE_PTHREAD_MUTEXATTR_SETPSHARED"
					fout.WriteLine("/*#define HAVE_PTHREAD_MUTEXATTR_SETPSHARED 1*/")
				Case "HAVE_SCHED_YIELD"
					fout.WriteLine("/*#define HAVE_SCHED_YIELD 1*/")
				Case "HAVE_SHMAT"
					fout.WriteLine("/* #undef HAVE_SHMAT */")
				Case "HAVE_SHMCTL"
					fout.WriteLine("/* #undef HAVE_SHMCTL */")
				Case "HAVE_SHMDT"
					fout.WriteLine("/* #undef HAVE_SHMDT */")
				Case "HAVE_SHMGET"
					fout.WriteLine("/* #undef HAVE_SHMGET */")
				Case "HAVE_USLEEP"
					fout.WriteLine("/*#define HAVE_USLEEP 1*/")
				Case "HAVE_YIELD"
					fout.WriteLine("/* #undef HAVE_YIELD */")
				Case "HAVE_LINUX_UNISTD_H"
					fout.WriteLine("/* #undef HAVE_LINUX_UNISTD_H */")
				Case "HAVE_NETDB_H"
					fout.WriteLine("/*#define HAVE_NETDB_H 1*/")
				Case "HAVE_NETINET_IN_H"
					fout.WriteLine("/*#define HAVE_NETINET_IN_H 1*/")
				Case "HAVE_NETINET_TCP_H"
					fout.WriteLine("/*#define HAVE_NETINET_TCP_H 1*/")
				Case "HAVE_PTHREAD_H"
					fout.WriteLine("/*#define HAVE_PTHREAD_H 1*/")
				Case "HAVE_SCHED_H"
					fout.WriteLine("/*#define HAVE_SCHED_H 1*/")
				Case "HAVE_SYS_FILIO_H"
					fout.WriteLine("/* #undef HAVE_SYS_FILIO_H */")
				Case "HAVE_SYS_IOCTL_H"
					fout.WriteLine("/*#define HAVE_SYS_IOCTL_H 1*/")
				Case "HAVE_SYS_IPC_H"
					fout.WriteLine("/* #undef HAVE_SYS_IPC_H */")
				Case "HAVE_SYS_PARAM_H"
					fout.WriteLine("/*#define HAVE_SYS_PARAM_H 1*/")
				Case "HAVE_SYS_PTRACE_H"
					fout.WriteLine("/* #undef HAVE_SYS_PTRACE_H */")
				Case "HAVE_SYS_SELECT_H"
					fout.WriteLine("/*#define HAVE_SYS_SELECT_H 1*/")
				Case "HAVE_SYS_SEM_H"
					fout.WriteLine("/* #undef HAVE_SYS_SEM_H */")
				Case "HAVE_SYS_SHM_H"
					fout.WriteLine("/* #undef HAVE_SYS_SHM_H */")
				Case "HAVE_SYS_SOCKET_H"
					fout.WriteLine("/*#define HAVE_SYS_SOCKET_H 1*/")
				Case "HAVE_SYS_TIME_H"
					fout.WriteLine("/*#define HAVE_SYS_TIME_H 1*/")
				Case "HAVE_SYS_UIO_H"
					fout.WriteLine("/*#define HAVE_SYS_UIO_H 1*/")
				Case "HAVE_SYS_WAIT_H"
					fout.WriteLine("/*#define HAVE_SYS_WAIT_H 1*/")
				Case "HAVE_VALUES_H"
					fout.WriteLine("/* #undef HAVE_VALUES_H */")
				Case "HAVE_LIBTHREAD"
					fout.WriteLine("/* #undef HAVE_LIBTHREAD */")
				Case "HAVE_ASSERT_H"
					fout.WriteLine("#define HAVE_ASSERT_H 1")
				Case "HAVE_LIMITS_H"
					fout.WriteLine("#define HAVE_LIMITS_H")
				Case "COLLECT_STATS"
					fout.WriteLine("/* #undef COLLECT_STATS */")
				Case "FILE_NAMEPUB_BASEDIR"
					fout.WriteLine("/* #undef FILE_NAMEPUB_BASEDIR */")
				Case "HAVE_CXX_BINDING"
					fout.WriteLine("#define HAVE_CXX_BINDING 1")
				Case "HAVE_DEBUGGER_SUPPORT"
					fout.WriteLine("/* #undef HAVE_DEBUGGER_SUPPORT */")
				Case "HAVE_DGETTEXT"
					fout.WriteLine("/* #undef HAVE_DGETTEXT */")
				Case "HAVE_FORTRAN_BINDING"
					fout.WriteLine("/* #undef HAVE_FORTRAN_BINDING */")
				Case "HAVE_GCC_ATTRIBUTE"
					fout.WriteLine("/* #undef HAVE_GCC_ATTRIBUTE */")
				Case "HAVE_GETTEXT"
					fout.WriteLine("/* #undef HAVE_GETTEXT */")
				Case "HAVE_LARGEST_STRUCT_ALIGNMENT"
					fout.WriteLine("/* #undef HAVE_LARGEST_STRUCT_ALIGNMENT */")
				Case "HAVE_LIBINTL_H"
					fout.WriteLine("/* #undef HAVE_LIBINTL_H */")
				Case "HAVE_LONG_DOUBLE"
					'fout.WriteLine("/* #undef HAVE_LONG_DOUBLE */")
					fout.WriteLine("#define HAVE_LONG_DOUBLE 1")
				Case "HAVE_LONG_LONG_INT"
					'fout.WriteLine("/* #undef HAVE_LONG_LONG_INT */")
					fout.WriteLine("#define HAVE_LONG_LONG_INT 1")
				Case "HAVE_MAX_STRUCT_ALIGNMENT"
					'fout.WriteLine("/* #undef HAVE_MAX_STRUCT_ALIGNMENT */")
					'If bWin64 Then
					'	fout.WriteLine("#define HAVE_MAX_STRUCT_ALIGNMENT 8")
					'Else
					'	fout.WriteLine("#define HAVE_MAX_STRUCT_ALIGNMENT 4")
					'End If
					fout.WriteLine("#define HAVE_MAX_STRUCT_ALIGNMENT 8")
				Case "HAVE_NAMEPUB_SERVICE"
					fout.WriteLine("#define HAVE_NAMEPUB_SERVICE 1")
				Case "HAVE_NO_FORTRAN_MPI_TYPES_IN_C"
					fout.WriteLine("/* #undef HAVE_NO_FORTRAN_MPI_TYPES_IN_C */")
				Case "HAVE_ROMIO"
					fout.WriteLine("/* #undef HAVE_ROMIO */")
				Case "HAVE_SEARCH"
					fout.WriteLine("/* #undef HAVE_SEARCH */")
				Case "HAVE_SNPRINTF"
					fout.WriteLine("#define HAVE_SNPRINTF")
				Case "HAVE_STDARG_H"
					fout.WriteLine("#define HAVE_STDARG_H")
				Case "HAVE_SYS_BITYPES_H"
					fout.WriteLine("/* #undef HAVE_SYS_BITYPES_H */")
				Case "HAVE_THREAD_H"
					fout.WriteLine("/* #undef HAVE_THREAD_H */")
				Case "HAVE_THR_YIELD"
					fout.WriteLine("/* #undef HAVE_THR_YIELD */")
				Case "HAVE_TSEARCH"
					fout.WriteLine("/* #undef HAVE_TSEARCH */")
				Case "HAVE_VA_COPY"
					fout.WriteLine("/* #undef HAVE_VA_COPY */")
				Case "HAVE_VSNPRINTF"
					fout.WriteLine("#define HAVE_VSNPRINTF")
				Case "HAVE_VSPRINTF"
					fout.WriteLine("#define HAVE_VSPRINTF")
				Case "MPICH_DEBUG_HANDLES"
					fout.WriteLine("/* #undef HAVE_MPICH_DEBUG_HANDLES */")
				Case "MPICH_DEBUG_INTERNAL"
					fout.WriteLine("/* #undef MPICH_DEBUG_INTERNAL */")
				Case "MPICH_DEBUG_NESTING"
					fout.WriteLine("/* #undef MPICH_DEBUG_NESTING */")
				Case "MPICH_ERROR_MSG_LEVEL"
					fout.WriteLine("#define MPICH_ERROR_MSG_LEVEL MPICH_ERROR_MSG_ALL")
				Case "MPICH_INFODLL_LOC"
					fout.WriteLine("/* #undef MPICH_INFODLL_LOC */")
				Case "MPIU_INT16_T"
					fout.WriteLine("#define MPIU_INT16_T __int16")
				Case "MPIU_INT32_T"
					fout.WriteLine("#define MPIU_INT32_T __int32")
				Case "MPIU_INT64_T"
					fout.WriteLine("#define MPIU_INT64_T __int64")
				Case "MPIU_SIZE_T"
					fout.WriteLine("#define MPIU_SIZE_T unsigned int")
				Case "NDEBUG"
					fout.WriteLine("/* #undef NDEBUG */")
				Case "NEEDS_POINTER_ALIGNMENT_ADJUST"
					fout.WriteLine("/* #undef NEEDS_POINTER_ALIGNMENT_ADJUST */")
				Case "NEEDS_SNPRINTF_DECL"
					fout.WriteLine("/* #undef NEEDS_SNPRINTF_DECL */")
				Case "NEEDS_STRDUP_DECL"
					fout.WriteLine("/* #undef NEEDS_STRDUP_DECL */")
				Case "PACKAGE_BUGREPORT"
					fout.WriteLine("/* #undef PACKAGE_BUGREPORT */")
				Case "PACKAGE_NAME"
					fout.WriteLine("/* #undef PACKAGE_NAME */")
				Case "PACKAGE_STRING"
					fout.WriteLine("/* #undef PACKAGE_STRING */")
				Case "PACKAGE_TARNAME"
					fout.WriteLine("/* #undef PACKAGE_TARNAME */")
				Case "PACKAGE_VERSION"
					fout.WriteLine("/* #undef PACKAGE_VERSION */")
				Case "USE_COVERAGE"
					fout.WriteLine("/* #undef USE_COVERAGE */")
				Case "USE_FILE_FOR_NAMEPUB"
					fout.WriteLine("/* #undef USE_FILE_FOR_NAMEPUB */")
				Case "USE_GETTEXT"
					fout.WriteLine("/* #undef USE_GETTEXT */")
				Case "USE_LDAP_FOR_NAMEPUB"
					fout.WriteLine("/* #undef USE_LDAP_FOR_NAMEPUB */")
				Case "USE_LOGGING"
					fout.WriteLine("/* #undef USE_LOGGING */")
				Case "USE_TSEARCH_WITH_CHARP"
					fout.WriteLine("/* #undef USE_TSEARCH_WITH_CHARP */")
				Case "USE_WEAK_SYMBOLS"
					fout.WriteLine("/* #undef USE_WEAK_SYMBOLS */")
				Case "HAVE_CPP_VARARGS"
					fout.WriteLine("/* #undef HAVE_CPP_VARARGS */")
				Case "HAVE_CLOCK_GETRES"
					fout.WriteLine("/* #undef HAVE_CLOCK_GETRES */")
				Case "HAVE_CLOCK_GETTIME"
					fout.WriteLine("/* #undef HAVE_CLOCK_GETTIME */")
				Case "HAVE_GETHRTIME"
					fout.WriteLine("/* #undef HAVE_GETHRTIME */")
				Case "HAVE_MPI_WIN_CREATE"
					fout.WriteLine("#define HAVE_MPI_WIN_CREATE 1")
				Case "HAVE_COMPARE_AND_SWAP"
					fout.WriteLine("/* #undef HAVE_COMPARE_AND_SWAP */")
				Case "HAVE_DLFCN_H"
					fout.WriteLine("/* #undef HAVE_DLFCN_H */")
				Case "HAVE_UUID_UUID_H"
					fout.WriteLine("/* #undef HAVE_UUID_UUID_H */")
				Case "HAVE_GCC_ASM_AND_X86_LFENCE"
					fout.WriteLine("/* #undef HAVE_GCC_ASM_AND_X86_LFENCE */")
				Case "HAVE_GCC_ASM_AND_X86_MFENCE"
					fout.WriteLine("/* #undef HAVE_GCC_ASM_AND_X86_MFENCE */")
				Case "HAVE_GCC_ASM_AND_X86_SFENCE"
					fout.WriteLine("/* #undef HAVE_GCC_ASM_AND_X86_SFENCE */")
				Case "HAVE_MMAP"
					fout.WriteLine("/* #undef HAVE_MMAP */")
				Case "HAVE_MPP_SHMEM_H"
					fout.WriteLine("/* #undef HAVE_MPP_SHMEM_H */")
				Case "HAVE_SHM_OPEN"
					fout.WriteLine("/* #undef HAVE_SHM_OPEN */")
				Case "HAVE_SHM_UNLINK"
					fout.WriteLine("/* #undef HAVE_SHM_UNLINK */")
				Case "HAVE_SYS_MMAN_H"
					fout.WriteLine("/* #undef HAVE_SYS_MMAN_H */")
				Case "HAVE_SYSCONF"
					fout.WriteLine("/* #undef HAVE_SYSCONF */")
				Case "HAVE_NET_IF_H"
					fout.WriteLine("/* #undef HAVE_NET_IF_H */")
				Case "HAVE_SYS_SOCKIO_H"
					fout.WriteLine("/* #undef HAVE_SYS_SOCKIO_H */")
				Case "HAVE_ARPA_INET_H"
					fout.WriteLIne("/* #undef HAVE_ARPA_INET_H */")
				Case "HAVE_CTYPE_H"
					fout.WriteLine("#define HAVE_CTYPE_H")
				Case "HAVE_GETPAGESIZE"
					fout.WriteLine("/* #undef HAVE_GETPAGESIZE */")
				Case "HAVE_MQUEUE_H"
					fout.WriteLine("/* #undef HAVE_MQUEUE_H */")
				Case "HAVE_MQ_OPEN"
					fout.WriteLine("/* #undef HAVE_MQ_OPEN */")
				Case "HAVE_MSGGET"
					fout.WriteLine("/* #undef HAVE_MSGGET */")
				Case "HAVE_PROCESS_H"
					fout.WriteLine("#define HAVE_PROCESS_H")
				Case "HAVE_MULTIPLE_PRAGMA_WEAK"
					fout.WriteLine("/* #undef HAVE_MULTIPLE_PRAGMA_WEAK */")
				Case "MPICH_CPU_TICK_TYPE"
					fout.WriteLine("#define MPICH_CPU_TICK_TYPE USE_WIN_X86_CYCLE_ASM")
				Case "USE_BUSY_LOCKS"
					fout.WriteLine("/* #undef USE_BUSY_LOCKS */")
				Case "USE_MQSHM"
					fout.WriteLine("/* #undef USE_MQSHM */")
				Case "USE_ATOMIC_UPDATES"
					fout.WriteLine("/* #undef USE_ATOMIC_UPDATES */")
				Case "F77_FALSE_VALUE"
					fout.WriteLine("#define F77_FALSE_VALUE 0")
				Case "F77_TRUE_VALUE"
					' Intel Fotran uses -1
					' Compaq Visual Fortran uses 1
					fout.WriteLine("#define F77_TRUE_VALUE -1")
				Case "F77_TRUE_VALUE_SET"
					fout.WriteLine("#define F77_TRUE_VALUE_SET 1")
				Case "F77_RUNTIME_VALUES"
					fout.WriteLine("/* #undef F77_RUNTIME_VALUES */")
				Case "HAVE_AINT_LARGER_THAN_FINT"
					fout.WriteLine("/* #undef HAVE_AINT_LARGER_THAN_FINT */")
				Case "HAVE_FINT_IS_INT"
					fout.WriteLine("/* #undef HAVE_FINT_IS_INT */")
				Case "HAVE_LONG_LONG"
					fout.WriteLine("/* #undef HAVE_LONG_LONG */")
				Case "HAVE_WEAK_SYMBOLS"
					fout.WriteLine("/* #undef HAVE_WEAK_SYMBOLS */")
				Case "SIZEOF_CHAR"
					fout.WriteLine("#define SIZEOF_CHAR 1")
				Case "SIZEOF_F77_DOUBLE_PRECISION"
					fout.WriteLine("#define SIZEOF_F77_DOUBLE_PRECISION 8")
				Case "SIZEOF_F77_INTEGER"
					fout.WriteLine("#define SIZEOF_F77_INTEGER 4")
				Case "SIZEOF_F77_REAL"
					fout.WriteLine("#define SIZEOF_F77_REAL 4")
				Case "SIZEOF_VOIDP"
					If b64 Then
						fout.WriteLine("#define SIZEOF_VOIDP 8")
					Else
						fout.WriteLine("#define SIZEOF_VOIDP 4")
					End If
				Case "USE_GCC_G77_DECLS"
					fout.WriteLine("/* #undef USE_GCC_G77_DECLS */")
				Case "USE_POINTER_FOR_BOTTOM"
					fout.WriteLine("/* #undef USE_POINTER_FOR_BOTTOM */")
				Case "_TWO_WORD_FCD"
					fout.WriteLine("/* #undef _TWO_WORD_FCD */")
				Case "FORTRAN_SPECIAL_FUNCTION_PTR"
					fout.WriteLine("/* #undef FORTRAN_SPECIAL_FUNCTION_PTR */")
				Case "F77_NAME_LOWER"
					If bf77_name_lower Then
						fout.WriteLine("#define F77_NAME_LOWER")
					Else
						fout.WriteLine("/* #undef F77_NAME_LOWER */")
					End If
				Case "F77_NAME_LOWER_USCORE"
					If b77_name_lower_uscore Then
						fout.WriteLine("#define F77_NAME_LOWER_USCORE")
					Else
						fout.WriteLine("/* #undef F77_NAME_LOWER_USCORE */")
					End If
				Case "F77_NAME_LOWER_2USCORE"
					If bf77_name_lower_2uscore Then
						fout.WriteLine("#define F77_NAME_LOWER_2USCORE 1")
					Else
						fout.WriteLine("/* #undef F77_NAME_LOWER_2USCORE */")
					End If
				Case "F77_NAME_UPPER"
					if b77_name_upper Then
						fout.WriteLine("#define F77_NAME_UPPER")
					Else
						fout.WriteLine("/* #undef F77_NAME_UPPER */")
					End If
				Case "F77_NAME_MIXED"
					if b77_name_mixed Then
						fout.WriteLine("#define F77_NAME_MIXED 1")
					Else
						fout.WriteLine("/* #undef F77_NAME_MIXED */")
					End If
				Case "F77_NAME_MIXED_USCORE"
					if b77_name_mixed_uscore Then
						fout.WriteLine("#define F77_NAME_MIXED_USCORE 1")
					Else
						fout.WriteLine("/* #undef F77_NAME_MIXED_USCORE */")
					End If
				Case "HAVE_NSLINKMODULE"
					fout.WriteLine("/* #undef HAVE_NSLINKMODULE */")
				Case "HAVE_DLOPEN"
					fout.WriteLine("/* #undef HAVE_DLOPEN */")
				Case "HAVE_MACH_O_DYLD_H"
					fout.WriteLine("/* #undef HAVE_MACH_O_DYLD_H */")
				Case "USE_HUMAN_READABLE_TOKENS"
					fout.WriteLine("#define USE_HUMAN_READABLE_TOKENS 1")
				Case "HAVE_STRERROR"
					fout.WriteLine("#ifndef HAVE_STRERROR")
					fout.WriteLine("#define HAVE_STRERROR 1")
					fout.WriteLine("#endif")
				Case "HAVE_ASM_AND_X86_LFENCE"
					fout.WriteLine("/* #undef HAVE_ASM_AND_X86_LFENCE */")
				Case "HAVE_ASM_AND_X86_MFENCE"
					fout.WriteLine("/* #undef HAVE_ASM_AND_X86_MFENCE */")
				Case "HAVE_ASM_AND_X86_SFENCE"
					fout.WriteLine("/* #undef HAVE_ASM_AND_X86_SFENCE */")
				Case "HAVE___ASM_AND_X86_LFENCE"
					fout.WriteLine("/* #undef HAVE___ASM_AND_X86_LFENCE */")
				Case "HAVE___ASM_AND_X86_MFENCE"
					fout.WriteLine("/* #undef HAVE___ASM_AND_X86_MFENCE */")
				Case "HAVE___ASM_AND_X86_SFENCE"
					fout.WriteLine("/* #undef HAVE___ASM_AND_X86_SFENCE */")
				Case "HAVE__INTERLOCKEDEXCHANGE"
					fout.WriteLine("/* #undef HAVE__INTERLOCKEDEXCHANGE */")
				Case "HAVE_GCC_AND_X86_64_ASM"
					fout.WriteLine("/* #undef HAVE_GCC_AND_X86_64_ASM */")
				Case "HAVE_GCC_AND_IA64_ASM"
					fout.WriteLine("/* #undef HAVE_GCC_AND_IA64_ASM */")
				Case "NEEDS_SYS_TIME_H"
					fout.WriteLine("/* #undef NEEDS_SYS_TIME_H */")
				Case "HAVE_ALARM"
					fout.WriteLine("/* #undef HAVE_ALARM */")
				Case "HAVE_SETITIMER"
					fout.WriteLine("/* #undef HAVE_SETITIMER */")
				Case "USE_MPI_FOR_NMPI"
					fout.WriteLine("/* #undef USE_MPI_FOR_NMPI */")
				Case "USE_MACROS_FOR_WTIME"
					fout.WriteLine("/* #undef USE_MACROS_FOR_WTIME */")
				Case "HAVE_CSHARP_BINDING"
					fout.WriteLine("/* #undef HAVE_CSHARP_BINDING */")
				Case "MPIR_REAL4_CTYPE"
					fout.WriteLine("/* #undef MPIR_REAL4_CTYPE */")
				Case "MPIR_REAL8_CTYPE"
					fout.WriteLine("/* #undef MPIR_REAL8_CTYPE */")
				Case "MPIR_REAL16_CTYPE"
					fout.WriteLine("/* #undef MPIR_REAL16_CTYPE */")
				Case "MPIR_INTEGER1_CTYPE"
					fout.WriteLine("/* #undef MPIR_INTEGER1_CTYPE */")
				Case "MPIR_INTEGER2_CTYPE"
					fout.WriteLine("/* #undef MPIR_INTEGER2_CTYPE */")
				Case "MPIR_INTEGER4_CTYPE"
					fout.WriteLine("/* #undef MPIR_INTEGER4_CTYPE */")
				Case "MPIR_INTEGER8_CTYPE"
					fout.WriteLine("/* #undef MPIR_INTEGER8_CTYPE */")
				Case "MPIR_INTEGER16_CTYPE"
					fout.WriteLine("/* #undef MPIR_INTEGER16_CTYPE */")
				Case "HAVE___VA_COPY"
					fout.WriteLine("/* #undef HAVE___VA_COPY */")
				Case "HAVE_IOSTREAM"
					fout.WriteLine("#define HAVE_IOSTREAM 1")
				Case "HAVE_NAMESPACES"
					fout.WriteLine("#define HAVE_NAMESPACES 1")
				Case "HAVE_NAMESPACE_STD"
					fout.WriteLine("#define HAVE_NAMESPACE_STD 1")
				Case "HAVE_STDDEF_H"
					fout.WriteLine("#define HAVE_STDDEF_H 1")
				Case "MPICH_THREAD_LEVEL"
					fout.WriteLine("#ifdef MPICH_MULTITHREADED")
					fout.WriteLine("#define MPICH_THREAD_LEVEL MPI_THREAD_MULTIPLE")
					fout.WriteLine("#else")
					fout.WriteLine("#define MPICH_THREAD_LEVEL MPI_THREAD_SINGLE")
					fout.WriteLine("#endif")
'					If bMultiThreaded Then
'						fout.WriteLine("#define MPICH_THREAD_LEVEL MPI_THREAD_MULTIPLE")
'					Else
'						fout.WriteLine("#define MPICH_THREAD_LEVEL MPI_THREAD_SINGLE")
'					End If
				Case "USE_THREAD_IMPL"
					fout.WriteLine("#ifdef MPICH_MULTITHREADED")
					fout.WriteLine("#define USE_THREAD_IMPL MPICH_THREAD_IMPL_GLOBAL_MUTEX")
					fout.WriteLine("#else")
					fout.WriteLine("#define USE_THREAD_IMPL MPICH_THREAD_IMPL_NONE")
					fout.WriteLine("#endif")
'					If bMultiThreaded Then
'						fout.WriteLine("#define USE_THREAD_IMPL MPICH_THREAD_IMPL_GLOBAL_MUTEX")
'					Else
'						fout.WriteLine("#define USE_THREAD_IMPL MPICH_THREAD_IMPL_NONE")
'					End If
				Case "USE_THREAD_PKG"
					fout.WriteLine("#ifdef MPICH_MULTITHREADED")
					fout.WriteLine("#define USE_THREAD_PKG MPICH_THREAD_PKG_POSIX /* MPICH_THREAD_PKG_WINTHREADS */")
					fout.WriteLine("#else")
					fout.WriteLine("#define USE_THREAD_PKG MPICH_THREAD_PKG_NONE")
					fout.WriteLine("#endif")
'					If bMultiThreaded Then
'						fout.WriteLine("#define USE_THREAD_PKG MPICH_THREAD_PKG_POSIX /* MPICH_THREAD_PKG_WINTHREADS */")
'					Else
'						fout.WriteLine("#define USE_THREAD_PKG MPICH_THREAD_PKG_NONE")
'					End If
				Case "_REENTRANT"
					fout.WriteLine("/* #undef _REENTRANT */")
				Case "_THREAD_SAFE"
					fout.WriteLine("/* #undef _THREAD_SAFE */")
				Case "HAVE_SYS_POLL_H"
					fout.WriteLine("/* #undef HAVE_SYS_POLL_H */")
				Case "USE_IB_IBAL"
					fout.WriteLine("/* #undef USE_IB_IBAL */")
				Case "USE_IB_VAPI"
					fout.WriteLine("#define USE_IB_VAPI 1")
				Case "MPID_IBU_TYPE_UNIX"
					fout.WriteLine("/* #undef MPID_IBU_TYPE_UNIX */")
					'fout.WriteLine("#define MPID_IBU_TYPE_WINDOWS 1")
				Case "HAVE_MALLOC_H"
					fout.WriteLine("#define HAVE_MALLOC_H 1")
				Case "MPICH_DEBUG_MEMINIT"
					fout.WriteLine("/* #undef MPICH_DEBUG_MEMINIT */")
				Case "C_ALLOCA"
					fout.WriteLine("/* #undef C_ALLOCA */")
				Case "HAVE_ALLOCA"
					'fout.WriteLine("/* #undef HAVE_ALLOCA */")
					fout.WriteLine("#define HAVE_ALLOCA 1")
					fout.WriteLine("#define alloca _alloca")
				Case "HAVE_ALLOCA_H"
					fout.WriteLine("/* #undef HAVE_ALLOCA_H */")
				Case "HAVE_PTHREAD_YIELD"
					fout.WriteLine("/* #undef HAVE_PTHREAD_YIELD */")
				Case "HAVE_MKSTEMP"
					fout.WriteLine("/* #undef HAVE_MKSTEMP */")
				Case "HAVE_O_BINARY"
					fout.WriteLine("#define HAVE_O_BINARY 1")
				Case "_FILE_OFFSET_BITS"
					fout.WriteLine("/* #undef _FILE_OFFSET_BITS */")
				Case "_LARGEFILE64_SOURCE"
					fout.WriteLine("/* #undef _LARGEFILE64_SOURCE */")
				Case "HAVE_MPI_COMM_F2C"
					fout.WriteLine("#define HAVE_MPI_COMM_F2C 1")
				Case "HAVE_MPI_ERRHANDLER_F2C"
					fout.WriteLine("#define HAVE_MPI_ERRHANDLER_F2C 1")
				Case "HAVE_MPI_GROUP_F2C"
					fout.WriteLine("#define HAVE_MPI_GROUP_F2C 1")
				Case "HAVE_MPI_IO"
					fout.WriteLine("#define HAVE_MPI_IO 1")
				Case "HAVE_MPI_OP_F2C"
					fout.WriteLine("#define HAVE_MPI_OP_F2C 1")
				Case "HAVE_MPI_REQUEST_F2C"
					fout.WriteLine("#define HAVE_MPI_REQUEST_F2C 1")
				Case "HAVE_MPI_RMA"
					fout.WriteLine("#define HAVE_MPI_RMA 1")
				Case "HAVE_MPI_STATUSES_IGNORE"
					fout.WriteLine("#define HAVE_MPI_STATUSES_IGNORE 1")
				Case "HAVE_MPI_STATUS_BROKEN_ON_PROC_NULL"
					fout.WriteLine("/* #undef HAVE_MPI_STATUS_BROKEN_ON_PROC_NULL */")
				Case "HAVE_MPI_STATUS_F2C"
					fout.WriteLine("#define HAVE_MPI_STATUS_F2C 1")
				Case "HAVE_MPI_STATUS_IGNORE"
					fout.WriteLine("#define HAVE_MPI_STATUS_IGNORE 1")
				Case "HAVE_MPI_TYPE_F2C"
					fout.WriteLine("#define HAVE_MPI_TYPE_F2C 1")
				Case "HAVE_NO_MPIO_REQUEST"
					fout.WriteLine("/* #undef HAVE_NO_MPIO_REQUEST */")
				Case "HAVE_PROTOTYPES"
					fout.WriteLine("#define HAVE_PROTOTYPES 1")
				Case "MPE_F77_FALSE_VALUE"
					fout.WriteLine("#define MPE_F77_FALSE_VALUE 0")
				Case "MPE_F77_TRUE_VALUE"
					fout.WriteLine("#define MPE_F77_TRUE_VALUE -1")
				Case "MPI_Fint"
					fout.WriteLine("/* #undef MPI_Fint */")
				Case "MPI_STATUS_SIZE"
					fout.WriteLine("#define MPI_STATUS_SIZE 5")
				Case "USE_STDARG"
					fout.WriteLine("/* #undef USE_STDARG */")
				Case "HAVE_MPI_WTIME"
					fout.WriteLine("#define HAVE_MPI_WTIME 1")
				Case "STDCALL"
					fout.WriteLine("/* #undef STDCALL */")
				Case "MPICH_DEBUG_FINE_GRAIN_NESTING"
					fout.WriteLine("/* #undef MPICH_DEBUG_FINE_GRAIN_NESTING */")
				Case "HAVE_SPARC_INLINE_PROCESS_LOCKS"
					fout.WriteLine("/* #undef HAVE_SPARC_INLINE_PROCESS_LOCKS */")
				Case "HAVE_IOSTREAM_H"
					fout.WriteLine("/* #undef HAVE_IOSTREAM_H */")
				Case "HAVE_CXX_EXCEPTIONS"
					fout.WriteLine("#define HAVE_CXX_EXCEPTIONS 1")
				Case "bool"
					fout.WriteLine("/* bool */")
				Case Else
					'MsgBox("Unhandled definition <" & define & ">")
					unhandled_definitions = unhandled_definitions & define & vbNewLine
					fout.WriteLine("/* unknown definition: " & define & " */")
			End Select
			fout.WriteLine("")
		Next
	End If
End Sub

'
' Generate the conf.h files
'

Sub WriteHeader( fout, str )
	fout.WriteLine( "/* -*- Mode: C; c-basic-offset:4 ; -*- */" & vbNewLine & "/*" & vbNewLine & " *  (C) 2001 by Argonne National Laboratory." & vbNewLine & " *      See COPYRIGHT in top-level directory." & vbNewLine & " */" )
	fout.WriteLine("")
	fout.WriteLine("#ifndef " & UCase(str) & "CONF_H")
	fout.WriteLine("#define " & UCase(str) & "CONF_H")
	fout.WriteLine("")
	fout.WriteLine("/* " & str & "conf.h.  Generated automatically by winconfigure.  */")
	fout.WriteLine("")
End Sub

Sub WriteFooter( fout )
	fout.WriteLine("")
	fout.WriteLine("#endif")
End Sub

' mpi_fortconf.h was removed and mpichconf.h is now included instead
'If Not bRemoveFortran Then
'	'
'	' mpi_fortconf.h
'	'
'	cEcho "Creating src\include\win32\mpi_fortconf.h"
'	Set fout = f.CreateTextFile("src\include\win32\mpi_fortconf.h")
'	Call WriteHeader(fout, "mpi_fort")
'	Call AddDefinitions(fout, "src\binding\f77\mpi_fortconf.h.in", false)
'	fout.WriteLine("#ifndef HAVE_WINDOWS_H")
'	fout.WriteLine("#define HAVE_WINDOWS_H")
'	fout.WriteLine("#endif")
'	fout.WriteLine("")
'	fout.WriteLine("/* Define to #define MPIR_F_TRUE/FALSE to F77_TRUE/FALSE_VALUE */")
'	fout.WriteLine("#define F77_USE_BOOLEAN_LITERALS 1")
'	Call WriteFooter(fout)
'	fout.Close()
'	cEcho "Creating src\include\win64\mpi_fortconf.h"
'	Set fout = f.CreateTextFile("src\include\win64\mpi_fortconf.h")
'	Call WriteHeader(fout, "mpi_fort")
'	Call AddDefinitions(fout, "src\binding\f77\mpi_fortconf.h.in", true)
'	fout.WriteLine("#ifndef HAVE_WINDOWS_H")
'	fout.WriteLine("#define HAVE_WINDOWS_H")
'	fout.WriteLine("#endif")
'	fout.WriteLine("")
'	fout.WriteLine("/* Define to #define MPIR_F_TRUE/FALSE to F77_TRUE/FALSE_VALUE */")
'	fout.WriteLine("#define F77_USE_BOOLEAN_LITERALS 1")
'	Call WriteFooter(fout)
'	fout.Close()
'	
'	'
'	' mpi_fortimpl.h
'	'
'	'Set fin = f.OpenTextFile("src\binding\f77\mpi_fortimpl.h")
'	'contents = fin.ReadAll()
'	'fin.Close()
'	'contents = Replace(contents, "#define MPIR_FROM_FLOG(a) ( (a) == MPIR_F_TRUE ? 1 : 0 )", "#define MPIR_FROM_FLOG(a) ( (a) != 0 ? 1 : 0 )")
'	'cEcho "Creating src\binding\f77\mpi_fortimpl.h"
'	'Set fout = f.CreateTextFile("src\binding\f77\mpi_fortimpl.h")
'	'fout.Write(contents)
'	'fout.Close()
'
'End If

'
' mpichconf.h
'
cEcho "Creating src\include\win32\mpichconf.h"
Set fout = f.CreateTextFile("src\include\win32\mpichconf.h")
Call WriteHeader(fout, "mpich")
Call AddDefinitions(fout, "src\include\mpichconf.h.in", false)
fout.WriteLine("#define HAVE_PROCESS_H")
fout.WriteLine("#ifndef HAVE_WINDOWS_H")
fout.WriteLine("#define HAVE_WINDOWS_H")
fout.WriteLine("#endif")
fout.WriteLine("#define HAVE_WINDOWS_SOCKET")
fout.WriteLine("#define HAVE_WINSOCK2_H")
fout.WriteLine("#define HAVE_WIN32_SLEEP")
fout.WriteLine("#define HAVE_NT_LOCKS")
fout.WriteLine("#define HAVE_MAPVIEWOFFILE")
fout.WriteLine("#define HAVE_CREATEFILEMAPPING")
fout.WriteLine("#define HAVE_INTERLOCKEDEXCHANGE")
fout.WriteLine("#define HAVE_BOOL")
fout.WriteLine("#define HAVE_CRTDBG_H")
fout.WriteLine("")
fout.WriteLine("#define snprintf _snprintf")
fout.WriteLine("#define vsnprintf _vsnprintf")
fout.WriteLine("#define inline __inline")
fout.WriteLine("")
fout.WriteLine("#define WITH_SOCK_TYPE SOCK_IOCP")
fout.WriteLine("")
fout.WriteLine("/* Define if building mpich in development mode */")
fout.WriteLine("#define MPICH_DEV_BUILD")
fout.WriteLine("/*#define MPICH_DBG_OUTPUT*/")
fout.WriteLine("")
fout.WriteLine("/*#define MPICH_MPI_FROM_PMPI*/")
fout.WriteLine("#define USE_PROCESS_LOCKS 1")
fout.WriteLine("#define USE_THREAD_PACKAGE")
fout.WriteLine("#define USE_WINTHREADS")
fout.WriteLine("#ifndef HAVE_INT64")
fout.WriteLine("#define HAVE_INT64 1")
fout.WriteLine("#define HAVE_PTRTOLONG")
fout.WriteLine("#define HAVE_PTRTOINT")
fout.WriteLine("#define HAVE_LONGTOPTR")
fout.WriteLine("#define HAVE_INTTOPTR")
fout.WriteLine("#endif")
If Not bRemoveFortran Then
	fout.WriteLine("/* Define to #define MPIR_F_TRUE/FALSE to F77_TRUE/FALSE_VALUE */")
	fout.WriteLine("#define F77_USE_BOOLEAN_LITERALS 1")
End If
Call WriteFooter(fout)
fout.Close()
cEcho "Creating src\include\win64\mpichconf.h"
Set fout = f.CreateTextFile("src\include\win64\mpichconf.h")
Call WriteHeader(fout, "mpich")
Call AddDefinitions(fout, "src\include\mpichconf.h.in", true)
fout.WriteLine("#define HAVE_PROCESS_H")
fout.WriteLine("#ifndef HAVE_WINDOWS_H")
fout.WriteLine("#define HAVE_WINDOWS_H")
fout.WriteLine("#endif")
fout.WriteLine("#define HAVE_WINDOWS_SOCKET")
fout.WriteLine("#define HAVE_WINSOCK2_H")
fout.WriteLine("#define HAVE_WIN32_SLEEP")
fout.WriteLine("#define HAVE_NT_LOCKS")
fout.WriteLine("#define HAVE_MAPVIEWOFFILE")
fout.WriteLine("#define HAVE_CREATEFILEMAPPING")
fout.WriteLine("#define HAVE_INTERLOCKEDEXCHANGE")
fout.WriteLine("#define HAVE_BOOL")
fout.WriteLine("#define HAVE_CRTDBG_H")
fout.WriteLine("")
fout.WriteLine("#define snprintf _snprintf")
fout.WriteLine("#define vsnprintf _vsnprintf")
fout.WriteLine("#define inline __inline")
fout.WriteLine("")
fout.WriteLine("#define WITH_SOCK_TYPE SOCK_IOCP")
fout.WriteLine("")
fout.WriteLine("/* Define if building mpich in development mode */")
fout.WriteLine("#define MPICH_DEV_BUILD")
fout.WriteLine("/*#define MPICH_DBG_OUTPUT*/")
fout.WriteLine("")
fout.WriteLine("/*#define MPICH_MPI_FROM_PMPI*/")
fout.WriteLine("#define USE_PROCESS_LOCKS 1")
fout.WriteLine("#define USE_THREAD_PACKAGE")
fout.WriteLine("#define USE_WINTHREADS")
fout.WriteLine("#ifndef HAVE_INT64")
fout.WriteLine("#define HAVE_INT64 1")
fout.WriteLine("#define HAVE_PTRTOLONG")
fout.WriteLine("#define HAVE_PTRTOINT")
fout.WriteLine("#define HAVE_LONGTOPTR")
fout.WriteLine("#define HAVE_INTTOPTR")
fout.WriteLine("#endif")
If Not bRemoveFortran Then
	fout.WriteLine("/* Define to #define MPIR_F_TRUE/FALSE to F77_TRUE/FALSE_VALUE */")
	fout.WriteLine("#define F77_USE_BOOLEAN_LITERALS 1")
End If
Call WriteFooter(fout)
fout.Close()

'
' mpidi_ch3_conf.h
'
cEcho "Creating src\include\win32\mpidi_ch3_conf.h"
Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3_conf.h")
Call WriteHeader(fout, "mpidi_ch3_")
Call AddDefinitions(fout, "src\mpid\ch3\include\mpidi_ch3_conf.h.in", false)
fout.WriteLine("#define EWOULDBLOCK EAGAIN")
fout.WriteLine("#define HAVE_WINTHREADS")
fout.WriteLine("#define MPICH_CPU_TICK_TYPE USE_WIN_X86_CYCLE_ASM")
Call WriteFooter(fout)
fout.Close()
cEcho "Creating src\include\win64\mpidi_ch3_conf.h"
Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3_conf.h")
Call WriteHeader(fout, "mpidi_ch3_")
Call AddDefinitions(fout, "src\mpid\ch3\include\mpidi_ch3_conf.h.in", true)
fout.WriteLine("#define EWOULDBLOCK EAGAIN")
fout.WriteLine("#define HAVE_WINTHREADS")
fout.WriteLine("#define MPICH_CPU_TICK_TYPE USE_WIN_X86_CYCLE_ASM")
Call WriteFooter(fout)
fout.Close()

'
' timerconf.h
'
cEcho "Creating src\include\win32\timerconf.h"
Set fout = f.CreateTextFile("src\include\win32\timerconf.h")
Call WriteHeader(fout, "timer")
Call AddDefinitions(fout, "src\mpi\timer\timerconf.h.in", false)
Call WriteFooter(fout)
fout.Close()
cEcho "Creating src\include\win64\timerconf.h"
Set fout = f.CreateTextFile("src\include\win64\timerconf.h")
Call WriteHeader(fout, "timer")
Call AddDefinitions(fout, "src\mpi\timer\timerconf.h.in", true)
Call WriteFooter(fout)
fout.Close()

'
' mpid_locksconf.h
'
cEcho "Creating src\include\win32\mpid_locksconf.h"
Set fout = f.CreateTextFile("src\include\win32\mpid_locksconf.h")
Call WriteHeader(fout, "mpid_locks")
Call AddDefinitions(fout, "src\mpid\common\locks\mpid_locksconf.h.in", false)
Call WriteFooter(fout)
fout.Close()
cEcho "Creating src\include\win64\mpid_locksconf.h"
Set fout = f.CreateTextFile("src\include\win64\mpid_locksconf.h")
Call WriteHeader(fout, "mpid_locks")
Call AddDefinitions(fout, "src\mpid\common\locks\mpid_locksconf.h.in", true)
Call WriteFooter(fout)
fout.Close()

'
' mpidu_sock_conf.h
'
cEcho "Creating src\include\win32\mpidu_sock_conf.h"
Set fout = f.CreateTextFile("src\include\win32\mpidu_sock_conf.h")
Call WriteHeader(fout, "mpidu_sock_")
Call AddDefinitions(fout, "src\mpid\common\sock\mpidu_sock_conf.h.in", false)
Call WriteFooter(fout)
fout.Close()
cEcho "Creating src\include\win64\mpidu_sock_conf.h"
Set fout = f.CreateTextFile("src\include\win64\mpidu_sock_conf.h")
Call WriteHeader(fout, "mpidu_sock_")
Call AddDefinitions(fout, "src\mpid\common\sock\mpidu_sock_conf.h.in", true)
Call WriteFooter(fout)
fout.Close()

'
' pmiconf.h
'
cEcho "Creating src\include\win32\pmiconf.h"
Set fout = f.CreateTextFile("src\include\win32\pmiconf.h")
Call WriteHeader(fout, "pmi")
Call AddDefinitions(fout, "src\pmi\smpd\pmiconf.h.in", false)
fout.WriteLine("#ifndef HAVE_WINDOWS_H")
fout.WriteLine("#define HAVE_WINDOWS_H")
fout.WriteLine("#endif")
Call WriteFooter(fout)
fout.Close()
cEcho "Creating src\include\win64\pmiconf.h"
Set fout = f.CreateTextFile("src\include\win64\pmiconf.h")
Call WriteHeader(fout, "pmi")
Call AddDefinitions(fout, "src\pmi\smpd\pmiconf.h.in", true)
fout.WriteLine("#ifndef HAVE_WINDOWS_H")
fout.WriteLine("#define HAVE_WINDOWS_H")
fout.WriteLine("#endif")
Call WriteFooter(fout)
fout.Close()

'
' mpidi_ch3i_rdma_conf.h
'
If f.FileExists("src\mpid\ch3\channels\rdma\include\mpidi_ch3i_rdma_conf.h.in") Then
	cEcho "Creating src\include\win32\mpidi_ch3i_rdma_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_rdma_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_rdma_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\rdma\include\mpidi_ch3i_rdma_conf.h.in", false)
	fout.WriteLine("#define USE_BUSY_LOCKS")
	Call WriteFooter(fout)
	fout.Close()
	cEcho "Creating src\include\win64\mpidi_ch3i_rdma_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_rdma_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_rdma_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\rdma\include\mpidi_ch3i_rdma_conf.h.in", true)
	fout.WriteLine("#define USE_BUSY_LOCKS")
	Call WriteFooter(fout)
	fout.Close()
Else
	cEcho "Skipping file: mpidi_ch3i_rdma_conf.h"
End If

'
' mpidi_ch3i_shm_conf.h
'
If f.FileExists("src\mpid\ch3\channels\shm\include\mpidi_ch3i_shm_conf.h.in") Then
	cEcho "Creating src\include\win32\mpidi_ch3i_shm_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_shm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_shm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\shm\include\mpidi_ch3i_shm_conf.h.in", false)
	fout.WriteLine("#define USE_BUSY_LOCKS")
	fout.WriteLine("#define HAVE_SHARED_PROCESS_READ")
	fout.WriteLine("#define MPIDI_CH3_CHANNEL_RNDV")
	fout.WriteLine("#define USE_RDMA_GET")
	fout.WriteLine("#define USE_SHM_RDMA_GET")
	Call WriteFooter(fout)
	fout.Close()
	cEcho "Creating src\include\win64\mpidi_ch3i_shm_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_shm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_shm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\shm\include\mpidi_ch3i_shm_conf.h.in", true)
	fout.WriteLine("#define USE_BUSY_LOCKS")
	fout.WriteLine("#define HAVE_SHARED_PROCESS_READ")
	fout.WriteLine("#define MPIDI_CH3_CHANNEL_RNDV")
	fout.WriteLine("#define USE_RDMA_GET")
	fout.WriteLine("#define USE_SHM_RDMA_GET")
	Call WriteFooter(fout)
	fout.Close()
Else
	cEcho "Skipping file: mpidi_ch3i_shm_conf.h"
End If

'
' mpidi_ch3i_sock_conf.h
'
If f.FileExists("src\mpid\ch3\channels\sock\include\mpidi_ch3i_sock_conf.h.in") Then
	cEcho "Creating src\include\win32\mpidi_ch3i_sock_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_sock_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_sock_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\sock\include\mpidi_ch3i_sock_conf.h.in", false)
	Call WriteFooter(fout)
	fout.Close()
	cEcho "Creating src\include\win64\mpidi_ch3i_sock_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_sock_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_sock_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\sock\include\mpidi_ch3i_sock_conf.h.in", true)
	Call WriteFooter(fout)
	fout.Close()
Else
	cEcho "Skipping file: mpidi_ch3i_sock_conf.h"
End If

'
' mpidi_ch3i_ssm_conf.h
'
If f.FileExists("src\mpid\ch3\channels\ssm\include\mpidi_ch3i_ssm_conf.h.in") Then
	cEcho "Creating src\include\win32\mpidi_ch3i_ssm_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_ssm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_ssm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\ssm\include\mpidi_ch3i_ssm_conf.h.in", false)
	Call WriteFooter(fout)
	fout.Close()
	cEcho "Creating src\include\win64\mpidi_ch3i_ssm_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_ssm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_ssm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\ssm\include\mpidi_ch3i_ssm_conf.h.in", true)
	Call WriteFooter(fout)
	fout.Close()
Else
	cEcho "Skipping file: mpidi_ch3i_ssm_conf.h"
End If

'
' mpidi_ch3i_essm_conf.h
'
If f.FileExists("src\mpid\ch3\channels\essm\include\mpidi_ch3i_essm_conf.h.in") Then
	cEcho "Creating src\include\win32\mpidi_ch3i_essm_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_essm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_essm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\essm\include\mpidi_ch3i_essm_conf.h.in", false)
	Call WriteFooter(fout)
	fout.Close()
	cEcho "Creating src\include\win64\mpidi_ch3i_essm_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_essm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_essm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\essm\include\mpidi_ch3i_essm_conf.h.in", true)
	Call WriteFooter(fout)
	fout.Close()
Else
	cEcho "Skipping file: mpidi_ch3i_essm_conf.h"
End If

'
' mpidi_ch3i_sshm_conf.h
'
If f.FileExists("src\mpid\ch3\channels\sshm\include\mpidi_ch3i_sshm_conf.h.in") Then
	cEcho "Creating src\include\win32\mpidi_ch3i_sshm_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_sshm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_sshm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\sshm\include\mpidi_ch3i_sshm_conf.h.in", false)
	fout.WriteLine("#define HAVE_MASM_AND_X86")
	Call WriteFooter(fout)
	fout.Close()
	cEcho "Creating src\include\win64\mpidi_ch3i_sshm_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_sshm_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_sshm_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\sshm\include\mpidi_ch3i_sshm_conf.h.in", true)
	fout.WriteLine("#define HAVE_MASM_AND_X86")
	Call WriteFooter(fout)
	fout.Close()
Else
	cEcho "Skipping file: mpidi_ch3i_sshm_conf.h"
End If

'
' mpidi_ch3i_ib_conf.h
'
If f.FileExists("src\mpid\ch3\channels\ib\include\mpidi_ch3i_ib_conf.h.in") Then
	cEcho "Creating src\include\win32\mpidi_ch3i_ib_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpidi_ch3i_ib_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_ib_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\ib\include\mpidi_ch3i_ib_conf.h.in", false)
	fout.WriteLine("#define MPID_IBU_TYPE_WINDOWS")
	fout.WriteLine("#define __i386__")
	If bUseIbRDMA Then
		fout.WriteLine("#define MPIDI_CH3_CHANNEL_RNDV")
	Else
		fout.WriteLine("/*#define MPIDI_CH3_CHANNEL_RNDV*/")
	End If
	If bUsePinCache Then
		fout.WriteLine("/*#define USE_NO_PIN_CACHE*/")
	else
		fout.WriteLine("#define USE_NO_PIN_CACHE")
	End If
	fout.WriteLine("#define USE_RDMA_GET")
	Call WriteFooter(fout)
	fout.Close()
	cEcho "Creating src\include\win64\mpidi_ch3i_ib_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpidi_ch3i_ib_conf.h")
	Call WriteHeader(fout, "mpidi_ch3i_ib_")
	Call AddDefinitions(fout, "src\mpid\ch3\channels\ib\include\mpidi_ch3i_ib_conf.h.in", true)
	fout.WriteLine("#define MPID_IBU_TYPE_WINDOWS")
	If x64 then
		fout.WriteLine("#define __x64__")
	else
		fout.WriteLine("#define __ia64__")
	End If
	If bUseIbRDMA Then
		fout.WriteLine("#define MPIDI_CH3_CHANNEL_RNDV")
	Else
		fout.WriteLine("/*#define MPIDI_CH3_CHANNEL_RNDV*/")
	End If
	If bUsePinCache Then
		fout.WriteLine("/*#define USE_NO_PIN_CACHE*/")
	else
		fout.WriteLine("#define USE_NO_PIN_CACHE")
	End If
	fout.WriteLine("#define USE_RDMA_GET")
	Call WriteFooter(fout)
	fout.Close()
Else
	cEcho "Skipping file: mpidi_ch3i_ib_conf.h"
End If

If f.FolderExists("src\mpe2") Then

	'
	' mpe_logging_conf.h
	'
	If f.FileExists("src\mpe2\src\logging\mpe_logging_conf.h.in") Then
		cEcho "Creating src\include\win32\mpe_logging_conf.h"
		Set fout = f.CreateTextFile("src\include\win32\mpe_logging_conf.h")
		Call WriteHeader(fout, "mpe_logging_")
		Call AddDefinitions(fout, "src\mpe2\src\logging\mpe_logging_conf.h.in", false)
		fout.WriteLine("#define HAVE_IO_H 1")
		fout.WriteLine("#define HAVE_WINDOWS_H 1")
		fout.WriteLine("#define read _read")
		fout.WriteLine("#define write _write")
		fout.WriteLine("#define open _open")
		fout.WriteLine("#define close _close")
		fout.WriteLine("#define mktemp _mktemp")
		fout.WriteLine("#define lseek _lseek")
		fout.WriteLine("#define snprintf _snprintf")
		fout.WriteLine("#define OPEN( a , b , c ) _open( a , b | O_BINARY , c )")
		Call WriteFooter(fout)
		fout.Close()
		cEcho "Creating src\include\win64\mpe_logging_conf.h"
		Set fout = f.CreateTextFile("src\include\win64\mpe_logging_conf.h")
		Call WriteHeader(fout, "mpe_logging_")
		Call AddDefinitions(fout, "src\mpe2\src\logging\mpe_logging_conf.h.in", true)
		fout.WriteLine("#define HAVE_IO_H 1")
		fout.WriteLine("#define HAVE_WINDOWS_H 1")
		fout.WriteLine("#define read _read")
		fout.WriteLine("#define write _write")
		fout.WriteLine("#define open _open")
		fout.WriteLine("#define close _close")
		fout.WriteLine("#define mktemp _mktemp")
		fout.WriteLine("#define lseek _lseek")
		fout.WriteLine("#define snprintf _snprintf")
		fout.WriteLine("#define OPEN( a , b , c ) _open( a , b | O_BINARY , c )")
		Call WriteFooter(fout)
		fout.Close()
	Else
		cEcho "Skipping file: mpe_logging_conf.h"
	End If

	'/src/misc/mpe_misc_conf.h.in

	'
	' mpe_wrappers_conf.h
	'
	If f.FileExists("src\mpe2\src\wrappers\mpe_wrappers_conf.h.in") Then
		cEcho "Creating src\include\win32\mpe_wrappers_conf.h"
		Set fout = f.CreateTextFile("src\include\win32\mpe_wrappers_conf.h")
		Call WriteHeader(fout, "mpe_wrappers_")
		Call AddDefinitions(fout, "src\mpe2\src\wrappers\mpe_wrappers_conf.h.in", false)
		fout.WriteLine("#define HAVE_WINDOWS_H 1")
		Call WriteFooter(fout)
		fout.Close()
		cEcho "Creating src\include\win64\mpe_wrappers_conf.h"
		Set fout = f.CreateTextFile("src\include\win64\mpe_wrappers_conf.h")
		Call WriteHeader(fout, "mpe_wrappers_")
		Call AddDefinitions(fout, "src\mpe2\src\wrappers\mpe_wrappers_conf.h.in", true)
		fout.WriteLine("#define HAVE_WINDOWS_H 1")
		Call WriteFooter(fout)
		fout.Close()
	Else
		cEcho "Skipping file: mpe_wrappers_conf.h"
	End If

	'/src/slog2sdk/trace_rlog/trace_impl.h.in
	'/src/slog2sdk/trace_sample/trace_impl.h.in

	'
	' mpe_conf.h
	'
	If f.FileExists("src\mpe2\mpe_conf.h.in") Then
		cEcho "Creating src\include\win32\mpe_conf.h"
		Set fout = f.CreateTextFile("src\include\win32\mpe_conf.h")
		Call WriteHeader(fout, "mpe_")
		Call AddDefinitions(fout, "src\mpe2\mpe_conf.h.in", false)
		fout.WriteLine("#define HAVE_IO_H 1")
		fout.WriteLine("#define HAVE_WINDOWS_H 1")
		fout.WriteLine("#define read _read")
		fout.WriteLine("#define write _write")
		fout.WriteLine("#define open _open")
		fout.WriteLine("#define close _close")
		fout.WriteLine("#define mktemp _mktemp")
		fout.WriteLine("#define lseek _lseek")
		fout.WriteLine("#define snprintf _snprintf")
		fout.WriteLine("#define OPEN( a , b , c ) _open( a , b | O_BINARY , c )")
		Call WriteFooter(fout)
		fout.Close()
		cEcho "Creating src\include\win64\mpe_conf.h"
		Set fout = f.CreateTextFile("src\include\win64\mpe_conf.h")
		Call WriteHeader(fout, "mpe_")
		Call AddDefinitions(fout, "src\mpe2\mpe_conf.h.in", true)
		fout.WriteLine("#define HAVE_IO_H 1")
		fout.WriteLine("#define HAVE_WINDOWS_H 1")
		fout.WriteLine("#define read _read")
		fout.WriteLine("#define write _write")
		fout.WriteLine("#define open _open")
		fout.WriteLine("#define close _close")
		fout.WriteLine("#define mktemp _mktemp")
		fout.WriteLine("#define lseek _lseek")
		fout.WriteLine("#define snprintf _snprintf")
		fout.WriteLine("#define OPEN( a , b , c ) _open( a , b | O_BINARY , c )")
		Call WriteFooter(fout)
		fout.Close()
	Else
		cEcho "Skipping file: mpe_conf.h"
	End If

End If

'
' mpe_thread.h
'
If f.FileExists("src\util\thread\mpe_thread.h.in") Then
	cEcho "Creating src\include\win32\mpe_thread.h"
	Set fout = f.CreateTextFile("src\include\win32\mpe_thread.h")
	Set fin = f.OpenTextFile("src\util\thread\mpe_thread.h.in")
	contents = fin.ReadAll()
	contents = ReplaceAts(contents, false, false)
	fout.Write(contents)
	fin.Close()
	fout.Close()
	cEcho "Creating src\include\win64\mpe_thread.h"
	Set fout = f.CreateTextFile("src\include\win64\mpe_thread.h")
	Set fin = f.OpenTextFile("src\util\thread\mpe_thread.h.in")
	contents = fin.ReadAll()
	contents = ReplaceAts(contents, false, true)
	fout.Write(contents)
	fin.Close()
	fout.Close()
Else
	cEcho "Skipping file: mpe_thread.h"
End If

'
' mpe_thread_conf.h
'
If f.FileExists("src\util\thread\mpe_thread_conf.h.in") Then
	cEcho "Creating src\include\win32\mpe_thread_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpe_thread_conf.h")
	Call WriteHeader(fout, "mpe_thread_")
	Call AddDefinitions(fout, "src\util\thread\mpe_thread_conf.h.in", false)
	Call WriteFooter(fout)
	fout.Close()
	cEcho "Creating src\include\win64\mpe_thread_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpe_thread_conf.h")
	Call WriteHeader(fout, "mpe_thread_")
	Call AddDefinitions(fout, "src\util\thread\mpe_thread_conf.h.in", true)
	Call WriteFooter(fout)
	fout.Close()
Else
	cEcho "Skipping file: mpe_thread_conf.h"
End If

'
' mpid_thread.h
'
If f.FileExists("src\mpid\common\thread\mpid_thread.h.in") Then
	cEcho "Creating src\include\win32\mpid_thread.h"
	Set fout = f.CreateTextFile("src\include\win32\mpid_thread.h")
	Set fin = f.OpenTextFile("src\mpid\common\thread\mpid_thread.h.in")
	contents = fin.ReadAll()
	contents = ReplaceAts(contents, false, false)
	fout.Write(contents)
	fin.Close()
	fout.Close()
	cEcho "Creating src\include\win64\mpid_thread.h"
	Set fout = f.CreateTextFile("src\include\win64\mpid_thread.h")
	Set fin = f.OpenTextFile("src\mpid\common\thread\mpid_thread.h.in")
	contents = fin.ReadAll()
	contents = ReplaceAts(contents, false, true)
	fout.Write(contents)
	fin.Close()
	fout.Close()
Else
	cEcho "Skipping file: mpid_thread.h"
End If

'
' mpiu_events_conf.h
'
If f.FileExists("src\util\events\mpiu_events_conf.h.in") Then
	cEcho "Creating src\include\win32\mpiu_events_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpiu_events_conf.h")
	Call WriteHeader(fout, "mpiu_events_")
	Call AddDefinitions(fout, "src\util\events\mpiu_events_conf.h.in", false)
	fout.WriteLine("#ifndef USE_MPIU_EVENT_TYPE")
	fout.WriteLine("#define USE_MPIU_EVENT_TYPE MPIU_EVENT_TYPE_WINDOWS")
	fout.WriteLine("#endif")
	Call WriteFooter(fout)
	fout.Close()
	cEcho "Creating src\include\win64\mpiu_events_conf.h"
	Set fout = f.CreateTextFile("src\include\win64\mpiu_events_conf.h")
	Call WriteHeader(fout, "mpiu_events_")
	Call AddDefinitions(fout, "src\util\events\mpiu_events_conf.h.in", false)
	fout.WriteLine("#ifndef USE_MPIU_EVENT_TYPE")
	fout.WriteLine("#define USE_MPIU_EVENT_TYPE MPIU_EVENT_TYPE_WINDOWS")
	fout.WriteLine("#endif")
	Call WriteFooter(fout)
	fout.Close()
Else
	'cEcho "Skipping file: mpiu_events_conf.h"
	Set fout = f.CreateTextFile("src\include\win32\mpiu_events_conf.h")
	Call WriteHeader(fout, "mpiu_events_")
	fout.WriteLine("#ifndef USE_MPIU_EVENT_TYPE")
	fout.WriteLine("#define USE_MPIU_EVENT_TYPE MPIU_EVENT_TYPE_WINDOWS")
	fout.WriteLine("#endif")
	Call WriteFooter(fout)
	fout.Close()
	Set fout = f.CreateTextFile("src\include\win64\mpiu_events_conf.h")
	Call WriteHeader(fout, "mpiu_events_")
	fout.WriteLine("#ifndef USE_MPIU_EVENT_TYPE")
	fout.WriteLine("#define USE_MPIU_EVENT_TYPE MPIU_EVENT_TYPE_WINDOWS")
	fout.WriteLine("#endif")
	Call WriteFooter(fout)
	fout.Close()
End If

'
' trace_impl.h
'
cEcho "Creating src\util\logging\rlog\trace_impl.h"
Set fout = f.CreateTextFile("src\util\logging\rlog\trace_impl.h")
Call WriteHeader(fout, "trace_impl")
'Call AddDefinitions(fout, "src\util\logging\rlog\trace_impl.h.in", false)
fout.WriteLine("#define HAVE_CTYPE_H")
fout.WriteLine("#define HAVE_STDLIB_H")
fout.WriteLine("#define HAVE_STRING_H")
Call WriteFooter(fout)
fout.Close()

Function ConfigureTestDir

	'
	' mpitestconf.h
	'
	If f.FileExists("test\mpi\include\mpitestconf.h.in") Then
		'Set fout = f.CreateTextFile("test\mpi\include\mpitestconf.h")
		cEcho "Creating src\include\win32\mpitestconf.h"
		Set fout = f.CreateTextFile("src\include\win32\mpitestconf.h") ' Let's avoid adding a new include path to the test projects
		Call WriteHeader(fout, "mpitest")
		Call AddDefinitions(fout, "test\mpi\include\mpitestconf.h.in", false)
		fout.WriteLine("#ifndef HAVE_WINDOWS_H")
		fout.WriteLine("#define HAVE_WINDOWS_H")
		fout.WriteLine("#endif")
		Call WriteFooter(fout)
		fout.Close()
		'Set fout = f.CreateTextFile("test\mpi\include\mpitestconf.h")
		cEcho "Creating src\include\win64\mpitestconf.h"
		Set fout = f.CreateTextFile("src\include\win64\mpitestconf.h") ' Let's avoid adding a new include path to the test projects
		Call WriteHeader(fout, "mpitest")
		Call AddDefinitions(fout, "test\mpi\include\mpitestconf.h.in", true)
		fout.WriteLine("#ifndef HAVE_WINDOWS_H")
		fout.WriteLine("#define HAVE_WINDOWS_H")
		fout.WriteLine("#endif")
		Call WriteFooter(fout)
		fout.Close()
	Else
		cEcho "Skipping file: mpitestconf.h"
	End If

	If Not bRemoveFortran Then
		'
		' attraints.h
		'
		If f.FileExists("test\mpi\f77\attr\attraints.h.in") Then
			cEcho "Creating test\mpi\f77\attr\attraints.h"
			Set fout = f.CreateTextFile("test\mpi\f77\attr\attraints.h")
			Set fin = f.OpenTextFile("test\mpi\f77\attr\attraints.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

'			cEcho "Creating test\mpi\f77\attr\attraints64.h"
'			Set fout = f.CreateTextFile("test\mpi\f77\attr\attraints64.h")
'			Set fin = f.OpenTextFile("test\mpi\f77\attr\attraints.h.in")
'			contents = fin.ReadAll()
'			contents = ReplaceAts(contents, false, true)
'			fout.Write(contents)
'			fin.Close()
'			fout.Close()
		Else
			cEcho "Skipping file: attraints.h"
		End If

		'
		' typeaints.h
		'
		If f.FileExists("test\mpi\f77\datatype\typeaints.h.in") Then
			cEcho "Creating test\mpi\f77\datatype\typeaints.h"
			Set fout = f.CreateTextFile("test\mpi\f77\datatype\typeaints.h")
			Set fin = f.OpenTextFile("test\mpi\f77\datatype\typeaints.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

'			cEcho "Creating test\mpi\f77\datatype\typeaints64.h"
'			Set fout = f.CreateTextFile("test\mpi\f77\datatype\typeaints64.h")
'			Set fin = f.OpenTextFile("test\mpi\f77\datatype\typeaints.h.in")
'			contents = fin.ReadAll()
'			contents = ReplaceAts(contents, false, true)
'			fout.Write(contents)
'			fin.Close()
'			fout.Close()
		Else
			cEcho "Skipping file: typeaints.h"
		End If

		'
		' iooffset.h
		'
		If f.FileExists("test\mpi\f77\io\iooffset.h.in") Then
			cEcho "Creating test\mpi\f77\io\iooffset.h"
			Set fout = f.CreateTextFile("test\mpi\f77\io\iooffset.h")
			Set fin = f.OpenTextFile("test\mpi\f77\io\iooffset.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

'			cEcho "Creating test\mpi\f77\io\iooffset64.h"
'			Set fout = f.CreateTextFile("test\mpi\f77\io\iooffset64.h")
'			Set fin = f.OpenTextFile("test\mpi\f77\io\iooffset.h.in")
'			contents = fin.ReadAll()
'			contents = ReplaceAts(contents, false, true)
'			fout.Write(contents)
'			fin.Close()
'			fout.Close()
		Else
			cEcho "Skipping file: iooffset.h"
		End If

		'
		' iodisp.h
		'
		If f.FileExists("test\mpi\f77\io\iodisp.h.in") Then
			cEcho "Creating test\mpi\f77\io\iodisp.h"
			Set fout = f.CreateTextFile("test\mpi\f77\io\iodisp.h")
			Set fin = f.OpenTextFile("test\mpi\f77\io\iodisp.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

'			cEcho "Creating test\mpi\f77\io\iodisp64.h"
'			Set fout = f.CreateTextFile("test\mpi\f77\io\iodisp64.h")
'			Set fin = f.OpenTextFile("test\mpi\f77\io\iodisp.h.in")
'			contents = fin.ReadAll()
'			contents = ReplaceAts(contents, false, true)
'			fout.Write(contents)
'			fin.Close()
'			fout.Close()
		Else
			cEcho "Skipping file: iodisp.h"
		End If

		'
		' addsize.h
		'
		If f.FileExists("test\mpi\f77\rma\addsize.h.in") Then
			cEcho "Creating test\mpi\f77\rma\addsize.h"
			Set fout = f.CreateTextFile("test\mpi\f77\rma\addsize.h")
			Set fin = f.OpenTextFile("test\mpi\f77\rma\addsize.h.in")
			contents = fin.ReadAll()
			contents = ReplaceAts(contents, false, false)
			fout.Write(contents)
			fin.Close()
			fout.Close()

'			cEcho "Creating test\mpi\f77\rma\addsize64.h"
'			Set fout = f.CreateTextFile("test\mpi\f77\rma\addsize64.h")
'			Set fin = f.OpenTextFile("test\mpi\f77\rma\addsize.h.in")
'			contents = fin.ReadAll()
'			contents = ReplaceAts(contents, false, true)
'			fout.Write(contents)
'			fin.Close()
'			fout.Close()
		Else
			cEcho "Skipping file: addsize.h"
		End If

	End If

End Function

ConfigureTestDir()

'
' fooconf.h
'
'Set fout = f.CreateTextFile("src\include\fooconf.h")
'Call WriteHeader(fout, "foo")
'Call AddDefinitions(fout, "src\include\fooconf.h.in", false)
'fout.WriteLine("foo specific stuff")
'Call WriteFooter(fout)
'fout.Close()

'
' Generate mpicc
'
Function GenerateMPICC()
	set f = WScript.CreateObject("Scripting.FileSystemObject")
	vbLessThan = "<"
	vbGreaterThan = ">"
	path_to_mpich = f.GetAbsolutePathName("winconfigure.wsf")
	path_to_mpich = Left(path_to_mpich, Len(path_to_mpich) - 16)
	If Not f.FolderExists("bin") Then
		f.CreateFolder("bin")
	End If
	cEcho "Creating bin\mpicc.wsf"
	Set fout = f.CreateTextFile("bin\mpicc.wsf")
	fout.WriteLine(vbLessThan & "package" & vbGreaterThan)
	fout.WriteLine(vbLessThan & "job id=""mpicc""" & vbGreaterThan)
	fout.WriteLine("    " & vbLessThan & "runtime" & vbGreaterThan)
	fout.WriteLine("        " & vbLessThan & "description" & vbGreaterThan & "This script compiles C console MPICH2 applications" & vbLessThan & "/description" & vbGreaterThan)
	fout.WriteLine("        " & vbLessThan & "unnamed")
	fout.WriteLine("            name = ""file""")
	fout.WriteLine("            helpstring = ""List the source files to compile""")
	fout.WriteLine("            many = ""true""")
	fout.WriteLine("            required = ""1""")
	fout.WriteLine("        /" & vbGreaterThan)
	fout.WriteLine("        " & vbLessThan & "named")
	fout.WriteLine("            name = ""out""")
	fout.WriteLine("            helpstring = ""Name of the output executable, default=myapp.exe""")
	fout.WriteLine("            type = ""string""")
	fout.WriteLine("            required = ""false""")
	fout.WriteLine("        /" & vbGreaterThan)
	fout.WriteLine("        " & vbLessThan & "example" & vbGreaterThan & "Example: mpicc main.c /out:foobar.exe" & vbLessThan & "/example" & vbGreaterThan)
	fout.WriteLine("    " & vbLessThan & "/runtime" & vbGreaterThan)
	fout.WriteLine(vbLessThan & "script language=""VBScript""" & vbGreaterThan)
	fout.WriteLine("")
	fout.WriteLine("' Set defaults")
	fout.WriteLine("outputExe = ""myapp.exe""")
	fout.WriteLine("")
	fout.WriteLine("If WScript.Arguments.Unnamed.Count = 0 Then")
	fout.WriteLine("    WScript.Arguments.ShowUsage")
	fout.WriteLine("    WScript.Quit")
	fout.WriteLine("End If")
	fout.WriteLine("")
	fout.WriteLine("Set f = WScript.CreateObject(""Scripting.FileSystemObject"")")
	fout.WriteLine("")
	fout.WriteLine("' Process named arguments")
	fout.WriteLine("If WScript.Arguments.Named.Exists(""out"") Then")
	fout.WriteLine("	outputExe = WScript.Arguments.Named.Item(""out"")")
	fout.WriteLine("End If")
	fout.WriteLine("")
	fout.WriteLine("' Create a new instance of Visual Studio .NET.")
	fout.WriteLine("Set DTE = WScript.CreateObject(""VisualStudio.DTE.7.1"")")
	fout.WriteLine("Set solution = DTE.Solution")
	if bVS2005 then
	    fout.WriteLine("solution.Open(""" & path_to_mpich & "examples\windows\skeleton\skeleton.vs05.sln"")")
	else
	    fout.WriteLine("solution.Open(""" & path_to_mpich & "examples\windows\skeleton\skeleton.sln"")")
	end if
	fout.WriteLine("Set project = solution.Projects.Item(1)")
	fout.WriteLine("")
	fout.WriteLine("' Add the C files to the project")
	fout.WriteLine("Set Cfiles = WScript.Arguments.Unnamed")
	fout.WriteLine("For arg = 0 To Cfiles.Count - 1")
	fout.WriteLine("	Cfile = Cfiles(arg)")
	fout.WriteLine("	Cfile = f.GetAbsolutePathName(Cfile)")
	fout.WriteLine("	project.ProjectItems.AddFromFile(Cfile)")
	fout.WriteLine("Next")
	fout.WriteLine("")
	fout.WriteLine("' Build the solution")
	fout.WriteLine("solution.SolutionBuild.Build()")
	fout.WriteLine("")
	fout.WriteLine("While solution.SolutionBuild.BuildState " & vbLessThan & vbGreaterThan & " 3")
	fout.WriteLine("	WScript.Sleep 1000")
	fout.WriteLine("Wend")
	fout.WriteLine("")
	fout.WriteLine("' Save the output on error")
	fout.WriteLine("If solution.SolutionBuild.LastBuildInfo " & vbLessThan & vbGreaterThan & " 0 Then")
	fout.WriteLine("	WScript.Echo ""Build failed""")
	fout.WriteLine("	Set shell = WScript.CreateObject(""WScript.shell"")")
	fout.WriteLine("	shell.run """ & path_to_mpich & "examples\windows\skeleton\Debug\BuildLog.htm""")
	fout.WriteLine("End If")
	fout.WriteLine("")
	fout.WriteLine("' Remove the C files from the project")
	fout.WriteLine("For i = 1 To project.ProjectItems.Count")
	fout.WriteLine("	If project.ProjectItems.Item(i).Name = ""Source Files"" Then")
	fout.WriteLine("		index = i")
	fout.WriteLine("	End If")
	fout.WriteLine("Next")
	fout.WriteLine("For arg = 0 To Cfiles.Count - 1")
	fout.WriteLine("	Cfile = Cfiles(arg)")
	fout.WriteLine("	Cfile = f.GetFileName(Cfile)")
	fout.WriteLine("	For i = project.ProjectItems.Item(index).ProjectItems.Count To 1 Step -1")
	fout.WriteLine("		If project.ProjectItems.Item(index).ProjectItems.Item(i).Name = Cfile Then")
	fout.WriteLine("			project.ProjectItems.Item(index).ProjectItems.Item(i).Remove()")
	fout.WriteLine("		End If")
	fout.WriteLine("	Next")
	fout.WriteLine("Next")
	fout.WriteLine("")
	fout.WriteLine("' Copy the executable")
	fout.WriteLine("If f.FileExists(""" & path_to_mpich & "examples\windows\skeleton\Debug\skeleton.exe"") Then")
	fout.WriteLine("	f.CopyFile """ & path_to_mpich & "examples\windows\skeleton\Debug\skeleton.exe"", outputExe, True")
	fout.WriteLine("End If")
	fout.WriteLine("")
	fout.WriteLine("' Clean up")
	fout.WriteLine("solution.SolutionBuild.Clean()")
	fout.WriteLine("")
	fout.WriteLine(vbLessThan & "/script" & vbGreaterThan)
	fout.WriteLine(vbLessThan & "/job" & vbGreaterThan)
	fout.WriteLine(vbLessThan & "/package" & vbGreaterThan)
	fout.Close()
End Function

GenerateMPICC()

Function ReplaceBetweenTags(str, tag1, find_str, tag2, replace_str)
	Dim index, left_str, right_str, start_index, end_index
	index = InStr(str, find_str)
	If index = 0 Then
		'MsgBox find_str & " not found in: " & str
		ReplaceBetweenTags = str
		Exit Function
	End If
	left_str = Left(str, index)
	right_str = Right(str, Len(str) - index)
	start_index = InStrRev(left_str, tag1)
	If start_index = 0 Then
		'MsgBox tag1 & " not found in: " & left_str
		ReplaceBetweenTags = str
		Exit Function
	End If
	end_index = InStr(right_str, tag2)
	If end_index = 0 Then
		'MsgBox tag2 & " not found in: " & right_str
		ReplaceBetweenTags = str
		Exit Function
	End If
	end_index = end_index + index
	ReplaceBetweenTags = Left(str, start_index-1) & replace_str & Right(str, Len(str) - end_index - Len(tag2) + 1)
End Function

If bRemoveFortran Then
	'Dim regEx, Match, Matches
	Set regEx = New RegExp
	regEx.IgnoreCase = False
	regEx.Global = True

	' mpich2.def
	'  remove:
	'	MPIPRIV
	'	MPIR_Keyval_set_fortran
	'	MPIR_Keyval_set_fortran90
	'	MPIR_Grequest_set_lang_f77
	Set fin = f.OpenTextFile("mpich2.def")
	contents = fin.ReadAll()
	fin.Close()
	regEx.Pattern = "(.*MPIPRIV.*)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPIR_Keyval_set_fortran)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPIR_Grequest_set_lang_f77)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPIR_F_MPI_BOTTOM)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPI_F_STATUS_IGNORE)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPI_F_STATUSES_IGNORE)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPI_F_ERRCODES_IGNORE)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*MPI_F_ARGVS_NULL)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*[P]?MPI_Status_c2f)"
	contents = regEx.Replace(contents, ";$1")
	regEx.Pattern = "(.*[P]?MPI_Status_f2c)"
	contents = regEx.Replace(contents, ";$1")
	cEcho "Creating mpich2.def"
	Set fout = f.CreateTextFile( "mpich2.def" )
	fout.Write(contents)
	fout.Close()

	' mpich2.sln
	'  remove:
	'	Project(..."mpich2f"...EndProject
	'   Project(..."mpich2ff"...EndProject
	'   fortDebug = fortDebug
	'   fortRelease = fortRelease
	'   gfortDebug = gfortDebug
	'   gfortRelease = gfortRelease
	'   sfortDebug = sfortDebug
	'   sfortRelease = sfortRelease
	'   *.fortDebug.*
	'   *.fortRelease.*
	'   *.gfortDebug.*
	'   *.gfortRelease.*
	'   *.sfortDebug.*
	'   *.sfortRelease.*
	'   *= fortDebug|Win32
	'   *= fortRelease|Win32
	'   *= gfortDebug|Win32
	'   *= gfortRelease|Win32
	'   *= sfortDebug|Win32
	'   *= sfortRelease|Win32
	if bVS2005 then
	    Set fin = f.OpenTextFile( "mpich2.vs05.sln" )
	else
	    Set fin = f.OpenTextFile( "mpich2.sln" )
	end if
	contents = fin.ReadAll()
	fin.Close()
	regEx.Pattern = "Project\(.*""mpich2ff?"".*\s*.*\s*.*\s*.*EndProject[\r\n]*"
	contents = regEx.Replace(contents, "")
	regEx.Pattern = ".*[gs]?fortDebug = [gs]?fortDebug.*[\r\n]*"
	contents = regEx.Replace(contents, "")
	regEx.Pattern = ".*[gs]?fortRelease = [gs]?fortRelease.*[\r\n]*"
	contents = regEx.Replace(contents, "")
	regEx.Pattern = ".*\.[gs]*fortDebug\..*[\r\n]*"
	contents = regEx.Replace(contents, "")
	regEx.Pattern = ".*\.[gs]*fortRelease\..*[\r\n]*"
	contents = regEx.Replace(contents, "")
	regEx.Pattern = ".*= [gs]?fortDebug\|Win32[\r\n]*"
	contents = regEx.Replace(contents, "")
	regEx.Pattern = ".*= [gs]?fortRelease\|Win32[\r\n]*"
	contents = regEx.Replace(contents, "")
	if bVS2005 then
		cEcho "Creating mpich2.vs05.sln"
	    Set fout = f.CreateTextFile( "mpich2.vs05.sln" )
	else
		cEcho "Creating mpich2.sln"
	    Set fout = f.CreateTextFile( "mpich2.sln" )
	end if
	fout.Write(contents)
	fout.Close()
	
	' mpich2.vcproj
	'  remove:
	'   ,HAVE_FORTRAN_BINDING
	'   mpich2ffd.lib
	'   mpich2ff.lib
	if bVS2005 then
	    Set fin = f.OpenTextFile( "mpich2.vs05.vcproj" )
	else
	    Set fin = f.OpenTextFile( "mpich2.vcproj" )
	end if
	contents = fin.ReadAll()
	fin.Close()
	contents = Replace(contents, ",HAVE_FORTRAN_BINDING", "")
	contents = Replace(contents, ";HAVE_FORTRAN_BINDING", "")
	contents = Replace(contents, "mpich2ffd.lib", "")
	contents = Replace(contents, "mpich2ff.lib", "")
	'regEx.Pattern = ".*<File.*\s*.*c2f\.c\s*.*</File>.*[\r\n]*"
	'contents = regEx.Replace(contents, "")
	'regEx.Pattern = ".*<File.*\s*.*f2c\.c\s*.*</File>.*[\r\n]*"
	'contents = regEx.Replace(contents, "")
	'regEx.Pattern = ".*<File.*\s*.*setbot\.c.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*</File>.*[\r\n]+"
	'contents = regEx.Replace(contents, "")
	contents = ReplaceBetweenTags(contents, "<File", "statusc2f.c", "</File>", "")
	contents = ReplaceBetweenTags(contents, "<File", "statusf2c.c", "</File>", "")
	contents = ReplaceBetweenTags(contents, "<File", "setbot.c", "</File>", "")
	if bVS2005 then
		cEcho "Creating mpich2.vs05.vcproj"
	    Set fout = f.CreateTextFile( "mpich2.vs05.vcproj" )
	else
		cEcho "Creating mpich2.vcproj"
	    Set fout = f.CreateTextFile( "mpich2.vcproj" )
	end if
	fout.Write(contents)
	fout.Close()

	' mpich2s.vcproj
	'  remove:
	'   lib\mpich2ffd.lib
	'   lib\mpich2ff.lib
	if bVS2005 then
	    Set fin = f.OpenTextFile( "mpich2s.vs05.vcproj" )
	else
	    Set fin = f.OpenTextFile( "mpich2s.vcproj" )
	end if
	contents = fin.ReadAll()
	fin.Close()
	contents = Replace(contents, ",HAVE_FORTRAN_BINDING", "")
	contents = Replace(contents, ";HAVE_FORTRAN_BINDING", "")
	contents = Replace(contents, "lib\mpich2ffd.lib", "")
	contents = Replace(contents, "lib\mpich2ff.lib", "")
	'regEx.Pattern = ".*<File.*\s*.*c2f\.c\s*.*</File>.*[\r\n]*"
	'contents = regEx.Replace(contents, "")
	'regEx.Pattern = ".*<File.*\s*.*f2c\.c\s*.*</File>.*[\r\n]*"
	'contents = regEx.Replace(contents, "")
	'regEx.Pattern = ".*<File.*\s*.*setbot\.c.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*[\r\n]+.*</File>.*[\r\n]+"
	'contents = regEx.Replace(contents, "")
	contents = ReplaceBetweenTags(contents, "<File", "statusc2f.c", "</File>", "")
	contents = ReplaceBetweenTags(contents, "<File", "statusf2c.c", "</File>", "")
	contents = ReplaceBetweenTags(contents, "<File", "setbot.c", "</File>", "")
	if bVS2005 then
		cEcho "Creating mpich2s.vs05.vcproj"
	    Set fout = f.CreateTextFile( "mpich2s.vs05.vcproj" )
	else
		cEcho "Creating mpich2s.vcproj"
	    Set fout = f.CreateTextFile( "mpich2s.vcproj" )
	end if
	fout.Write(contents)
	fout.Close()

	' maint\mpich2i.vdproj
	'  remove:
	'   lots of stuff
End If

'
' Move the mpi binding implementation from the smpd directory to the src\binding\mpi directory
'
'If Not f.FolderExists("src\binding\mpi") Then
'	f.CreateFolder("src\binding\mpi")
'End If
'If Not f.FileExists("src\binding\mpi\mpi.c") Then
'	f.CopyFile("src\pm\smpd\mpi.c", "src\binding\mpi\")
'End If

'
' Report any errors
'
If unhandled_definitions <> "" Then
	If bEcho Then
		WScript.Echo "Unhandled definitions:" & vbNewLine & unhandled_definitions
	else
		MsgBox "Unhandled definitions:" & vbNewLine & unhandled_definitions
	End If
End If
If unhandled_ats <> "" Then
	If bEcho Then
		WScript.Echo "Unhandled @foo@'s:" & vbNewLine & unhandled_ats
	else
		MsgBox "Unhandled @foo@'s:" & vbNewLine & unhandled_ats
	End If
End If

</script>
</job>
</package>
